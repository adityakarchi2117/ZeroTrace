"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/storage.ts":
/*!****************************!*\
  !*** ./src/lib/storage.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   localStorageManager: function() { return /* binding */ localStorageManager; }\n/* harmony export */ });\n/**\r\n * CipherLink Local Storage Manager\r\n * Production-grade IndexedDB implementation for persistent chat history\r\n */ class LocalStorageManager {\n    async init() {\n        return new Promise((resolve, reject)=>{\n            const request = indexedDB.open(this.dbName, this.version);\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = ()=>{\n                this.db = request.result;\n                resolve();\n            };\n            request.onupgradeneeded = (event)=>{\n                const db = event.target.result;\n                // Messages store\n                if (!db.objectStoreNames.contains(\"messages\")) {\n                    const messageStore = db.createObjectStore(\"messages\", {\n                        keyPath: \"id\"\n                    });\n                    messageStore.createIndex(\"conversation\", [\n                        \"sender_username\",\n                        \"recipient_username\"\n                    ], {\n                        unique: false\n                    });\n                    messageStore.createIndex(\"recipient\", \"recipient_username\", {\n                        unique: false\n                    });\n                    messageStore.createIndex(\"sender\", \"sender_username\", {\n                        unique: false\n                    });\n                    messageStore.createIndex(\"created_at\", \"created_at\", {\n                        unique: false\n                    });\n                }\n                // Conversations store\n                if (!db.objectStoreNames.contains(\"conversations\")) {\n                    const convStore = db.createObjectStore(\"conversations\", {\n                        keyPath: \"username\"\n                    });\n                    convStore.createIndex(\"last_message_time\", \"last_message_time\", {\n                        unique: false\n                    });\n                }\n                // Contacts store\n                if (!db.objectStoreNames.contains(\"contacts\")) {\n                    const contactStore = db.createObjectStore(\"contacts\", {\n                        keyPath: \"id\"\n                    });\n                    contactStore.createIndex(\"contact_username\", \"contact_username\", {\n                        unique: false\n                    });\n                }\n                // Sync metadata store\n                if (!db.objectStoreNames.contains(\"sync_metadata\")) {\n                    db.createObjectStore(\"sync_metadata\", {\n                        keyPath: \"key\"\n                    });\n                }\n            };\n        });\n    }\n    // ============ Messages ============\n    async saveMessage(message) {\n        if (!this.db) await this.init();\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                \"messages\"\n            ], \"readwrite\");\n            const store = transaction.objectStore(\"messages\");\n            const request = store.put(message);\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = ()=>resolve();\n        });\n    }\n    async saveMessages(messages) {\n        if (!this.db) await this.init();\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                \"messages\"\n            ], \"readwrite\");\n            const store = transaction.objectStore(\"messages\");\n            let completed = 0;\n            const total = messages.length;\n            if (total === 0) {\n                resolve();\n                return;\n            }\n            messages.forEach((message)=>{\n                const request = store.put(message);\n                request.onsuccess = ()=>{\n                    completed++;\n                    if (completed === total) resolve();\n                };\n                request.onerror = ()=>reject(request.error);\n            });\n        });\n    }\n    async getConversationMessages(username, currentUsername) {\n        let limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 50;\n        if (!this.db) await this.init();\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                \"messages\"\n            ], \"readonly\");\n            const store = transaction.objectStore(\"messages\");\n            const messages = [];\n            const request = store.openCursor();\n            request.onsuccess = (event)=>{\n                const cursor = event.target.result;\n                if (cursor) {\n                    const message = cursor.value;\n                    // Check if message is part of conversation\n                    const isConversationMessage = message.sender_username === username && message.recipient_username === currentUsername || message.sender_username === currentUsername && message.recipient_username === username;\n                    if (isConversationMessage) {\n                        messages.push(message);\n                    }\n                    cursor.continue();\n                } else {\n                    // Sort by created_at and limit\n                    messages.sort((a, b)=>new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n                    resolve(messages.slice(-limit)); // Get last N messages\n                }\n            };\n            request.onerror = ()=>reject(request.error);\n        });\n    }\n    async getAllMessages() {\n        if (!this.db) await this.init();\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                \"messages\"\n            ], \"readonly\");\n            const store = transaction.objectStore(\"messages\");\n            const request = store.getAll();\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = ()=>resolve(request.result);\n        });\n    }\n    // ============ Conversations ============\n    async saveConversation(conversation) {\n        if (!this.db) await this.init();\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                \"conversations\"\n            ], \"readwrite\");\n            const store = transaction.objectStore(\"conversations\");\n            const request = store.put(conversation);\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = ()=>resolve();\n        });\n    }\n    async saveConversations(conversations) {\n        if (!this.db) await this.init();\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                \"conversations\"\n            ], \"readwrite\");\n            const store = transaction.objectStore(\"conversations\");\n            let completed = 0;\n            const total = conversations.length;\n            if (total === 0) {\n                resolve();\n                return;\n            }\n            conversations.forEach((conversation)=>{\n                const request = store.put(conversation);\n                request.onsuccess = ()=>{\n                    completed++;\n                    if (completed === total) resolve();\n                };\n                request.onerror = ()=>reject(request.error);\n            });\n        });\n    }\n    async getAllConversations() {\n        if (!this.db) await this.init();\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                \"conversations\"\n            ], \"readonly\");\n            const store = transaction.objectStore(\"conversations\");\n            const request = store.getAll();\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = ()=>resolve(request.result);\n        });\n    }\n    // ============ Contacts ============\n    async saveContact(contact) {\n        if (!this.db) await this.init();\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                \"contacts\"\n            ], \"readwrite\");\n            const store = transaction.objectStore(\"contacts\");\n            const request = store.put(contact);\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = ()=>resolve();\n        });\n    }\n    async saveContacts(contacts) {\n        if (!this.db) await this.init();\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                \"contacts\"\n            ], \"readwrite\");\n            const store = transaction.objectStore(\"contacts\");\n            let completed = 0;\n            const total = contacts.length;\n            if (total === 0) {\n                resolve();\n                return;\n            }\n            contacts.forEach((contact)=>{\n                const request = store.put(contact);\n                request.onsuccess = ()=>{\n                    completed++;\n                    if (completed === total) resolve();\n                };\n                request.onerror = ()=>reject(request.error);\n            });\n        });\n    }\n    async getAllContacts() {\n        if (!this.db) await this.init();\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                \"contacts\"\n            ], \"readonly\");\n            const store = transaction.objectStore(\"contacts\");\n            const request = store.getAll();\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = ()=>resolve(request.result);\n        });\n    }\n    // ============ Sync Metadata ============\n    async setSyncTimestamp(key, timestamp) {\n        if (!this.db) await this.init();\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                \"sync_metadata\"\n            ], \"readwrite\");\n            const store = transaction.objectStore(\"sync_metadata\");\n            const request = store.put({\n                key,\n                timestamp\n            });\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = ()=>resolve();\n        });\n    }\n    async getSyncTimestamp(key) {\n        if (!this.db) await this.init();\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                \"sync_metadata\"\n            ], \"readonly\");\n            const store = transaction.objectStore(\"sync_metadata\");\n            const request = store.get(key);\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = ()=>{\n                const result = request.result;\n                resolve(result ? result.timestamp : null);\n            };\n        });\n    }\n    // ============ Cleanup ============\n    async clearAllData() {\n        if (!this.db) await this.init();\n        const stores = [\n            \"messages\",\n            \"conversations\",\n            \"contacts\",\n            \"sync_metadata\"\n        ];\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction(stores, \"readwrite\");\n            let completed = 0;\n            stores.forEach((storeName)=>{\n                const store = transaction.objectStore(storeName);\n                const request = store.clear();\n                request.onsuccess = ()=>{\n                    completed++;\n                    if (completed === stores.length) resolve();\n                };\n                request.onerror = ()=>reject(request.error);\n            });\n        });\n    }\n    async deleteConversation(username) {\n        if (!this.db) await this.init();\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                \"conversations\",\n                \"messages\"\n            ], \"readwrite\");\n            // Delete conversation\n            const convStore = transaction.objectStore(\"conversations\");\n            convStore.delete(username);\n            // Delete all messages in conversation\n            const msgStore = transaction.objectStore(\"messages\");\n            const request = msgStore.openCursor();\n            request.onsuccess = (event)=>{\n                const cursor = event.target.result;\n                if (cursor) {\n                    const message = cursor.value;\n                    if (message.sender_username === username || message.recipient_username === username) {\n                        cursor.delete();\n                    }\n                    cursor.continue();\n                } else {\n                    resolve();\n                }\n            };\n            request.onerror = ()=>reject(request.error);\n        });\n    }\n    // ============ Message Deletion ============\n    async deleteMessage(messageId) {\n        if (!this.db) await this.init();\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                \"messages\"\n            ], \"readwrite\");\n            const store = transaction.objectStore(\"messages\");\n            const request = store.delete(messageId);\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = ()=>resolve();\n        });\n    }\n    async markMessageAsDeleted(messageId) {\n        if (!this.db) await this.init();\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                \"messages\"\n            ], \"readwrite\");\n            const store = transaction.objectStore(\"messages\");\n            const getRequest = store.get(messageId);\n            getRequest.onsuccess = ()=>{\n                const message = getRequest.result;\n                if (message) {\n                    // Mark as deleted but preserve metadata\n                    message.encrypted_content = JSON.stringify({\n                        deleted: true\n                    });\n                    message.message_type = \"deleted\";\n                    message.status = \"deleted\";\n                    const updateRequest = store.put(message);\n                    updateRequest.onsuccess = ()=>resolve();\n                    updateRequest.onerror = ()=>reject(updateRequest.error);\n                } else {\n                    resolve();\n                }\n            };\n            getRequest.onerror = ()=>reject(getRequest.error);\n        });\n    }\n    async clearConversationMessages(username, currentUsername) {\n        if (!this.db) await this.init();\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                \"messages\"\n            ], \"readwrite\");\n            const store = transaction.objectStore(\"messages\");\n            const request = store.openCursor();\n            request.onsuccess = (event)=>{\n                const cursor = event.target.result;\n                if (cursor) {\n                    const message = cursor.value;\n                    // Check if message is part of conversation\n                    const isConversationMessage = message.sender_username === username && message.recipient_username === currentUsername || message.sender_username === currentUsername && message.recipient_username === username;\n                    if (isConversationMessage) {\n                        cursor.delete();\n                    }\n                    cursor.continue();\n                } else {\n                    resolve();\n                }\n            };\n            request.onerror = ()=>reject(request.error);\n        });\n    }\n    constructor(){\n        this.db = null;\n        this.dbName = \"CipherLinkDB\";\n        this.version = 1;\n    }\n}\n// Export singleton instance\nconst localStorageManager = new LocalStorageManager();\n// Auto-initialize on import\nif (true) {\n    localStorageManager.init().catch(console.error);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUU3QixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0IsTUFBTXlCLGNBQWMsSUFBSSxDQUFDaEIsRUFBRSxDQUFFZ0IsV0FBVyxDQUFDO2dCQUFDO2FBQVcsRUFBRTtZQUN2RCxNQUFNQyxRQUFRRCxZQUFZRSxXQUFXLENBQUM7WUFDdEMsTUFBTTFCLFVBQVV5QixNQUFNYSxVQUFVO1lBRWhDdEMsUUFBUU8sU0FBUyxHQUFHLENBQUNJO2dCQUNuQixNQUFNNEIsU0FBUyxNQUFPM0IsTUFBTSxDQUFnQkgsTUFBTTtnQkFDbEQsSUFBSThCLFFBQVE7b0JBQ1YsTUFBTWhCLFVBQVVnQixPQUFPQyxLQUFLO29CQUM1QiwyQ0FBMkM7b0JBQzNDLE1BQU1DLHdCQUNKLFFBQVNDLGVBQWUsS0FBS1AsWUFBWVosUUFBUW9CLGtCQUFrQixLQUFLUCxtQkFDdkViLFFBQVFtQixlQUFlLEtBQUtOLG1CQUFtQmIsUUFBUW9CLGtCQUFrQixLQUFLUjtvQkFFakYsSUFBSU0sdUJBQXVCO3dCQUN6QkYsT0FBT29DLE1BQU07b0JBQ2Y7b0JBQ0FwQyxPQUFPTSxRQUFRO2dCQUNqQixPQUFPO29CQUNML0M7Z0JBQ0Y7WUFDRjtZQUVBRSxRQUFRSyxPQUFPLEdBQUcsSUFBTU4sT0FBT0MsUUFBUU0sS0FBSztRQUM5QztJQUNGOzthQWhaUUUsS0FBeUI7YUFDekJMLFNBQVM7YUFDVEMsVUFBVTs7QUErWXBCO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU1xRixzQkFBc0IsSUFBSTlGLHNCQUFzQjtBQUU3RCw0QkFBNEI7QUFDNUIsSUFBSSxJQUFrQixFQUFhO0lBQ2pDOEYsb0JBQW9CN0YsSUFBSSxHQUFHOEYsS0FBSyxDQUFDQyxRQUFRckYsS0FBSztBQUNoRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3N0b3JhZ2UudHM/YWZlOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ2lwaGVyTGluayBMb2NhbCBTdG9yYWdlIE1hbmFnZXJcclxuICogUHJvZHVjdGlvbi1ncmFkZSBJbmRleGVkREIgaW1wbGVtZW50YXRpb24gZm9yIHBlcnNpc3RlbnQgY2hhdCBoaXN0b3J5XHJcbiAqL1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTdG9yZWRNZXNzYWdlIHtcclxuICBpZDogbnVtYmVyO1xyXG4gIHNlbmRlcl9pZDogbnVtYmVyO1xyXG4gIHNlbmRlcl91c2VybmFtZTogc3RyaW5nO1xyXG4gIHJlY2lwaWVudF9pZDogbnVtYmVyO1xyXG4gIHJlY2lwaWVudF91c2VybmFtZTogc3RyaW5nO1xyXG4gIGVuY3J5cHRlZF9jb250ZW50OiBzdHJpbmc7XHJcbiAgZW5jcnlwdGVkX2tleT86IHN0cmluZztcclxuICBtZXNzYWdlX3R5cGU6IHN0cmluZztcclxuICBzdGF0dXM6IHN0cmluZztcclxuICBjcmVhdGVkX2F0OiBzdHJpbmc7XHJcbiAgZGVsaXZlcmVkX2F0Pzogc3RyaW5nO1xyXG4gIHJlYWRfYXQ/OiBzdHJpbmc7XHJcbiAgZXhwaXJ5X3R5cGU6IHN0cmluZztcclxuICBleHBpcmVzX2F0Pzogc3RyaW5nO1xyXG4gIGZpbGVfbWV0YWRhdGE/OiBhbnk7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RvcmVkQ29udmVyc2F0aW9uIHtcclxuICB1c2VybmFtZTogc3RyaW5nO1xyXG4gIHVzZXJfaWQ6IG51bWJlcjtcclxuICBwdWJsaWNfa2V5Pzogc3RyaW5nO1xyXG4gIGlkZW50aXR5X2tleT86IHN0cmluZztcclxuICBsYXN0X21lc3NhZ2VfdGltZT86IHN0cmluZztcclxuICBsYXN0X21lc3NhZ2VfcHJldmlldz86IHN0cmluZztcclxuICB1bnJlYWRfY291bnQ6IG51bWJlcjtcclxuICBpc19vbmxpbmU6IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RvcmVkQ29udGFjdCB7XHJcbiAgaWQ6IG51bWJlcjtcclxuICB1c2VyX2lkOiBudW1iZXI7XHJcbiAgY29udGFjdF9pZDogbnVtYmVyO1xyXG4gIGNvbnRhY3RfdXNlcm5hbWU6IHN0cmluZztcclxuICBjb250YWN0X2VtYWlsOiBzdHJpbmc7XHJcbiAgcHVibGljX2tleT86IHN0cmluZztcclxuICBpZGVudGl0eV9rZXk/OiBzdHJpbmc7XHJcbiAgbmlja25hbWU/OiBzdHJpbmc7XHJcbiAgaXNfYmxvY2tlZDogYm9vbGVhbjtcclxuICBpc192ZXJpZmllZDogYm9vbGVhbjtcclxuICBhZGRlZF9hdDogc3RyaW5nO1xyXG59XHJcblxyXG5jbGFzcyBMb2NhbFN0b3JhZ2VNYW5hZ2VyIHtcclxuICBwcml2YXRlIGRiOiBJREJEYXRhYmFzZSB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgZGJOYW1lID0gJ0NpcGhlckxpbmtEQic7XHJcbiAgcHJpdmF0ZSB2ZXJzaW9uID0gMTtcclxuXHJcbiAgYXN5bmMgaW5pdCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLmRiTmFtZSwgdGhpcy52ZXJzaW9uKTtcclxuXHJcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcclxuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5kYiA9IHJlcXVlc3QucmVzdWx0O1xyXG4gICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGIgPSAoZXZlbnQudGFyZ2V0IGFzIElEQk9wZW5EQlJlcXVlc3QpLnJlc3VsdDtcclxuXHJcbiAgICAgICAgLy8gTWVzc2FnZXMgc3RvcmVcclxuICAgICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJ21lc3NhZ2VzJykpIHtcclxuICAgICAgICAgIGNvbnN0IG1lc3NhZ2VTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdtZXNzYWdlcycsIHsga2V5UGF0aDogJ2lkJyB9KTtcclxuICAgICAgICAgIG1lc3NhZ2VTdG9yZS5jcmVhdGVJbmRleCgnY29udmVyc2F0aW9uJywgWydzZW5kZXJfdXNlcm5hbWUnLCAncmVjaXBpZW50X3VzZXJuYW1lJ10sIHsgdW5pcXVlOiBmYWxzZSB9KTtcclxuICAgICAgICAgIG1lc3NhZ2VTdG9yZS5jcmVhdGVJbmRleCgncmVjaXBpZW50JywgJ3JlY2lwaWVudF91c2VybmFtZScsIHsgdW5pcXVlOiBmYWxzZSB9KTtcclxuICAgICAgICAgIG1lc3NhZ2VTdG9yZS5jcmVhdGVJbmRleCgnc2VuZGVyJywgJ3NlbmRlcl91c2VybmFtZScsIHsgdW5pcXVlOiBmYWxzZSB9KTtcclxuICAgICAgICAgIG1lc3NhZ2VTdG9yZS5jcmVhdGVJbmRleCgnY3JlYXRlZF9hdCcsICdjcmVhdGVkX2F0JywgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29udmVyc2F0aW9ucyBzdG9yZVxyXG4gICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnY29udmVyc2F0aW9ucycpKSB7XHJcbiAgICAgICAgICBjb25zdCBjb252U3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZSgnY29udmVyc2F0aW9ucycsIHsga2V5UGF0aDogJ3VzZXJuYW1lJyB9KTtcclxuICAgICAgICAgIGNvbnZTdG9yZS5jcmVhdGVJbmRleCgnbGFzdF9tZXNzYWdlX3RpbWUnLCAnbGFzdF9tZXNzYWdlX3RpbWUnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb250YWN0cyBzdG9yZVxyXG4gICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnY29udGFjdHMnKSkge1xyXG4gICAgICAgICAgY29uc3QgY29udGFjdFN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ2NvbnRhY3RzJywgeyBrZXlQYXRoOiAnaWQnIH0pO1xyXG4gICAgICAgICAgY29udGFjdFN0b3JlLmNyZWF0ZUluZGV4KCdjb250YWN0X3VzZXJuYW1lJywgJ2NvbnRhY3RfdXNlcm5hbWUnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTeW5jIG1ldGFkYXRhIHN0b3JlXHJcbiAgICAgICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCdzeW5jX21ldGFkYXRhJykpIHtcclxuICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdzeW5jX21ldGFkYXRhJywgeyBrZXlQYXRoOiAna2V5JyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PSBNZXNzYWdlcyA9PT09PT09PT09PT1cclxuXHJcbiAgYXN5bmMgc2F2ZU1lc3NhZ2UobWVzc2FnZTogU3RvcmVkTWVzc2FnZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKCF0aGlzLmRiKSBhd2FpdCB0aGlzLmluaXQoKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIhLnRyYW5zYWN0aW9uKFsnbWVzc2FnZXMnXSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdtZXNzYWdlcycpO1xyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUucHV0KG1lc3NhZ2UpO1xyXG5cclxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xyXG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2F2ZU1lc3NhZ2VzKG1lc3NhZ2VzOiBTdG9yZWRNZXNzYWdlW10pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGlmICghdGhpcy5kYikgYXdhaXQgdGhpcy5pbml0KCk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiIS50cmFuc2FjdGlvbihbJ21lc3NhZ2VzJ10sICdyZWFkd3JpdGUnKTtcclxuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnbWVzc2FnZXMnKTtcclxuXHJcbiAgICAgIGxldCBjb21wbGV0ZWQgPSAwO1xyXG4gICAgICBjb25zdCB0b3RhbCA9IG1lc3NhZ2VzLmxlbmd0aDtcclxuXHJcbiAgICAgIGlmICh0b3RhbCA9PT0gMCkge1xyXG4gICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG1lc3NhZ2VzLmZvckVhY2gobWVzc2FnZSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLnB1dChtZXNzYWdlKTtcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcclxuICAgICAgICAgIGNvbXBsZXRlZCsrO1xyXG4gICAgICAgICAgaWYgKGNvbXBsZXRlZCA9PT0gdG90YWwpIHJlc29sdmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldENvbnZlcnNhdGlvbk1lc3NhZ2VzKHVzZXJuYW1lOiBzdHJpbmcsIGN1cnJlbnRVc2VybmFtZTogc3RyaW5nLCBsaW1pdDogbnVtYmVyID0gNTApOiBQcm9taXNlPFN0b3JlZE1lc3NhZ2VbXT4ge1xyXG4gICAgaWYgKCF0aGlzLmRiKSBhd2FpdCB0aGlzLmluaXQoKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIhLnRyYW5zYWN0aW9uKFsnbWVzc2FnZXMnXSwgJ3JlYWRvbmx5Jyk7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ21lc3NhZ2VzJyk7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2VzOiBTdG9yZWRNZXNzYWdlW10gPSBbXTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5vcGVuQ3Vyc29yKCk7XHJcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgY3Vyc29yID0gKGV2ZW50LnRhcmdldCBhcyBJREJSZXF1ZXN0KS5yZXN1bHQ7XHJcbiAgICAgICAgaWYgKGN1cnNvcikge1xyXG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGN1cnNvci52YWx1ZSBhcyBTdG9yZWRNZXNzYWdlO1xyXG5cclxuICAgICAgICAgIC8vIENoZWNrIGlmIG1lc3NhZ2UgaXMgcGFydCBvZiBjb252ZXJzYXRpb25cclxuICAgICAgICAgIGNvbnN0IGlzQ29udmVyc2F0aW9uTWVzc2FnZSA9XHJcbiAgICAgICAgICAgIChtZXNzYWdlLnNlbmRlcl91c2VybmFtZSA9PT0gdXNlcm5hbWUgJiYgbWVzc2FnZS5yZWNpcGllbnRfdXNlcm5hbWUgPT09IGN1cnJlbnRVc2VybmFtZSkgfHxcclxuICAgICAgICAgICAgKG1lc3NhZ2Uuc2VuZGVyX3VzZXJuYW1lID09PSBjdXJyZW50VXNlcm5hbWUgJiYgbWVzc2FnZS5yZWNpcGllbnRfdXNlcm5hbWUgPT09IHVzZXJuYW1lKTtcclxuXHJcbiAgICAgICAgICBpZiAoaXNDb252ZXJzYXRpb25NZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIFNvcnQgYnkgY3JlYXRlZF9hdCBhbmQgbGltaXRcclxuICAgICAgICAgIG1lc3NhZ2VzLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGEuY3JlYXRlZF9hdCkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi5jcmVhdGVkX2F0KS5nZXRUaW1lKCkpO1xyXG4gICAgICAgICAgcmVzb2x2ZShtZXNzYWdlcy5zbGljZSgtbGltaXQpKTsgLy8gR2V0IGxhc3QgTiBtZXNzYWdlc1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0QWxsTWVzc2FnZXMoKTogUHJvbWlzZTxTdG9yZWRNZXNzYWdlW10+IHtcclxuICAgIGlmICghdGhpcy5kYikgYXdhaXQgdGhpcy5pbml0KCk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiIS50cmFuc2FjdGlvbihbJ21lc3NhZ2VzJ10sICdyZWFkb25seScpO1xyXG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdtZXNzYWdlcycpO1xyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0QWxsKCk7XHJcblxyXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XHJcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZShyZXF1ZXN0LnJlc3VsdCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PSBDb252ZXJzYXRpb25zID09PT09PT09PT09PVxyXG5cclxuICBhc3luYyBzYXZlQ29udmVyc2F0aW9uKGNvbnZlcnNhdGlvbjogU3RvcmVkQ29udmVyc2F0aW9uKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAoIXRoaXMuZGIpIGF3YWl0IHRoaXMuaW5pdCgpO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYiEudHJhbnNhY3Rpb24oWydjb252ZXJzYXRpb25zJ10sICdyZWFkd3JpdGUnKTtcclxuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnY29udmVyc2F0aW9ucycpO1xyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUucHV0KGNvbnZlcnNhdGlvbik7XHJcblxyXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XHJcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzYXZlQ29udmVyc2F0aW9ucyhjb252ZXJzYXRpb25zOiBTdG9yZWRDb252ZXJzYXRpb25bXSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKCF0aGlzLmRiKSBhd2FpdCB0aGlzLmluaXQoKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIhLnRyYW5zYWN0aW9uKFsnY29udmVyc2F0aW9ucyddLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ2NvbnZlcnNhdGlvbnMnKTtcclxuXHJcbiAgICAgIGxldCBjb21wbGV0ZWQgPSAwO1xyXG4gICAgICBjb25zdCB0b3RhbCA9IGNvbnZlcnNhdGlvbnMubGVuZ3RoO1xyXG5cclxuICAgICAgaWYgKHRvdGFsID09PSAwKSB7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29udmVyc2F0aW9ucy5mb3JFYWNoKGNvbnZlcnNhdGlvbiA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLnB1dChjb252ZXJzYXRpb24pO1xyXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xyXG4gICAgICAgICAgY29tcGxldGVkKys7XHJcbiAgICAgICAgICBpZiAoY29tcGxldGVkID09PSB0b3RhbCkgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0QWxsQ29udmVyc2F0aW9ucygpOiBQcm9taXNlPFN0b3JlZENvbnZlcnNhdGlvbltdPiB7XHJcbiAgICBpZiAoIXRoaXMuZGIpIGF3YWl0IHRoaXMuaW5pdCgpO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYiEudHJhbnNhY3Rpb24oWydjb252ZXJzYXRpb25zJ10sICdyZWFkb25seScpO1xyXG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdjb252ZXJzYXRpb25zJyk7XHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5nZXRBbGwoKTtcclxuXHJcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcclxuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKHJlcXVlc3QucmVzdWx0KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gPT09PT09PT09PT09IENvbnRhY3RzID09PT09PT09PT09PVxyXG5cclxuICBhc3luYyBzYXZlQ29udGFjdChjb250YWN0OiBTdG9yZWRDb250YWN0KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAoIXRoaXMuZGIpIGF3YWl0IHRoaXMuaW5pdCgpO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYiEudHJhbnNhY3Rpb24oWydjb250YWN0cyddLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ2NvbnRhY3RzJyk7XHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5wdXQoY29udGFjdCk7XHJcblxyXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XHJcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzYXZlQ29udGFjdHMoY29udGFjdHM6IFN0b3JlZENvbnRhY3RbXSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKCF0aGlzLmRiKSBhd2FpdCB0aGlzLmluaXQoKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIhLnRyYW5zYWN0aW9uKFsnY29udGFjdHMnXSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdjb250YWN0cycpO1xyXG5cclxuICAgICAgbGV0IGNvbXBsZXRlZCA9IDA7XHJcbiAgICAgIGNvbnN0IHRvdGFsID0gY29udGFjdHMubGVuZ3RoO1xyXG5cclxuICAgICAgaWYgKHRvdGFsID09PSAwKSB7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29udGFjdHMuZm9yRWFjaChjb250YWN0ID0+IHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUucHV0KGNvbnRhY3QpO1xyXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xyXG4gICAgICAgICAgY29tcGxldGVkKys7XHJcbiAgICAgICAgICBpZiAoY29tcGxldGVkID09PSB0b3RhbCkgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0QWxsQ29udGFjdHMoKTogUHJvbWlzZTxTdG9yZWRDb250YWN0W10+IHtcclxuICAgIGlmICghdGhpcy5kYikgYXdhaXQgdGhpcy5pbml0KCk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiIS50cmFuc2FjdGlvbihbJ2NvbnRhY3RzJ10sICdyZWFkb25seScpO1xyXG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdjb250YWN0cycpO1xyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0QWxsKCk7XHJcblxyXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XHJcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZShyZXF1ZXN0LnJlc3VsdCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PSBTeW5jIE1ldGFkYXRhID09PT09PT09PT09PVxyXG5cclxuICBhc3luYyBzZXRTeW5jVGltZXN0YW1wKGtleTogc3RyaW5nLCB0aW1lc3RhbXA6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKCF0aGlzLmRiKSBhd2FpdCB0aGlzLmluaXQoKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIhLnRyYW5zYWN0aW9uKFsnc3luY19tZXRhZGF0YSddLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ3N5bmNfbWV0YWRhdGEnKTtcclxuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLnB1dCh7IGtleSwgdGltZXN0YW1wIH0pO1xyXG5cclxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xyXG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0U3luY1RpbWVzdGFtcChrZXk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gICAgaWYgKCF0aGlzLmRiKSBhd2FpdCB0aGlzLmluaXQoKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIhLnRyYW5zYWN0aW9uKFsnc3luY19tZXRhZGF0YSddLCAncmVhZG9ubHknKTtcclxuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnc3luY19tZXRhZGF0YScpO1xyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0KGtleSk7XHJcblxyXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XHJcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlcXVlc3QucmVzdWx0O1xyXG4gICAgICAgIHJlc29sdmUocmVzdWx0ID8gcmVzdWx0LnRpbWVzdGFtcCA6IG51bGwpO1xyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyA9PT09PT09PT09PT0gQ2xlYW51cCA9PT09PT09PT09PT1cclxuXHJcbiAgYXN5bmMgY2xlYXJBbGxEYXRhKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKCF0aGlzLmRiKSBhd2FpdCB0aGlzLmluaXQoKTtcclxuXHJcbiAgICBjb25zdCBzdG9yZXMgPSBbJ21lc3NhZ2VzJywgJ2NvbnZlcnNhdGlvbnMnLCAnY29udGFjdHMnLCAnc3luY19tZXRhZGF0YSddO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYiEudHJhbnNhY3Rpb24oc3RvcmVzLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgIGxldCBjb21wbGV0ZWQgPSAwO1xyXG5cclxuICAgICAgc3RvcmVzLmZvckVhY2goc3RvcmVOYW1lID0+IHtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmNsZWFyKCk7XHJcblxyXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xyXG4gICAgICAgICAgY29tcGxldGVkKys7XHJcbiAgICAgICAgICBpZiAoY29tcGxldGVkID09PSBzdG9yZXMubGVuZ3RoKSByZXNvbHZlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBkZWxldGVDb252ZXJzYXRpb24odXNlcm5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKCF0aGlzLmRiKSBhd2FpdCB0aGlzLmluaXQoKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIhLnRyYW5zYWN0aW9uKFsnY29udmVyc2F0aW9ucycsICdtZXNzYWdlcyddLCAncmVhZHdyaXRlJyk7XHJcblxyXG4gICAgICAvLyBEZWxldGUgY29udmVyc2F0aW9uXHJcbiAgICAgIGNvbnN0IGNvbnZTdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdjb252ZXJzYXRpb25zJyk7XHJcbiAgICAgIGNvbnZTdG9yZS5kZWxldGUodXNlcm5hbWUpO1xyXG5cclxuICAgICAgLy8gRGVsZXRlIGFsbCBtZXNzYWdlcyBpbiBjb252ZXJzYXRpb25cclxuICAgICAgY29uc3QgbXNnU3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnbWVzc2FnZXMnKTtcclxuICAgICAgY29uc3QgcmVxdWVzdCA9IG1zZ1N0b3JlLm9wZW5DdXJzb3IoKTtcclxuXHJcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgY3Vyc29yID0gKGV2ZW50LnRhcmdldCBhcyBJREJSZXF1ZXN0KS5yZXN1bHQ7XHJcbiAgICAgICAgaWYgKGN1cnNvcikge1xyXG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGN1cnNvci52YWx1ZSBhcyBTdG9yZWRNZXNzYWdlO1xyXG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc2VuZGVyX3VzZXJuYW1lID09PSB1c2VybmFtZSB8fCBtZXNzYWdlLnJlY2lwaWVudF91c2VybmFtZSA9PT0gdXNlcm5hbWUpIHtcclxuICAgICAgICAgICAgY3Vyc29yLmRlbGV0ZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PSBNZXNzYWdlIERlbGV0aW9uID09PT09PT09PT09PVxyXG5cclxuICBhc3luYyBkZWxldGVNZXNzYWdlKG1lc3NhZ2VJZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAoIXRoaXMuZGIpIGF3YWl0IHRoaXMuaW5pdCgpO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYiEudHJhbnNhY3Rpb24oWydtZXNzYWdlcyddLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ21lc3NhZ2VzJyk7XHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5kZWxldGUobWVzc2FnZUlkKTtcclxuXHJcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcclxuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIG1hcmtNZXNzYWdlQXNEZWxldGVkKG1lc3NhZ2VJZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAoIXRoaXMuZGIpIGF3YWl0IHRoaXMuaW5pdCgpO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYiEudHJhbnNhY3Rpb24oWydtZXNzYWdlcyddLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ21lc3NhZ2VzJyk7XHJcbiAgICAgIGNvbnN0IGdldFJlcXVlc3QgPSBzdG9yZS5nZXQobWVzc2FnZUlkKTtcclxuXHJcbiAgICAgIGdldFJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZXRSZXF1ZXN0LnJlc3VsdDtcclxuICAgICAgICBpZiAobWVzc2FnZSkge1xyXG4gICAgICAgICAgLy8gTWFyayBhcyBkZWxldGVkIGJ1dCBwcmVzZXJ2ZSBtZXRhZGF0YVxyXG4gICAgICAgICAgbWVzc2FnZS5lbmNyeXB0ZWRfY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHsgZGVsZXRlZDogdHJ1ZSB9KTtcclxuICAgICAgICAgIG1lc3NhZ2UubWVzc2FnZV90eXBlID0gJ2RlbGV0ZWQnO1xyXG4gICAgICAgICAgbWVzc2FnZS5zdGF0dXMgPSAnZGVsZXRlZCc7XHJcblxyXG4gICAgICAgICAgY29uc3QgdXBkYXRlUmVxdWVzdCA9IHN0b3JlLnB1dChtZXNzYWdlKTtcclxuICAgICAgICAgIHVwZGF0ZVJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgdXBkYXRlUmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHVwZGF0ZVJlcXVlc3QuZXJyb3IpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgZ2V0UmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KGdldFJlcXVlc3QuZXJyb3IpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBjbGVhckNvbnZlcnNhdGlvbk1lc3NhZ2VzKHVzZXJuYW1lOiBzdHJpbmcsIGN1cnJlbnRVc2VybmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAoIXRoaXMuZGIpIGF3YWl0IHRoaXMuaW5pdCgpO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYiEudHJhbnNhY3Rpb24oWydtZXNzYWdlcyddLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ21lc3NhZ2VzJyk7XHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5vcGVuQ3Vyc29yKCk7XHJcblxyXG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGN1cnNvciA9IChldmVudC50YXJnZXQgYXMgSURCUmVxdWVzdCkucmVzdWx0O1xyXG4gICAgICAgIGlmIChjdXJzb3IpIHtcclxuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjdXJzb3IudmFsdWUgYXMgU3RvcmVkTWVzc2FnZTtcclxuICAgICAgICAgIC8vIENoZWNrIGlmIG1lc3NhZ2UgaXMgcGFydCBvZiBjb252ZXJzYXRpb25cclxuICAgICAgICAgIGNvbnN0IGlzQ29udmVyc2F0aW9uTWVzc2FnZSA9XHJcbiAgICAgICAgICAgIChtZXNzYWdlLnNlbmRlcl91c2VybmFtZSA9PT0gdXNlcm5hbWUgJiYgbWVzc2FnZS5yZWNpcGllbnRfdXNlcm5hbWUgPT09IGN1cnJlbnRVc2VybmFtZSkgfHxcclxuICAgICAgICAgICAgKG1lc3NhZ2Uuc2VuZGVyX3VzZXJuYW1lID09PSBjdXJyZW50VXNlcm5hbWUgJiYgbWVzc2FnZS5yZWNpcGllbnRfdXNlcm5hbWUgPT09IHVzZXJuYW1lKTtcclxuXHJcbiAgICAgICAgICBpZiAoaXNDb252ZXJzYXRpb25NZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGN1cnNvci5kZWxldGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBsb2NhbFN0b3JhZ2VNYW5hZ2VyID0gbmV3IExvY2FsU3RvcmFnZU1hbmFnZXIoKTtcclxuXHJcbi8vIEF1dG8taW5pdGlhbGl6ZSBvbiBpbXBvcnRcclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbG9jYWxTdG9yYWdlTWFuYWdlci5pbml0KCkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbn0iXSwibmFtZXMiOlsiTG9jYWxTdG9yYWdlTWFuYWdlciIsImluaXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlcXVlc3QiLCJpbmRleGVkREIiLCJvcGVuIiwiZGJOYW1lIiwidmVyc2lvbiIsIm9uZXJyb3IiLCJlcnJvciIsIm9uc3VjY2VzcyIsImRiIiwicmVzdWx0Iiwib251cGdyYWRlbmVlZGVkIiwiZXZlbnQiLCJ0YXJnZXQiLCJvYmplY3RTdG9yZU5hbWVzIiwiY29udGFpbnMiLCJtZXNzYWdlU3RvcmUiLCJjcmVhdGVPYmplY3RTdG9yZSIsImtleVBhdGgiLCJjcmVhdGVJbmRleCIsInVuaXF1ZSIsImNvbnZTdG9yZSIsImNvbnRhY3RTdG9yZSIsInNhdmVNZXNzYWdlIiwibWVzc2FnZSIsInRyYW5zYWN0aW9uIiwic3RvcmUiLCJvYmplY3RTdG9yZSIsInB1dCIsInNhdmVNZXNzYWdlcyIsIm1lc3NhZ2VzIiwiY29tcGxldGVkIiwidG90YWwiLCJsZW5ndGgiLCJmb3JFYWNoIiwiZ2V0Q29udmVyc2F0aW9uTWVzc2FnZXMiLCJ1c2VybmFtZSIsImN1cnJlbnRVc2VybmFtZSIsImxpbWl0Iiwib3BlbkN1cnNvciIsImN1cnNvciIsInZhbHVlIiwiaXNDb252ZXJzYXRpb25NZXNzYWdlIiwic2VuZGVyX3VzZXJuYW1lIiwicmVjaXBpZW50X3VzZXJuYW1lIiwicHVzaCIsImNvbnRpbnVlIiwic29ydCIsImEiLCJiIiwiRGF0ZSIsImNyZWF0ZWRfYXQiLCJnZXRUaW1lIiwic2xpY2UiLCJnZXRBbGxNZXNzYWdlcyIsImdldEFsbCIsInNhdmVDb252ZXJzYXRpb24iLCJjb252ZXJzYXRpb24iLCJzYXZlQ29udmVyc2F0aW9ucyIsImNvbnZlcnNhdGlvbnMiLCJnZXRBbGxDb252ZXJzYXRpb25zIiwic2F2ZUNvbnRhY3QiLCJjb250YWN0Iiwic2F2ZUNvbnRhY3RzIiwiY29udGFjdHMiLCJnZXRBbGxDb250YWN0cyIsInNldFN5bmNUaW1lc3RhbXAiLCJrZXkiLCJ0aW1lc3RhbXAiLCJnZXRTeW5jVGltZXN0YW1wIiwiZ2V0IiwiY2xlYXJBbGxEYXRhIiwic3RvcmVzIiwic3RvcmVOYW1lIiwiY2xlYXIiLCJkZWxldGVDb252ZXJzYXRpb24iLCJkZWxldGUiLCJtc2dTdG9yZSIsImRlbGV0ZU1lc3NhZ2UiLCJtZXNzYWdlSWQiLCJtYXJrTWVzc2FnZUFzRGVsZXRlZCIsImdldFJlcXVlc3QiLCJlbmNyeXB0ZWRfY29udGVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkZWxldGVkIiwibWVzc2FnZV90eXBlIiwic3RhdHVzIiwidXBkYXRlUmVxdWVzdCIsImNsZWFyQ29udmVyc2F0aW9uTWVzc2FnZXMiLCJsb2NhbFN0b3JhZ2VNYW5hZ2VyIiwiY2F0Y2giLCJjb25zb2xlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/storage.ts\n"));

/***/ })

});