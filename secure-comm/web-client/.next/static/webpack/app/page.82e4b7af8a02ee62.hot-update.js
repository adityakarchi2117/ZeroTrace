"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/websocket.ts":
/*!******************************!*\
  !*** ./src/lib/websocket.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wsManager: function() { return /* binding */ wsManager; }\n/* harmony export */ });\n/**\r\n * CipherLink WebSocket Manager\r\n * Handles real-time messaging, presence, and call signaling\r\n */ class WebSocketManager {\n    connect(userId, token) {\n        this.userId = userId;\n        this.token = token;\n        this.connectWebSocket();\n    }\n    connectWebSocket() {\n        var _this_ws;\n        if (this.isConnecting || ((_this_ws = this.ws) === null || _this_ws === void 0 ? void 0 : _this_ws.readyState) === WebSocket.OPEN) {\n            return;\n        }\n        this.isConnecting = true;\n        const wsUrl = \"ws://localhost:8000/ws\" || 0;\n        if (!this.token) {\n            console.warn(\"No auth token available for WebSocket connection\");\n            this.isConnecting = false;\n            return;\n        }\n        try {\n            this.ws = new WebSocket(\"\".concat(wsUrl, \"/chat?token=\").concat(this.token));\n            this.ws.onopen = ()=>{\n                console.log(\"\\uD83D\\uDD17 WebSocket connected\");\n                this.isConnecting = false;\n                this.reconnectAttempts = 0;\n                this.startHeartbeat();\n                // Send any queued messages\n                this.flushMessageQueue();\n            };\n            this.ws.onmessage = (event)=>{\n                try {\n                    const message = JSON.parse(event.data);\n                    this.handleMessage(message);\n                } catch (error) {\n                    console.error(\"Failed to parse WebSocket message:\", error);\n                }\n            };\n            this.ws.onclose = (event)=>{\n                console.log(\"\\uD83D\\uDD0C WebSocket disconnected:\", event.code, event.reason);\n                this.isConnecting = false;\n                this.stopHeartbeat();\n                this.attemptReconnect();\n            };\n            this.ws.onerror = (error)=>{\n                console.error(\"❌ WebSocket error:\", error);\n                this.isConnecting = false;\n            };\n        } catch (error) {\n            console.error(\"Failed to create WebSocket connection:\", error);\n            this.isConnecting = false;\n            this.attemptReconnect();\n        }\n    }\n    attemptReconnect() {\n        if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n            console.error(\"Max reconnection attempts reached\");\n            return;\n        }\n        this.reconnectAttempts++;\n        const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1), 30000);\n        console.log(\"Attempting to reconnect in \".concat(delay, \"ms (attempt \").concat(this.reconnectAttempts, \")\"));\n        setTimeout(()=>{\n            this.connectWebSocket();\n        }, delay);\n    }\n    startHeartbeat() {\n        this.heartbeatInterval = setInterval(()=>{\n            var _this_ws;\n            if (((_this_ws = this.ws) === null || _this_ws === void 0 ? void 0 : _this_ws.readyState) === WebSocket.OPEN) {\n                this.send({\n                    type: \"ping\",\n                    data: {},\n                    timestamp: new Date().toISOString()\n                });\n            }\n        }, 30000);\n    }\n    stopHeartbeat() {\n        if (this.heartbeatInterval) {\n            clearInterval(this.heartbeatInterval);\n            this.heartbeatInterval = null;\n        }\n    }\n    handleMessage(message) {\n        const type = message.type;\n        const handlers = this.messageHandlers.get(type);\n        if (handlers && handlers.size > 0) {\n            handlers.forEach((handler)=>{\n                try {\n                    handler(message);\n                } catch (error) {\n                    console.error(\"Error in handler for \".concat(type, \":\"), error);\n                }\n            });\n        } else if (type !== \"pong\") {\n            console.log(\"Unhandled WebSocket message type:\", type, message);\n        }\n    }\n    flushMessageQueue() {\n        while(this.messageQueue.length > 0){\n            const message = this.messageQueue.shift();\n            if (message) {\n                this.send(message);\n            }\n        }\n    }\n    // Public methods\n    send(message) {\n        var _this_ws;\n        if (((_this_ws = this.ws) === null || _this_ws === void 0 ? void 0 : _this_ws.readyState) === WebSocket.OPEN) {\n            console.log(\"\\uD83D\\uDCE4 Sending \".concat(message.type, \" message:\"), message);\n            this.ws.send(JSON.stringify(message));\n        } else {\n            var _this_ws1;\n            // Queue message for later\n            this.messageQueue.push(message);\n            console.warn(\"⏳ WebSocket not connected (state: \".concat((_this_ws1 = this.ws) === null || _this_ws1 === void 0 ? void 0 : _this_ws1.readyState, \"), queuing \").concat(message.type, \" message\"));\n            // Try to reconnect if not connecting\n            if (!this.isConnecting && this.userId && this.token) {\n                console.log(\"\\uD83D\\uDD04 Triggering reconnection from send failure\");\n                this.connect(this.userId, this.token);\n            }\n        }\n    }\n    on(type, handler) {\n        if (!this.messageHandlers.has(type)) {\n            this.messageHandlers.set(type, new Set());\n        }\n        this.messageHandlers.get(type).add(handler);\n    }\n    off(type, handler) {\n        if (handler) {\n            var _this_messageHandlers_get;\n            (_this_messageHandlers_get = this.messageHandlers.get(type)) === null || _this_messageHandlers_get === void 0 ? void 0 : _this_messageHandlers_get.delete(handler);\n        } else {\n            this.messageHandlers.delete(type);\n        }\n    }\n    onMessage(type, handler) {\n        this.on(type, handler);\n    }\n    offMessage(type) {\n        this.messageHandlers.delete(type);\n    }\n    // Send encrypted message\n    sendEncryptedMessage(recipientUsername, encryptedContent) {\n        let messageType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"text\", fileMetadata = arguments.length > 3 ? arguments[3] : void 0;\n        this.send({\n            type: \"message\",\n            data: {\n                recipient_username: recipientUsername,\n                encrypted_content: encryptedContent,\n                message_type: messageType,\n                file_metadata: fileMetadata\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    sendTypingIndicator(recipientUsername, isTyping) {\n        this.send({\n            type: \"typing\",\n            data: {\n                recipient_username: recipientUsername,\n                is_typing: isTyping\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    sendDeliveryReceipt(messageId, senderId) {\n        this.send({\n            type: \"delivery_receipt\",\n            data: {\n                message_id: messageId,\n                sender_id: senderId\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    sendReadReceipt(messageId, senderId) {\n        this.send({\n            type: \"read_receipt\",\n            data: {\n                message_id: messageId,\n                sender_id: senderId\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    updatePresence(isOnline) {\n        this.send({\n            type: \"presence\",\n            data: {\n                is_online: isOnline\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    subscribeToPresence(userIds) {\n        this.send({\n            type: \"presence_subscribe\",\n            data: {\n                user_ids: userIds\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    getOnlineStatus(userIds) {\n        this.send({\n            type: \"get_online_status\",\n            data: {\n                user_ids: userIds\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    disconnect() {\n        this.stopHeartbeat();\n        this.updatePresence(false);\n        if (this.ws) {\n            this.ws.close();\n            this.ws = null;\n        }\n        this.messageQueue = [];\n    }\n    isConnected() {\n        var _this_ws;\n        return ((_this_ws = this.ws) === null || _this_ws === void 0 ? void 0 : _this_ws.readyState) === WebSocket.OPEN;\n    }\n    getConnectionState() {\n        var _this_ws;\n        var _this_ws_readyState;\n        return (_this_ws_readyState = (_this_ws = this.ws) === null || _this_ws === void 0 ? void 0 : _this_ws.readyState) !== null && _this_ws_readyState !== void 0 ? _this_ws_readyState : null;\n    }\n    constructor(){\n        this.ws = null;\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 10;\n        this.reconnectDelay = 1000;\n        this.heartbeatInterval = null;\n        this.messageHandlers = new Map();\n        this.userId = null;\n        this.token = null;\n        this.isConnecting = false;\n        this.messageQueue = [];\n    // Don't auto-connect in constructor\n    }\n}\n// Export singleton instance\nconst wsManager = new WebSocketManager();\n// Auto-disconnect on page unload\nif (true) {\n    window.addEventListener(\"beforeunload\", ()=>{\n        wsManager.updatePresence(false);\n        wsManager.disconnect();\n    });\n    // Update presence on visibility change\n    document.addEventListener(\"visibilitychange\", ()=>{\n        if (document.hidden) {\n            wsManager.updatePresence(false);\n        } else {\n            wsManager.updatePresence(true);\n        }\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvd2Vic29ja2V0LnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0NBR0MsR0F5QkQsTUFBTUE7SUFnQkpDLFFBQVFDLE1BQWMsRUFBRUMsS0FBYSxFQUFFO1FBQ3JDLElBQUksQ0FBQ0QsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsZ0JBQWdCO0lBQ3ZCO0lBRVFBLG1CQUFtQjtZQUNBO1FBQXpCLElBQUksSUFBSSxDQUFDQyxZQUFZLElBQUksaUJBQUksQ0FBQ0MsRUFBRSxjQUFQLHdDQUFTQyxVQUFVLE1BQUtDLFVBQVVDLElBQUksRUFBRTtZQUMvRDtRQUNGO1FBRUEsSUFBSSxDQUFDSixZQUFZLEdBQUc7UUFDcEIsTUFBTUssUUFBUUMsd0JBQThCLElBQUk7UUFFaEQsSUFBSSxDQUFDLElBQUksQ0FBQ1IsS0FBSyxFQUFFO1lBQ2ZXLFFBQVFDLElBQUksQ0FBQztZQUNiLElBQUksQ0FBQ1YsWUFBWSxHQUFHO1lBQ3BCO1FBQ0Y7UUFFQSxJQUFJO1lBQ0YsSUFBSSxDQUFDQyxFQUFFLEdBQUcsSUFBSUUsVUFBVSxHQUF1QixPQUFwQkUsT0FBTSxnQkFBeUIsT0FBWCxJQUFJLENBQUNQLEtBQUs7WUFFekQsSUFBSSxDQUFDRyxFQUFFLENBQUNVLE1BQU0sR0FBRztnQkFDZkYsUUFBUUcsR0FBRyxDQUFDO2dCQUNaLElBQUksQ0FBQ1osWUFBWSxHQUFHO2dCQUNwQixJQUFJLENBQUNhLGlCQUFpQixHQUFHO2dCQUN6QixJQUFJLENBQUNDLGNBQWM7Z0JBRW5CLDJCQUEyQjtnQkFDM0IsSUFBSSxDQUFDQyxpQkFBaUI7WUFDeEI7WUFFQSxJQUFJLENBQUNkLEVBQUUsQ0FBQ2UsU0FBUyxHQUFHLENBQUNDO2dCQUNuQixJQUFJO29CQUNGLE1BQU1DLFVBQVVDLEtBQUtDLEtBQUssQ0FBQ0gsTUFBTUksSUFBSTtvQkFDckMsSUFBSSxDQUFDQyxhQUFhLENBQUNK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O2FBQzdEbEcsU0FBd0I7YUFDeEJDLFFBQXVCO2FBQ3ZCRSxlQUFlO2FBQ2ZtRCxlQUFtQyxFQUFFO0lBRzNDLG9DQUFvQztJQUN0QztBQXFRRjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNNkMsWUFBWSxJQUFJckcsbUJBQW1CO0FBRWhELGlDQUFpQztBQUNqQyxJQUFJLElBQWtCLEVBQWE7SUFDakNzRyxPQUFPQyxnQkFBZ0IsQ0FBQyxnQkFBZ0I7UUFDdENGLFVBQVViLGNBQWMsQ0FBQztRQUN6QmEsVUFBVU4sVUFBVTtJQUN0QjtJQUVBLHVDQUF1QztJQUN2Q1MsU0FBU0QsZ0JBQWdCLENBQUMsb0JBQW9CO1FBQzVDLElBQUlDLFNBQVNDLE1BQU0sRUFBRTtZQUNuQkosVUFBVWIsY0FBYyxDQUFDO1FBQzNCLE9BQU87WUFDTGEsVUFBVWIsY0FBYyxDQUFDO1FBQzNCO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3dlYnNvY2tldC50cz9jNjk2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDaXBoZXJMaW5rIFdlYlNvY2tldCBNYW5hZ2VyXHJcbiAqIEhhbmRsZXMgcmVhbC10aW1lIG1lc3NhZ2luZywgcHJlc2VuY2UsIGFuZCBjYWxsIHNpZ25hbGluZ1xyXG4gKi9cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2ViU29ja2V0TWVzc2FnZSB7XHJcbiAgdHlwZTogJ21lc3NhZ2UnIHwgJ3ByZXNlbmNlJyB8ICd0eXBpbmcnIHwgJ2RlbGl2ZXJ5X3JlY2VpcHQnIHwgJ3JlYWRfcmVjZWlwdCcgfFxyXG4gICdwaW5nJyB8ICdwb25nJyB8ICdjb25uZWN0ZWQnIHwgJ21lc3NhZ2Vfc2VudCcgfCAnZXJyb3InIHxcclxuICAnY2FsbF9vZmZlcicgfCAnY2FsbF9hbnN3ZXInIHwgJ2NhbGxfcmVqZWN0JyB8ICdjYWxsX3JlamVjdGVkJyB8XHJcbiAgJ2NhbGxfZW5kJyB8ICdjYWxsX2VuZGVkJyB8ICdjYWxsX2ZhaWxlZCcgfCAnaWNlX2NhbmRpZGF0ZScgfFxyXG4gICdwcmVzZW5jZV9zdWJzY3JpYmUnIHwgJ2dldF9vbmxpbmVfc3RhdHVzJyB8ICdvbmxpbmVfc3RhdHVzJyB8XHJcbiAgJ2RlbGV0ZV9tZXNzYWdlJyB8ICdkZWxldGVfbWVzc2FnZV9yZWNlaXZlZCcgfCAnZGVsZXRlX2NvbnZlcnNhdGlvbicgfCAnZGVsZXRlX2NvbnZlcnNhdGlvbl9yZWNlaXZlZCc7XHJcbiAgZGF0YT86IGFueTtcclxuICB0aW1lc3RhbXA6IHN0cmluZztcclxuICBba2V5OiBzdHJpbmddOiBhbnk7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJlc2VuY2VVcGRhdGUge1xyXG4gIHVzZXJuYW1lOiBzdHJpbmc7XHJcbiAgaXNfb25saW5lOiBib29sZWFuO1xyXG4gIGxhc3Rfc2Vlbj86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUeXBpbmdJbmRpY2F0b3Ige1xyXG4gIHVzZXJuYW1lOiBzdHJpbmc7XHJcbiAgaXNfdHlwaW5nOiBib29sZWFuO1xyXG59XHJcblxyXG5jbGFzcyBXZWJTb2NrZXRNYW5hZ2VyIHtcclxuICBwcml2YXRlIHdzOiBXZWJTb2NrZXQgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIHJlY29ubmVjdEF0dGVtcHRzID0gMDtcclxuICBwcml2YXRlIG1heFJlY29ubmVjdEF0dGVtcHRzID0gMTA7XHJcbiAgcHJpdmF0ZSByZWNvbm5lY3REZWxheSA9IDEwMDA7XHJcbiAgcHJpdmF0ZSBoZWFydGJlYXRJbnRlcnZhbDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIG1lc3NhZ2VIYW5kbGVyczogTWFwPHN0cmluZywgU2V0PChkYXRhOiBhbnkpID0+IHZvaWQ+PiA9IG5ldyBNYXAoKTtcclxuICBwcml2YXRlIHVzZXJJZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSB0b2tlbjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSBpc0Nvbm5lY3RpbmcgPSBmYWxzZTtcclxuICBwcml2YXRlIG1lc3NhZ2VRdWV1ZTogV2ViU29ja2V0TWVzc2FnZVtdID0gW107XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgLy8gRG9uJ3QgYXV0by1jb25uZWN0IGluIGNvbnN0cnVjdG9yXHJcbiAgfVxyXG5cclxuICBjb25uZWN0KHVzZXJJZDogc3RyaW5nLCB0b2tlbjogc3RyaW5nKSB7XHJcbiAgICB0aGlzLnVzZXJJZCA9IHVzZXJJZDtcclxuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcclxuICAgIHRoaXMuY29ubmVjdFdlYlNvY2tldCgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjb25uZWN0V2ViU29ja2V0KCkge1xyXG4gICAgaWYgKHRoaXMuaXNDb25uZWN0aW5nIHx8IHRoaXMud3M/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmlzQ29ubmVjdGluZyA9IHRydWU7XHJcbiAgICBjb25zdCB3c1VybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1dTX1VSTCB8fCAnd3M6Ly9sb2NhbGhvc3Q6ODAwMC93cyc7XHJcblxyXG4gICAgaWYgKCF0aGlzLnRva2VuKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignTm8gYXV0aCB0b2tlbiBhdmFpbGFibGUgZm9yIFdlYlNvY2tldCBjb25uZWN0aW9uJyk7XHJcbiAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldChgJHt3c1VybH0vY2hhdD90b2tlbj0ke3RoaXMudG9rZW59YCk7XHJcblxyXG4gICAgICB0aGlzLndzLm9ub3BlbiA9ICgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+UlyBXZWJTb2NrZXQgY29ubmVjdGVkJyk7XHJcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcclxuICAgICAgICB0aGlzLnN0YXJ0SGVhcnRiZWF0KCk7XHJcblxyXG4gICAgICAgIC8vIFNlbmQgYW55IHF1ZXVlZCBtZXNzYWdlc1xyXG4gICAgICAgIHRoaXMuZmx1c2hNZXNzYWdlUXVldWUoKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xyXG4gICAgICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgV2ViU29ja2V0IG1lc3NhZ2U6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMud3Mub25jbG9zZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SMIFdlYlNvY2tldCBkaXNjb25uZWN0ZWQ6JywgZXZlbnQuY29kZSwgZXZlbnQucmVhc29uKTtcclxuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RvcEhlYXJ0YmVhdCgpO1xyXG4gICAgICAgIHRoaXMuYXR0ZW1wdFJlY29ubmVjdCgpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy53cy5vbmVycm9yID0gKGVycm9yKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFdlYlNvY2tldCBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcclxuICAgICAgfTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIFdlYlNvY2tldCBjb25uZWN0aW9uOicsIGVycm9yKTtcclxuICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcclxuICAgICAgdGhpcy5hdHRlbXB0UmVjb25uZWN0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGF0dGVtcHRSZWNvbm5lY3QoKSB7XHJcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA+PSB0aGlzLm1heFJlY29ubmVjdEF0dGVtcHRzKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgcmVhY2hlZCcpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cysrO1xyXG4gICAgY29uc3QgZGVsYXkgPSBNYXRoLm1pbih0aGlzLnJlY29ubmVjdERlbGF5ICogTWF0aC5wb3coMiwgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyAtIDEpLCAzMDAwMCk7XHJcblxyXG4gICAgY29uc29sZS5sb2coYEF0dGVtcHRpbmcgdG8gcmVjb25uZWN0IGluICR7ZGVsYXl9bXMgKGF0dGVtcHQgJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSlgKTtcclxuXHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGhpcy5jb25uZWN0V2ViU29ja2V0KCk7XHJcbiAgICB9LCBkZWxheSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN0YXJ0SGVhcnRiZWF0KCkge1xyXG4gICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgaWYgKHRoaXMud3M/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgICAgdGhpcy5zZW5kKHtcclxuICAgICAgICAgIHR5cGU6ICdwaW5nJyxcclxuICAgICAgICAgIGRhdGE6IHt9LFxyXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSwgMzAwMDApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdG9wSGVhcnRiZWF0KCkge1xyXG4gICAgaWYgKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdEludGVydmFsKTtcclxuICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGhhbmRsZU1lc3NhZ2UobWVzc2FnZTogYW55KSB7XHJcbiAgICBjb25zdCB0eXBlID0gbWVzc2FnZS50eXBlO1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSB0aGlzLm1lc3NhZ2VIYW5kbGVycy5nZXQodHlwZSk7XHJcblxyXG4gICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzLnNpemUgPiAwKSB7XHJcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGhhbmRsZXIobWVzc2FnZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgZm9yICR7dHlwZX06YCwgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdwb25nJykge1xyXG4gICAgICBjb25zb2xlLmxvZygnVW5oYW5kbGVkIFdlYlNvY2tldCBtZXNzYWdlIHR5cGU6JywgdHlwZSwgbWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGZsdXNoTWVzc2FnZVF1ZXVlKCkge1xyXG4gICAgd2hpbGUgKHRoaXMubWVzc2FnZVF1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMubWVzc2FnZVF1ZXVlLnNoaWZ0KCk7XHJcbiAgICAgIGlmIChtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5zZW5kKG1lc3NhZ2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWMgbWV0aG9kc1xyXG4gIHNlbmQobWVzc2FnZTogV2ViU29ja2V0TWVzc2FnZSkge1xyXG4gICAgaWYgKHRoaXMud3M/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OkIFNlbmRpbmcgJHttZXNzYWdlLnR5cGV9IG1lc3NhZ2U6YCwgbWVzc2FnZSk7XHJcbiAgICAgIHRoaXMud3Muc2VuZChKU09OLnN0cmluZ2lmeShtZXNzYWdlKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBRdWV1ZSBtZXNzYWdlIGZvciBsYXRlclxyXG4gICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5wdXNoKG1lc3NhZ2UpO1xyXG4gICAgICBjb25zb2xlLndhcm4oYOKPsyBXZWJTb2NrZXQgbm90IGNvbm5lY3RlZCAoc3RhdGU6ICR7dGhpcy53cz8ucmVhZHlTdGF0ZX0pLCBxdWV1aW5nICR7bWVzc2FnZS50eXBlfSBtZXNzYWdlYCk7XHJcblxyXG4gICAgICAvLyBUcnkgdG8gcmVjb25uZWN0IGlmIG5vdCBjb25uZWN0aW5nXHJcbiAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RpbmcgJiYgdGhpcy51c2VySWQgJiYgdGhpcy50b2tlbikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFRyaWdnZXJpbmcgcmVjb25uZWN0aW9uIGZyb20gc2VuZCBmYWlsdXJlJyk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMudXNlcklkLCB0aGlzLnRva2VuKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiAoZGF0YTogYW55KSA9PiB2b2lkKSB7XHJcbiAgICBpZiAoIXRoaXMubWVzc2FnZUhhbmRsZXJzLmhhcyh0eXBlKSkge1xyXG4gICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVycy5zZXQodHlwZSwgbmV3IFNldCgpKTtcclxuICAgIH1cclxuICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzLmdldCh0eXBlKSEuYWRkKGhhbmRsZXIpO1xyXG4gIH1cclxuXHJcbiAgb2ZmKHR5cGU6IHN0cmluZywgaGFuZGxlcj86IChkYXRhOiBhbnkpID0+IHZvaWQpIHtcclxuICAgIGlmIChoYW5kbGVyKSB7XHJcbiAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzLmdldCh0eXBlKT8uZGVsZXRlKGhhbmRsZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcnMuZGVsZXRlKHR5cGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25NZXNzYWdlKHR5cGU6IHN0cmluZywgaGFuZGxlcjogKGRhdGE6IGFueSkgPT4gdm9pZCkge1xyXG4gICAgdGhpcy5vbih0eXBlLCBoYW5kbGVyKTtcclxuICB9XHJcblxyXG4gIG9mZk1lc3NhZ2UodHlwZTogc3RyaW5nKSB7XHJcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVycy5kZWxldGUodHlwZSk7XHJcbiAgfVxyXG5cclxuICAvLyBTZW5kIGVuY3J5cHRlZCBtZXNzYWdlXHJcbiAgc2VuZEVuY3J5cHRlZE1lc3NhZ2UocmVjaXBpZW50VXNlcm5hbWU6IHN0cmluZywgZW5jcnlwdGVkQ29udGVudDogc3RyaW5nLCBtZXNzYWdlVHlwZTogc3RyaW5nID0gJ3RleHQnLCBmaWxlTWV0YWRhdGE/OiBhbnkpIHtcclxuICAgIHRoaXMuc2VuZCh7XHJcbiAgICAgIHR5cGU6ICdtZXNzYWdlJyxcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIHJlY2lwaWVudF91c2VybmFtZTogcmVjaXBpZW50VXNlcm5hbWUsXHJcbiAgICAgICAgZW5jcnlwdGVkX2NvbnRlbnQ6IGVuY3J5cHRlZENvbnRlbnQsXHJcbiAgICAgICAgbWVzc2FnZV90eXBlOiBtZXNzYWdlVHlwZSxcclxuICAgICAgICBmaWxlX21ldGFkYXRhOiBmaWxlTWV0YWRhdGEsXHJcbiAgICAgIH0sXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHNlbmRUeXBpbmdJbmRpY2F0b3IocmVjaXBpZW50VXNlcm5hbWU6IHN0cmluZywgaXNUeXBpbmc6IGJvb2xlYW4pIHtcclxuICAgIHRoaXMuc2VuZCh7XHJcbiAgICAgIHR5cGU6ICd0eXBpbmcnLFxyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgcmVjaXBpZW50X3VzZXJuYW1lOiByZWNpcGllbnRVc2VybmFtZSxcclxuICAgICAgICBpc190eXBpbmc6IGlzVHlwaW5nXHJcbiAgICAgIH0sXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHNlbmREZWxpdmVyeVJlY2VpcHQobWVzc2FnZUlkOiBudW1iZXIsIHNlbmRlcklkOiBudW1iZXIpIHtcclxuICAgIHRoaXMuc2VuZCh7XHJcbiAgICAgIHR5cGU6ICdkZWxpdmVyeV9yZWNlaXB0JyxcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIG1lc3NhZ2VfaWQ6IG1lc3NhZ2VJZCxcclxuICAgICAgICBzZW5kZXJfaWQ6IHNlbmRlcklkXHJcbiAgICAgIH0sXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHNlbmRSZWFkUmVjZWlwdChtZXNzYWdlSWQ6IG51bWJlciwgc2VuZGVySWQ6IG51bWJlcikge1xyXG4gICAgdGhpcy5zZW5kKHtcclxuICAgICAgdHlwZTogJ3JlYWRfcmVjZWlwdCcsXHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICBtZXNzYWdlX2lkOiBtZXNzYWdlSWQsXHJcbiAgICAgICAgc2VuZGVyX2lkOiBzZW5kZXJJZFxyXG4gICAgICB9LFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVQcmVzZW5jZShpc09ubGluZTogYm9vbGVhbikge1xyXG4gICAgdGhpcy5zZW5kKHtcclxuICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIGlzX29ubGluZTogaXNPbmxpbmVcclxuICAgICAgfSxcclxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc3Vic2NyaWJlVG9QcmVzZW5jZSh1c2VySWRzOiBudW1iZXJbXSkge1xyXG4gICAgdGhpcy5zZW5kKHtcclxuICAgICAgdHlwZTogJ3ByZXNlbmNlX3N1YnNjcmliZScsXHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICB1c2VyX2lkczogdXNlcklkc1xyXG4gICAgICB9LFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBnZXRPbmxpbmVTdGF0dXModXNlcklkczogbnVtYmVyW10pIHtcclxuICAgIHRoaXMuc2VuZCh7XHJcbiAgICAgIHR5cGU6ICdnZXRfb25saW5lX3N0YXR1cycsXHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICB1c2VyX2lkczogdXNlcklkc1xyXG4gICAgICB9LFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBkaXNjb25uZWN0KCkge1xyXG4gICAgdGhpcy5zdG9wSGVhcnRiZWF0KCk7XHJcbiAgICB0aGlzLnVwZGF0ZVByZXNlbmNlKGZhbHNlKTtcclxuXHJcbiAgICBpZiAodGhpcy53cykge1xyXG4gICAgICB0aGlzLndzLmNsb3NlKCk7XHJcbiAgICAgIHRoaXMud3MgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubWVzc2FnZVF1ZXVlID0gW107XHJcbiAgfVxyXG5cclxuICBpc0Nvbm5lY3RlZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLndzPy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTjtcclxuICB9XHJcblxyXG4gIGdldENvbm5lY3Rpb25TdGF0ZSgpOiBudW1iZXIgfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLndzPy5yZWFkeVN0YXRlID8/IG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCB3c01hbmFnZXIgPSBuZXcgV2ViU29ja2V0TWFuYWdlcigpO1xyXG5cclxuLy8gQXV0by1kaXNjb25uZWN0IG9uIHBhZ2UgdW5sb2FkXHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCAoKSA9PiB7XHJcbiAgICB3c01hbmFnZXIudXBkYXRlUHJlc2VuY2UoZmFsc2UpO1xyXG4gICAgd3NNYW5hZ2VyLmRpc2Nvbm5lY3QoKTtcclxuICB9KTtcclxuXHJcbiAgLy8gVXBkYXRlIHByZXNlbmNlIG9uIHZpc2liaWxpdHkgY2hhbmdlXHJcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcclxuICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcclxuICAgICAgd3NNYW5hZ2VyLnVwZGF0ZVByZXNlbmNlKGZhbHNlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdzTWFuYWdlci51cGRhdGVQcmVzZW5jZSh0cnVlKTtcclxuICAgIH1cclxuICB9KTtcclxufSJdLCJuYW1lcyI6WyJXZWJTb2NrZXRNYW5hZ2VyIiwiY29ubmVjdCIsInVzZXJJZCIsInRva2VuIiwiY29ubmVjdFdlYlNvY2tldCIsImlzQ29ubmVjdGluZyIsIndzIiwicmVhZHlTdGF0ZSIsIldlYlNvY2tldCIsIk9QRU4iLCJ3c1VybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19XU19VUkwiLCJjb25zb2xlIiwid2FybiIsIm9ub3BlbiIsImxvZyIsInJlY29ubmVjdEF0dGVtcHRzIiwic3RhcnRIZWFydGJlYXQiLCJmbHVzaE1lc3NhZ2VRdWV1ZSIsIm9ubWVzc2FnZSIsImV2ZW50IiwibWVzc2FnZSIsIkpTT04iLCJwYXJzZSIsImRhdGEiLCJoYW5kbGVNZXNzYWdlIiwiZXJyb3IiLCJvbmNsb3NlIiwiY29kZSIsInJlYXNvbiIsInN0b3BIZWFydGJlYXQiLCJhdHRlbXB0UmVjb25uZWN0Iiwib25lcnJvciIsIm1heFJlY29ubmVjdEF0dGVtcHRzIiwiZGVsYXkiLCJNYXRoIiwibWluIiwicmVjb25uZWN0RGVsYXkiLCJwb3ciLCJzZXRUaW1lb3V0IiwiaGVhcnRiZWF0SW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInNlbmQiLCJ0eXBlIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY2xlYXJJbnRlcnZhbCIsImhhbmRsZXJzIiwibWVzc2FnZUhhbmRsZXJzIiwiZ2V0Iiwic2l6ZSIsImZvckVhY2giLCJoYW5kbGVyIiwibWVzc2FnZVF1ZXVlIiwibGVuZ3RoIiwic2hpZnQiLCJzdHJpbmdpZnkiLCJwdXNoIiwib24iLCJoYXMiLCJzZXQiLCJTZXQiLCJhZGQiLCJvZmYiLCJkZWxldGUiLCJvbk1lc3NhZ2UiLCJvZmZNZXNzYWdlIiwic2VuZEVuY3J5cHRlZE1lc3NhZ2UiLCJyZWNpcGllbnRVc2VybmFtZSIsImVuY3J5cHRlZENvbnRlbnQiLCJtZXNzYWdlVHlwZSIsImZpbGVNZXRhZGF0YSIsInJlY2lwaWVudF91c2VybmFtZSIsImVuY3J5cHRlZF9jb250ZW50IiwibWVzc2FnZV90eXBlIiwiZmlsZV9tZXRhZGF0YSIsInNlbmRUeXBpbmdJbmRpY2F0b3IiLCJpc1R5cGluZyIsImlzX3R5cGluZyIsInNlbmREZWxpdmVyeVJlY2VpcHQiLCJtZXNzYWdlSWQiLCJzZW5kZXJJZCIsIm1lc3NhZ2VfaWQiLCJzZW5kZXJfaWQiLCJzZW5kUmVhZFJlY2VpcHQiLCJ1cGRhdGVQcmVzZW5jZSIsImlzT25saW5lIiwiaXNfb25saW5lIiwic3Vic2NyaWJlVG9QcmVzZW5jZSIsInVzZXJJZHMiLCJ1c2VyX2lkcyIsImdldE9ubGluZVN0YXR1cyIsImRpc2Nvbm5lY3QiLCJjbG9zZSIsImlzQ29ubmVjdGVkIiwiZ2V0Q29ubmVjdGlvblN0YXRlIiwiY29uc3RydWN0b3IiLCJNYXAiLCJ3c01hbmFnZXIiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiZG9jdW1lbnQiLCJoaWRkZW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/websocket.ts\n"));

/***/ })

});