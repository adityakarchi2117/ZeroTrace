"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/websocket.ts":
/*!******************************!*\
  !*** ./src/lib/websocket.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wsManager: function() { return /* binding */ wsManager; }\n/* harmony export */ });\n/**\r\n * CipherLink WebSocket Manager\r\n * Handles real-time messaging, presence, and call signaling\r\n */ class WebSocketManager {\n    connect(userId, token) {\n        this.userId = userId;\n        this.token = token;\n        this.connectWebSocket();\n    }\n    connectWebSocket() {\n        var _this_ws;\n        if (this.isConnecting || ((_this_ws = this.ws) === null || _this_ws === void 0 ? void 0 : _this_ws.readyState) === WebSocket.OPEN) {\n            return;\n        }\n        this.isConnecting = true;\n        const wsUrl = \"ws://localhost:8000/ws\" || 0;\n        if (!this.token) {\n            console.warn(\"No auth token available for WebSocket connection\");\n            this.isConnecting = false;\n            return;\n        }\n        try {\n            this.ws = new WebSocket(\"\".concat(wsUrl, \"/chat?token=\").concat(this.token));\n            this.ws.onopen = ()=>{\n                console.log(\"\\uD83D\\uDD17 WebSocket connected\");\n                this.isConnecting = false;\n                this.reconnectAttempts = 0;\n                this.startHeartbeat();\n                // Send any queued messages\n                this.flushMessageQueue();\n            };\n            this.ws.onmessage = (event)=>{\n                try {\n                    const message = JSON.parse(event.data);\n                    this.handleMessage(message);\n                } catch (error) {\n                    console.error(\"Failed to parse WebSocket message:\", error);\n                }\n            };\n            this.ws.onclose = (event)=>{\n                console.log(\"\\uD83D\\uDD0C WebSocket disconnected:\", event.code, event.reason);\n                this.isConnecting = false;\n                this.stopHeartbeat();\n                this.attemptReconnect();\n            };\n            this.ws.onerror = (error)=>{\n                console.error(\"❌ WebSocket error:\", error);\n                this.isConnecting = false;\n            };\n        } catch (error) {\n            console.error(\"Failed to create WebSocket connection:\", error);\n            this.isConnecting = false;\n            this.attemptReconnect();\n        }\n    }\n    attemptReconnect() {\n        if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n            console.error(\"Max reconnection attempts reached\");\n            return;\n        }\n        this.reconnectAttempts++;\n        const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1), 30000);\n        console.log(\"Attempting to reconnect in \".concat(delay, \"ms (attempt \").concat(this.reconnectAttempts, \")\"));\n        setTimeout(()=>{\n            this.connectWebSocket();\n        }, delay);\n    }\n    startHeartbeat() {\n        this.heartbeatInterval = setInterval(()=>{\n            var _this_ws;\n            if (((_this_ws = this.ws) === null || _this_ws === void 0 ? void 0 : _this_ws.readyState) === WebSocket.OPEN) {\n                this.send({\n                    type: \"ping\",\n                    data: {},\n                    timestamp: new Date().toISOString()\n                });\n            }\n        }, 30000);\n    }\n    stopHeartbeat() {\n        if (this.heartbeatInterval) {\n            clearInterval(this.heartbeatInterval);\n            this.heartbeatInterval = null;\n        }\n    }\n    handleMessage(message) {\n        const type = message.type;\n        const handlers = this.messageHandlers.get(type);\n        if (handlers && handlers.size > 0) {\n            handlers.forEach((handler)=>{\n                try {\n                    handler(message);\n                } catch (error) {\n                    console.error(\"Error in handler for \".concat(type, \":\"), error);\n                }\n            });\n        } else if (type !== \"pong\") {\n            console.log(\"Unhandled WebSocket message type:\", type, message);\n        }\n    }\n    flushMessageQueue() {\n        while(this.messageQueue.length > 0){\n            const message = this.messageQueue.shift();\n            if (message) {\n                this.send(message);\n            }\n        }\n    }\n    // Public methods\n    send(message) {\n        var _this_ws;\n        if (((_this_ws = this.ws) === null || _this_ws === void 0 ? void 0 : _this_ws.readyState) === WebSocket.OPEN) {\n            console.log(\"\\uD83D\\uDCE4 Sending \".concat(message.type, \" message:\"), message);\n            this.ws.send(JSON.stringify(message));\n        } else {\n            var _this_ws1;\n            // Queue message for later\n            this.messageQueue.push(message);\n            console.warn(\"⏳ WebSocket not connected (state: \".concat((_this_ws1 = this.ws) === null || _this_ws1 === void 0 ? void 0 : _this_ws1.readyState, \"), queuing \").concat(message.type, \" message\"));\n            // Try to reconnect if not connecting\n            if (!this.isConnecting && this.userId && this.token) {\n                console.log(\"\\uD83D\\uDD04 Triggering reconnection from send failure\");\n                this.connect(this.userId, this.token);\n            }\n        }\n    }\n    on(type, handler) {\n        if (!this.messageHandlers.has(type)) {\n            this.messageHandlers.set(type, new Set());\n        }\n        this.messageHandlers.get(type).add(handler);\n    }\n    off(type, handler) {\n        if (handler) {\n            var _this_messageHandlers_get;\n            (_this_messageHandlers_get = this.messageHandlers.get(type)) === null || _this_messageHandlers_get === void 0 ? void 0 : _this_messageHandlers_get.delete(handler);\n        } else {\n            this.messageHandlers.delete(type);\n        }\n    }\n    onMessage(type, handler) {\n        this.on(type, handler);\n    }\n    offMessage(type) {\n        this.messageHandlers.delete(type);\n    }\n    // Send encrypted message\n    sendEncryptedMessage(recipientUsername, encryptedContent) {\n        let messageType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"text\", fileMetadata = arguments.length > 3 ? arguments[3] : void 0;\n        this.send({\n            type: \"message\",\n            data: {\n                recipient_username: recipientUsername,\n                encrypted_content: encryptedContent,\n                message_type: messageType,\n                file_metadata: fileMetadata\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    sendTypingIndicator(recipientUsername, isTyping) {\n        this.send({\n            type: \"typing\",\n            data: {\n                recipient_username: recipientUsername,\n                is_typing: isTyping\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    sendDeliveryReceipt(messageId, senderId) {\n        this.send({\n            type: \"delivery_receipt\",\n            data: {\n                message_id: messageId,\n                sender_id: senderId\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    sendReadReceipt(messageId, senderId) {\n        this.send({\n            type: \"read_receipt\",\n            data: {\n                message_id: messageId,\n                sender_id: senderId\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    updatePresence(isOnline) {\n        this.send({\n            type: \"presence\",\n            data: {\n                is_online: isOnline\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    subscribeToPresence(userIds) {\n        this.send({\n            type: \"presence_subscribe\",\n            data: {\n                user_ids: userIds\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    getOnlineStatus(userIds) {\n        this.send({\n            type: \"get_online_status\",\n            data: {\n                user_ids: userIds\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    // Send delete message event (delete for everyone)\n    sendDeleteMessage(messageId, recipientUsername) {\n        this.send({\n            type: \"delete_message\",\n            data: {\n                message_id: messageId,\n                recipient_username: recipientUsername\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    // Send delete conversation event (delete for everyone)\n    sendDeleteConversation(recipientUsername) {\n        this.send({\n            type: \"delete_conversation\",\n            data: {\n                recipient_username: recipientUsername\n            },\n            timestamp: new Date().toISOString()\n        });\n    }\n    disconnect() {\n        this.stopHeartbeat();\n        this.updatePresence(false);\n        if (this.ws) {\n            this.ws.close();\n            this.ws = null;\n        }\n        this.messageQueue = [];\n    }\n    isConnected() {\n        var _this_ws;\n        return ((_this_ws = this.ws) === null || _this_ws === void 0 ? void 0 : _this_ws.readyState) === WebSocket.OPEN;\n    }\n    getConnectionState() {\n        var _this_ws;\n        var _this_ws_readyState;\n        return (_this_ws_readyState = (_this_ws = this.ws) === null || _this_ws === void 0 ? void 0 : _this_ws.readyState) !== null && _this_ws_readyState !== void 0 ? _this_ws_readyState : null;\n    }\n    constructor(){\n        this.ws = null;\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 10;\n        this.reconnectDelay = 1000;\n        this.heartbeatInterval = null;\n        this.messageHandlers = new Map();\n        this.userId = null;\n        this.token = null;\n        this.isConnecting = false;\n        this.messageQueue = [];\n    // Don't auto-connect in constructor\n    }\n}\n// Export singleton instance\nconst wsManager = new WebSocketManager();\n// Auto-disconnect on page unload\nif (true) {\n    window.addEventListener(\"beforeunload\", ()=>{\n        wsManager.updatePresence(false);\n        wsManager.disconnect();\n    });\n    // Update presence on visibility change\n    document.addEventListener(\"visibilitychange\", ()=>{\n        if (document.hidden) {\n            wsManager.updatePresence(false);\n        } else {\n            wsManager.updatePresence(true);\n        }\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvd2Vic29ja2V0LnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0NBR0MsR0F5QkQsTUFBTUE7SUFnQkpDLFFBQVFDLE1BQWMsRUFBRUMsS0FBYSxFQUFFO1FBQ3JDLElBQUksQ0FBQ0QsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsZ0JBQWdCO0lBQ3ZCO0lBRVFBLG1CQUFtQjtZQUNBO1FBQXpCLElBQUksSUFBSSxDQUFDQyxZQUFZLElBQUksaUJBQUksQ0FBQ0MsRUFBRSxjQUFQLHdDQUFTQyxVQUFVLE1BQUtDLFVBQVVDLElBQUksRUFBRTtZQUMvRDtRQUNGO1FBRUEsSUFBSSxDQUFDSixZQUFZLEdBQUc7UUFDcEIsTUFBTUssUUFBUUMsd0JBQThCLElBQUk7UUFFaEQsSUFBSSxDQUFDLElBQUksQ0FBQ1IsS0FBSyxFQUFFO1lBQ2ZXLFFBQVFDLElBQUksQ0FBQztZQUNiLElBQUksQ0FBQ1YsWUFBWSxHQUFHO1lBQ3BCO1FBQ0Y7UUFFQSxJQUFJO1lBQ0YsSUFBSSxDQUFDQyxFQUFFLEdBQUcsSUFBSUUsVUFBVSxHQUF1QixPQUFwQkUsT0FBTSxnQkFBeUIsT0FBWCxJQUFJLENBQUNQLEtBQUs7WUFFekQsSUFBSSxDQUFDRyxFQUFFLENBQUNVLE1BQU0sR0FBRztnQkFDZkYsUUFBUUcsR0FBRyxDQUFDO2dCQUNaLElBQUksQ0FBQ1osWUFBWSxHQUFHO2dCQUNwQixJQUFJLENBQUNhLGlCQUFpQixHQUFHO2dCQUN6QixJQUFJLENBQUNDLGNBQWM7Z0JBRW5CLDJCQUEyQjtnQkFDM0IsSUFBSSxDQUFDQyxpQkFBaUI7WUFDeEI7WUFFQSxJQUFJLENBQUNkLEVBQUUsQ0FBQ2UsU0FBUyxHQUFHLENBQUNDO2dCQUNuQixJQUFJO29CQUNGLE1BQU1DLFVBQVVDLEtBQUtDLEtBQUssQ0FBQ0gsTUFBTUksSUFBSTtvQkFDckMsSUFBSSxDQUFDQyxhQUFhLENBQUNK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LEVBQUUsR0FBRztRQUNaO1FBRUEsSUFBSSxDQUFDa0QsWUFBWSxHQUFHLEVBQUU7SUFDeEI7SUFFQTJDLGNBQXVCO1lBQ2Q7UUFBUCxPQUFPLGlCQUFJLENBQUM3RixFQUFFLGNBQVAsd0NBQVNDLFVBQVUsTUFBS0MsVUFBVUMsSUFBSTtJQUMvQztJQUVBMkYscUJBQW9DO1lBQzNCO1lBQUE7UUFBUCxPQUFPLHVDQUFJLENBQUM5RixFQUFFLGNBQVAsd0NBQVNDLFVBQVUsY0FBbkIsdURBQXVCO0lBQ2hDO0lBN1JBOEYsYUFBYzthQVhOL0YsS0FBdUI7YUFDdkJZLG9CQUFvQjthQUNwQmlCLHVCQUF1QjthQUN2QkksaUJBQWlCO2FBQ2pCRyxvQkFBMkM7YUFDM0NTLGtCQUF5RCxJQUFJbUQ7YUFDN0RwRyxTQUF3QjthQUN4QkMsUUFBdUI7YUFDdkJFLGVBQWU7YUFDZm1ELGVBQW1DLEVBQUU7SUFHM0Msb0NBQW9DO0lBQ3RDO0FBNFJGO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU0rQyxZQUFZLElBQUl2RyxtQkFBbUI7QUFFaEQsaUNBQWlDO0FBQ2pDLElBQUksSUFBa0IsRUFBYTtJQUNqQ3dHLE9BQU9DLGdCQUFnQixDQUFDLGdCQUFnQjtRQUN0Q0YsVUFBVWYsY0FBYyxDQUFDO1FBQ3pCZSxVQUFVTixVQUFVO0lBQ3RCO0lBRUEsdUNBQXVDO0lBQ3ZDUyxTQUFTRCxnQkFBZ0IsQ0FBQyxvQkFBb0I7UUFDNUMsSUFBSUMsU0FBU0MsTUFBTSxFQUFFO1lBQ25CSixVQUFVZixjQUFjLENBQUM7UUFDM0IsT0FBTztZQUNMZSxVQUFVZixjQUFjLENBQUM7UUFDM0I7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvd2Vic29ja2V0LnRzP2M2OTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENpcGhlckxpbmsgV2ViU29ja2V0IE1hbmFnZXJcclxuICogSGFuZGxlcyByZWFsLXRpbWUgbWVzc2FnaW5nLCBwcmVzZW5jZSwgYW5kIGNhbGwgc2lnbmFsaW5nXHJcbiAqL1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBXZWJTb2NrZXRNZXNzYWdlIHtcclxuICB0eXBlOiAnbWVzc2FnZScgfCAncHJlc2VuY2UnIHwgJ3R5cGluZycgfCAnZGVsaXZlcnlfcmVjZWlwdCcgfCAncmVhZF9yZWNlaXB0JyB8XHJcbiAgJ3BpbmcnIHwgJ3BvbmcnIHwgJ2Nvbm5lY3RlZCcgfCAnbWVzc2FnZV9zZW50JyB8ICdlcnJvcicgfFxyXG4gICdjYWxsX29mZmVyJyB8ICdjYWxsX2Fuc3dlcicgfCAnY2FsbF9yZWplY3QnIHwgJ2NhbGxfcmVqZWN0ZWQnIHxcclxuICAnY2FsbF9lbmQnIHwgJ2NhbGxfZW5kZWQnIHwgJ2NhbGxfZmFpbGVkJyB8ICdpY2VfY2FuZGlkYXRlJyB8XHJcbiAgJ3ByZXNlbmNlX3N1YnNjcmliZScgfCAnZ2V0X29ubGluZV9zdGF0dXMnIHwgJ29ubGluZV9zdGF0dXMnIHxcclxuICAnZGVsZXRlX21lc3NhZ2UnIHwgJ2RlbGV0ZV9tZXNzYWdlX3JlY2VpdmVkJyB8ICdkZWxldGVfY29udmVyc2F0aW9uJyB8ICdkZWxldGVfY29udmVyc2F0aW9uX3JlY2VpdmVkJztcclxuICBkYXRhPzogYW55O1xyXG4gIHRpbWVzdGFtcDogc3RyaW5nO1xyXG4gIFtrZXk6IHN0cmluZ106IGFueTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQcmVzZW5jZVVwZGF0ZSB7XHJcbiAgdXNlcm5hbWU6IHN0cmluZztcclxuICBpc19vbmxpbmU6IGJvb2xlYW47XHJcbiAgbGFzdF9zZWVuPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFR5cGluZ0luZGljYXRvciB7XHJcbiAgdXNlcm5hbWU6IHN0cmluZztcclxuICBpc190eXBpbmc6IGJvb2xlYW47XHJcbn1cclxuXHJcbmNsYXNzIFdlYlNvY2tldE1hbmFnZXIge1xyXG4gIHByaXZhdGUgd3M6IFdlYlNvY2tldCB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgcmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xyXG4gIHByaXZhdGUgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSAxMDtcclxuICBwcml2YXRlIHJlY29ubmVjdERlbGF5ID0gMTAwMDtcclxuICBwcml2YXRlIGhlYXJ0YmVhdEludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgbWVzc2FnZUhhbmRsZXJzOiBNYXA8c3RyaW5nLCBTZXQ8KGRhdGE6IGFueSkgPT4gdm9pZD4+ID0gbmV3IE1hcCgpO1xyXG4gIHByaXZhdGUgdXNlcklkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIHRva2VuOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIGlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gIHByaXZhdGUgbWVzc2FnZVF1ZXVlOiBXZWJTb2NrZXRNZXNzYWdlW10gPSBbXTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAvLyBEb24ndCBhdXRvLWNvbm5lY3QgaW4gY29uc3RydWN0b3JcclxuICB9XHJcblxyXG4gIGNvbm5lY3QodXNlcklkOiBzdHJpbmcsIHRva2VuOiBzdHJpbmcpIHtcclxuICAgIHRoaXMudXNlcklkID0gdXNlcklkO1xyXG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xyXG4gICAgdGhpcy5jb25uZWN0V2ViU29ja2V0KCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNvbm5lY3RXZWJTb2NrZXQoKSB7XHJcbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RpbmcgfHwgdGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaXNDb25uZWN0aW5nID0gdHJ1ZTtcclxuICAgIGNvbnN0IHdzVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfV1NfVVJMIHx8ICd3czovL2xvY2FsaG9zdDo4MDAwL3dzJztcclxuXHJcbiAgICBpZiAoIXRoaXMudG9rZW4pIHtcclxuICAgICAgY29uc29sZS53YXJuKCdObyBhdXRoIHRva2VuIGF2YWlsYWJsZSBmb3IgV2ViU29ja2V0IGNvbm5lY3Rpb24nKTtcclxuICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KGAke3dzVXJsfS9jaGF0P3Rva2VuPSR7dGhpcy50b2tlbn1gKTtcclxuXHJcbiAgICAgIHRoaXMud3Mub25vcGVuID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SXIFdlYlNvY2tldCBjb25uZWN0ZWQnKTtcclxuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhcnRIZWFydGJlYXQoKTtcclxuXHJcbiAgICAgICAgLy8gU2VuZCBhbnkgcXVldWVkIG1lc3NhZ2VzXHJcbiAgICAgICAgdGhpcy5mbHVzaE1lc3NhZ2VRdWV1ZSgpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgICB0aGlzLmhhbmRsZU1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBXZWJTb2NrZXQgbWVzc2FnZTonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy53cy5vbmNsb3NlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ/CflIwgV2ViU29ja2V0IGRpc2Nvbm5lY3RlZDonLCBldmVudC5jb2RlLCBldmVudC5yZWFzb24pO1xyXG4gICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zdG9wSGVhcnRiZWF0KCk7XHJcbiAgICAgICAgdGhpcy5hdHRlbXB0UmVjb25uZWN0KCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLndzLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgV2ViU29ja2V0IGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gICAgICB9O1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgV2ViU29ja2V0IGNvbm5lY3Rpb246JywgZXJyb3IpO1xyXG4gICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLmF0dGVtcHRSZWNvbm5lY3QoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXR0ZW1wdFJlY29ubmVjdCgpIHtcclxuICAgIGlmICh0aGlzLnJlY29ubmVjdEF0dGVtcHRzID49IHRoaXMubWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignTWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyByZWFjaGVkJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzKys7XHJcbiAgICBjb25zdCBkZWxheSA9IE1hdGgubWluKHRoaXMucmVjb25uZWN0RGVsYXkgKiBNYXRoLnBvdygyLCB0aGlzLnJlY29ubmVjdEF0dGVtcHRzIC0gMSksIDMwMDAwKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhgQXR0ZW1wdGluZyB0byByZWNvbm5lY3QgaW4gJHtkZWxheX1tcyAoYXR0ZW1wdCAke3RoaXMucmVjb25uZWN0QXR0ZW1wdHN9KWApO1xyXG5cclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzLmNvbm5lY3RXZWJTb2NrZXQoKTtcclxuICAgIH0sIGRlbGF5KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhcnRIZWFydGJlYXQoKSB7XHJcbiAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICB0aGlzLnNlbmQoe1xyXG4gICAgICAgICAgdHlwZTogJ3BpbmcnLFxyXG4gICAgICAgICAgZGF0YToge30sXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9LCAzMDAwMCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN0b3BIZWFydGJlYXQoKSB7XHJcbiAgICBpZiAodGhpcy5oZWFydGJlYXRJbnRlcnZhbCkge1xyXG4gICAgICBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwpO1xyXG4gICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgaGFuZGxlTWVzc2FnZShtZXNzYWdlOiBhbnkpIHtcclxuICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLnR5cGU7XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMubWVzc2FnZUhhbmRsZXJzLmdldCh0eXBlKTtcclxuXHJcbiAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMuc2l6ZSA+IDApIHtcclxuICAgICAgaGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaGFuZGxlcihtZXNzYWdlKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciBmb3IgJHt0eXBlfTpgLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ3BvbmcnKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdVbmhhbmRsZWQgV2ViU29ja2V0IG1lc3NhZ2UgdHlwZTonLCB0eXBlLCBtZXNzYWdlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZmx1c2hNZXNzYWdlUXVldWUoKSB7XHJcbiAgICB3aGlsZSAodGhpcy5tZXNzYWdlUXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlUXVldWUuc2hpZnQoKTtcclxuICAgICAgaWYgKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLnNlbmQobWVzc2FnZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYyBtZXRob2RzXHJcbiAgc2VuZChtZXNzYWdlOiBXZWJTb2NrZXRNZXNzYWdlKSB7XHJcbiAgICBpZiAodGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgY29uc29sZS5sb2coYPCfk6QgU2VuZGluZyAke21lc3NhZ2UudHlwZX0gbWVzc2FnZTpgLCBtZXNzYWdlKTtcclxuICAgICAgdGhpcy53cy5zZW5kKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFF1ZXVlIG1lc3NhZ2UgZm9yIGxhdGVyXHJcbiAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLnB1c2gobWVzc2FnZSk7XHJcbiAgICAgIGNvbnNvbGUud2Fybihg4o+zIFdlYlNvY2tldCBub3QgY29ubmVjdGVkIChzdGF0ZTogJHt0aGlzLndzPy5yZWFkeVN0YXRlfSksIHF1ZXVpbmcgJHttZXNzYWdlLnR5cGV9IG1lc3NhZ2VgKTtcclxuXHJcbiAgICAgIC8vIFRyeSB0byByZWNvbm5lY3QgaWYgbm90IGNvbm5lY3RpbmdcclxuICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGluZyAmJiB0aGlzLnVzZXJJZCAmJiB0aGlzLnRva2VuKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ/CflIQgVHJpZ2dlcmluZyByZWNvbm5lY3Rpb24gZnJvbSBzZW5kIGZhaWx1cmUnKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy51c2VySWQsIHRoaXMudG9rZW4pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IChkYXRhOiBhbnkpID0+IHZvaWQpIHtcclxuICAgIGlmICghdGhpcy5tZXNzYWdlSGFuZGxlcnMuaGFzKHR5cGUpKSB7XHJcbiAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzLnNldCh0eXBlLCBuZXcgU2V0KCkpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlcnMuZ2V0KHR5cGUpIS5hZGQoaGFuZGxlcik7XHJcbiAgfVxyXG5cclxuICBvZmYodHlwZTogc3RyaW5nLCBoYW5kbGVyPzogKGRhdGE6IGFueSkgPT4gdm9pZCkge1xyXG4gICAgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcnMuZ2V0KHR5cGUpPy5kZWxldGUoaGFuZGxlcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVycy5kZWxldGUodHlwZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbk1lc3NhZ2UodHlwZTogc3RyaW5nLCBoYW5kbGVyOiAoZGF0YTogYW55KSA9PiB2b2lkKSB7XHJcbiAgICB0aGlzLm9uKHR5cGUsIGhhbmRsZXIpO1xyXG4gIH1cclxuXHJcbiAgb2ZmTWVzc2FnZSh0eXBlOiBzdHJpbmcpIHtcclxuICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzLmRlbGV0ZSh0eXBlKTtcclxuICB9XHJcblxyXG4gIC8vIFNlbmQgZW5jcnlwdGVkIG1lc3NhZ2VcclxuICBzZW5kRW5jcnlwdGVkTWVzc2FnZShyZWNpcGllbnRVc2VybmFtZTogc3RyaW5nLCBlbmNyeXB0ZWRDb250ZW50OiBzdHJpbmcsIG1lc3NhZ2VUeXBlOiBzdHJpbmcgPSAndGV4dCcsIGZpbGVNZXRhZGF0YT86IGFueSkge1xyXG4gICAgdGhpcy5zZW5kKHtcclxuICAgICAgdHlwZTogJ21lc3NhZ2UnLFxyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgcmVjaXBpZW50X3VzZXJuYW1lOiByZWNpcGllbnRVc2VybmFtZSxcclxuICAgICAgICBlbmNyeXB0ZWRfY29udGVudDogZW5jcnlwdGVkQ29udGVudCxcclxuICAgICAgICBtZXNzYWdlX3R5cGU6IG1lc3NhZ2VUeXBlLFxyXG4gICAgICAgIGZpbGVfbWV0YWRhdGE6IGZpbGVNZXRhZGF0YSxcclxuICAgICAgfSxcclxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc2VuZFR5cGluZ0luZGljYXRvcihyZWNpcGllbnRVc2VybmFtZTogc3RyaW5nLCBpc1R5cGluZzogYm9vbGVhbikge1xyXG4gICAgdGhpcy5zZW5kKHtcclxuICAgICAgdHlwZTogJ3R5cGluZycsXHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICByZWNpcGllbnRfdXNlcm5hbWU6IHJlY2lwaWVudFVzZXJuYW1lLFxyXG4gICAgICAgIGlzX3R5cGluZzogaXNUeXBpbmdcclxuICAgICAgfSxcclxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc2VuZERlbGl2ZXJ5UmVjZWlwdChtZXNzYWdlSWQ6IG51bWJlciwgc2VuZGVySWQ6IG51bWJlcikge1xyXG4gICAgdGhpcy5zZW5kKHtcclxuICAgICAgdHlwZTogJ2RlbGl2ZXJ5X3JlY2VpcHQnLFxyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgbWVzc2FnZV9pZDogbWVzc2FnZUlkLFxyXG4gICAgICAgIHNlbmRlcl9pZDogc2VuZGVySWRcclxuICAgICAgfSxcclxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc2VuZFJlYWRSZWNlaXB0KG1lc3NhZ2VJZDogbnVtYmVyLCBzZW5kZXJJZDogbnVtYmVyKSB7XHJcbiAgICB0aGlzLnNlbmQoe1xyXG4gICAgICB0eXBlOiAncmVhZF9yZWNlaXB0JyxcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIG1lc3NhZ2VfaWQ6IG1lc3NhZ2VJZCxcclxuICAgICAgICBzZW5kZXJfaWQ6IHNlbmRlcklkXHJcbiAgICAgIH0sXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZVByZXNlbmNlKGlzT25saW5lOiBib29sZWFuKSB7XHJcbiAgICB0aGlzLnNlbmQoe1xyXG4gICAgICB0eXBlOiAncHJlc2VuY2UnLFxyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgaXNfb25saW5lOiBpc09ubGluZVxyXG4gICAgICB9LFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBzdWJzY3JpYmVUb1ByZXNlbmNlKHVzZXJJZHM6IG51bWJlcltdKSB7XHJcbiAgICB0aGlzLnNlbmQoe1xyXG4gICAgICB0eXBlOiAncHJlc2VuY2Vfc3Vic2NyaWJlJyxcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIHVzZXJfaWRzOiB1c2VySWRzXHJcbiAgICAgIH0sXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGdldE9ubGluZVN0YXR1cyh1c2VySWRzOiBudW1iZXJbXSkge1xyXG4gICAgdGhpcy5zZW5kKHtcclxuICAgICAgdHlwZTogJ2dldF9vbmxpbmVfc3RhdHVzJyxcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIHVzZXJfaWRzOiB1c2VySWRzXHJcbiAgICAgIH0sXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIFNlbmQgZGVsZXRlIG1lc3NhZ2UgZXZlbnQgKGRlbGV0ZSBmb3IgZXZlcnlvbmUpXHJcbiAgc2VuZERlbGV0ZU1lc3NhZ2UobWVzc2FnZUlkOiBudW1iZXIsIHJlY2lwaWVudFVzZXJuYW1lOiBzdHJpbmcpIHtcclxuICAgIHRoaXMuc2VuZCh7XHJcbiAgICAgIHR5cGU6ICdkZWxldGVfbWVzc2FnZScsXHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICBtZXNzYWdlX2lkOiBtZXNzYWdlSWQsXHJcbiAgICAgICAgcmVjaXBpZW50X3VzZXJuYW1lOiByZWNpcGllbnRVc2VybmFtZSxcclxuICAgICAgfSxcclxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gU2VuZCBkZWxldGUgY29udmVyc2F0aW9uIGV2ZW50IChkZWxldGUgZm9yIGV2ZXJ5b25lKVxyXG4gIHNlbmREZWxldGVDb252ZXJzYXRpb24ocmVjaXBpZW50VXNlcm5hbWU6IHN0cmluZykge1xyXG4gICAgdGhpcy5zZW5kKHtcclxuICAgICAgdHlwZTogJ2RlbGV0ZV9jb252ZXJzYXRpb24nLFxyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgcmVjaXBpZW50X3VzZXJuYW1lOiByZWNpcGllbnRVc2VybmFtZSxcclxuICAgICAgfSxcclxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZGlzY29ubmVjdCgpIHtcclxuICAgIHRoaXMuc3RvcEhlYXJ0YmVhdCgpO1xyXG4gICAgdGhpcy51cGRhdGVQcmVzZW5jZShmYWxzZSk7XHJcblxyXG4gICAgaWYgKHRoaXMud3MpIHtcclxuICAgICAgdGhpcy53cy5jbG9zZSgpO1xyXG4gICAgICB0aGlzLndzID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IFtdO1xyXG4gIH1cclxuXHJcbiAgaXNDb25uZWN0ZWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU47XHJcbiAgfVxyXG5cclxuICBnZXRDb25uZWN0aW9uU3RhdGUoKTogbnVtYmVyIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy53cz8ucmVhZHlTdGF0ZSA/PyBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxyXG5leHBvcnQgY29uc3Qgd3NNYW5hZ2VyID0gbmV3IFdlYlNvY2tldE1hbmFnZXIoKTtcclxuXHJcbi8vIEF1dG8tZGlzY29ubmVjdCBvbiBwYWdlIHVubG9hZFxyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgKCkgPT4ge1xyXG4gICAgd3NNYW5hZ2VyLnVwZGF0ZVByZXNlbmNlKGZhbHNlKTtcclxuICAgIHdzTWFuYWdlci5kaXNjb25uZWN0KCk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIFVwZGF0ZSBwcmVzZW5jZSBvbiB2aXNpYmlsaXR5IGNoYW5nZVxyXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XHJcbiAgICAgIHdzTWFuYWdlci51cGRhdGVQcmVzZW5jZShmYWxzZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3c01hbmFnZXIudXBkYXRlUHJlc2VuY2UodHJ1ZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0iXSwibmFtZXMiOlsiV2ViU29ja2V0TWFuYWdlciIsImNvbm5lY3QiLCJ1c2VySWQiLCJ0b2tlbiIsImNvbm5lY3RXZWJTb2NrZXQiLCJpc0Nvbm5lY3RpbmciLCJ3cyIsInJlYWR5U3RhdGUiLCJXZWJTb2NrZXQiLCJPUEVOIiwid3NVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfV1NfVVJMIiwiY29uc29sZSIsIndhcm4iLCJvbm9wZW4iLCJsb2ciLCJyZWNvbm5lY3RBdHRlbXB0cyIsInN0YXJ0SGVhcnRiZWF0IiwiZmx1c2hNZXNzYWdlUXVldWUiLCJvbm1lc3NhZ2UiLCJldmVudCIsIm1lc3NhZ2UiLCJKU09OIiwicGFyc2UiLCJkYXRhIiwiaGFuZGxlTWVzc2FnZSIsImVycm9yIiwib25jbG9zZSIsImNvZGUiLCJyZWFzb24iLCJzdG9wSGVhcnRiZWF0IiwiYXR0ZW1wdFJlY29ubmVjdCIsIm9uZXJyb3IiLCJtYXhSZWNvbm5lY3RBdHRlbXB0cyIsImRlbGF5IiwiTWF0aCIsIm1pbiIsInJlY29ubmVjdERlbGF5IiwicG93Iiwic2V0VGltZW91dCIsImhlYXJ0YmVhdEludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJzZW5kIiwidHlwZSIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNsZWFySW50ZXJ2YWwiLCJoYW5kbGVycyIsIm1lc3NhZ2VIYW5kbGVycyIsImdldCIsInNpemUiLCJmb3JFYWNoIiwiaGFuZGxlciIsIm1lc3NhZ2VRdWV1ZSIsImxlbmd0aCIsInNoaWZ0Iiwic3RyaW5naWZ5IiwicHVzaCIsIm9uIiwiaGFzIiwic2V0IiwiU2V0IiwiYWRkIiwib2ZmIiwiZGVsZXRlIiwib25NZXNzYWdlIiwib2ZmTWVzc2FnZSIsInNlbmRFbmNyeXB0ZWRNZXNzYWdlIiwicmVjaXBpZW50VXNlcm5hbWUiLCJlbmNyeXB0ZWRDb250ZW50IiwibWVzc2FnZVR5cGUiLCJmaWxlTWV0YWRhdGEiLCJyZWNpcGllbnRfdXNlcm5hbWUiLCJlbmNyeXB0ZWRfY29udGVudCIsIm1lc3NhZ2VfdHlwZSIsImZpbGVfbWV0YWRhdGEiLCJzZW5kVHlwaW5nSW5kaWNhdG9yIiwiaXNUeXBpbmciLCJpc190eXBpbmciLCJzZW5kRGVsaXZlcnlSZWNlaXB0IiwibWVzc2FnZUlkIiwic2VuZGVySWQiLCJtZXNzYWdlX2lkIiwic2VuZGVyX2lkIiwic2VuZFJlYWRSZWNlaXB0IiwidXBkYXRlUHJlc2VuY2UiLCJpc09ubGluZSIsImlzX29ubGluZSIsInN1YnNjcmliZVRvUHJlc2VuY2UiLCJ1c2VySWRzIiwidXNlcl9pZHMiLCJnZXRPbmxpbmVTdGF0dXMiLCJzZW5kRGVsZXRlTWVzc2FnZSIsInNlbmREZWxldGVDb252ZXJzYXRpb24iLCJkaXNjb25uZWN0IiwiY2xvc2UiLCJpc0Nvbm5lY3RlZCIsImdldENvbm5lY3Rpb25TdGF0ZSIsImNvbnN0cnVjdG9yIiwiTWFwIiwid3NNYW5hZ2VyIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImRvY3VtZW50IiwiaGlkZGVuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/websocket.ts\n"));

/***/ })

});