"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/store.ts":
/*!**************************!*\
  !*** ./src/lib/store.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useStore: function() { return /* binding */ useStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"(app-pages-browser)/./src/lib/api.ts\");\n/* harmony import */ var _crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crypto */ \"(app-pages-browser)/./src/lib/crypto.ts\");\n/* harmony import */ var _websocket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./websocket */ \"(app-pages-browser)/./src/lib/websocket.ts\");\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./storage */ \"(app-pages-browser)/./src/lib/storage.ts\");\n/**\r\n * CipherLink Global State Store\r\n * Uses Zustand for state management\r\n */ \n\n\n\n\n\nconst useStore = (0,zustand__WEBPACK_IMPORTED_MODULE_4__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_5__.persist)((set, get)=>({\n        // Initial state\n        user: null,\n        token: null,\n        isAuthenticated: false,\n        isLoading: false,\n        error: null,\n        privateKey: null,\n        publicKey: null,\n        identityKey: null,\n        identityPrivateKey: null,\n        contacts: [],\n        conversations: [],\n        currentConversation: null,\n        messages: new Map(),\n        onlineUsers: new Set(),\n        typingUsers: new Map(),\n        callHistory: [],\n        // ============ Auth Actions ============\n        login: async (username, password)=>{\n            set({\n                isLoading: true,\n                error: null\n            });\n            try {\n                var _keys_publicKey, _user_public_key, _keys_privateKey;\n                const response = await _api__WEBPACK_IMPORTED_MODULE_0__.api.login(username, password);\n                let user = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getCurrentUser();\n                // Store token\n                localStorage.setItem(\"cipherlink_token\", response.access_token);\n                localStorage.setItem(\"cipherlink_username\", username);\n                // Load or generate keys\n                let keys = _crypto__WEBPACK_IMPORTED_MODULE_1__.KeyStorage.load(username);\n                let needsUpload = !user.public_key;\n                let keyMismatch = false;\n                // Verify key consistency if both local and server keys exist\n                if (keys && user.public_key) {\n                    const isConsistent = _crypto__WEBPACK_IMPORTED_MODULE_1__.KeyStorage.verifyKeyConsistency(username, user.public_key);\n                    if (!isConsistent) {\n                        console.warn(\"⚠️ Key mismatch detected! Local key differs from server key.\");\n                        console.warn(\"This may happen if you logged in from a different device.\");\n                        console.warn(\"Old messages encrypted with the server key may not decrypt correctly.\");\n                        keyMismatch = true;\n                    // Keep local keys but mark the mismatch\n                    }\n                }\n                if (!keys) {\n                    // Generate new proper key bundle\n                    console.log(\"\\uD83D\\uDD10 Generating new key bundle...\");\n                    const { bundle, privateKeys } = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.generateKeyBundle)(5);\n                    keys = {\n                        privateKey: privateKeys.signedPrekeyPrivate,\n                        publicKey: bundle.publicKey,\n                        identityKey: bundle.identityKey,\n                        signedPrekey: bundle.signedPrekey,\n                        signedPrekeySignature: bundle.signedPrekeySignature,\n                        identityPrivateKey: privateKeys.identityPrivate,\n                        oneTimePrekeys: bundle.oneTimePrekeys\n                    };\n                    _crypto__WEBPACK_IMPORTED_MODULE_1__.KeyStorage.save(username, keys);\n                    needsUpload = true;\n                    console.log(\"✅ Key bundle generated\");\n                }\n                // CRITICAL: Verify that privateKey and publicKey form a valid pair\n                if (keys.privateKey && keys.publicKey) {\n                    const isValidPair = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.verifyKeyPair)(keys.privateKey, keys.publicKey);\n                    console.log(\"\\uD83D\\uDD11 Key pair verification:\", isValidPair ? \"✅ VALID\" : \"❌ INVALID\");\n                    if (!isValidPair) {\n                        var _keys_publicKey1;\n                        // The stored public key doesn't match the private key!\n                        // Derive the correct public key from the private key\n                        console.warn(\"⚠️ Key pair mismatch detected! Deriving correct public key...\");\n                        const correctPublicKey = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.derivePublicKeyFromPrivate)(keys.privateKey);\n                        console.log(\"\\uD83D\\uDD27 Original publicKey:\", (_keys_publicKey1 = keys.publicKey) === null || _keys_publicKey1 === void 0 ? void 0 : _keys_publicKey1.substring(0, 30));\n                        console.log(\"\\uD83D\\uDD27 Derived publicKey:\", correctPublicKey === null || correctPublicKey === void 0 ? void 0 : correctPublicKey.substring(0, 30));\n                        // Update the keys with the correct public key\n                        keys.publicKey = correctPublicKey;\n                        _crypto__WEBPACK_IMPORTED_MODULE_1__.KeyStorage.save(username, keys);\n                        needsUpload = true; // Need to upload the corrected key\n                        console.log(\"✅ Key pair corrected and saved\");\n                    }\n                }\n                // Upload keys if not on server OR if we corrected the key pair\n                if (needsUpload && keys) {\n                    var _keys_publicKey2;\n                    console.log(\"\\uD83D\\uDCE4 Uploading keys to server...\", {\n                        publicKeyToUpload: (_keys_publicKey2 = keys.publicKey) === null || _keys_publicKey2 === void 0 ? void 0 : _keys_publicKey2.substring(0, 30)\n                    });\n                    try {\n                        var _user_public_key1;\n                        await _api__WEBPACK_IMPORTED_MODULE_0__.api.uploadKeys({\n                            public_key: keys.publicKey || \"\",\n                            identity_key: keys.identityKey || \"\",\n                            signed_prekey: keys.signedPrekey || keys.publicKey || \"\",\n                            signed_prekey_signature: keys.signedPrekeySignature || \"\",\n                            one_time_prekeys: keys.oneTimePrekeys || []\n                        });\n                        // Refresh user to get updated public_key\n                        user = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getCurrentUser();\n                        console.log(\"✅ Keys uploaded successfully!\", {\n                            serverNowHas: (_user_public_key1 = user.public_key) === null || _user_public_key1 === void 0 ? void 0 : _user_public_key1.substring(0, 30)\n                        });\n                    } catch (uploadError) {\n                        var _uploadError_response;\n                        console.error(\"❌ Failed to upload keys:\", (uploadError === null || uploadError === void 0 ? void 0 : (_uploadError_response = uploadError.response) === null || _uploadError_response === void 0 ? void 0 : _uploadError_response.data) || uploadError);\n                    }\n                }\n                // Final verification: ensure local key matches server key\n                const localServerMatch = (keys === null || keys === void 0 ? void 0 : keys.publicKey) === user.public_key;\n                console.log(\"\\uD83D\\uDD10 Final Key Status:\", {\n                    username,\n                    localPubKey: keys === null || keys === void 0 ? void 0 : (_keys_publicKey = keys.publicKey) === null || _keys_publicKey === void 0 ? void 0 : _keys_publicKey.substring(0, 30),\n                    serverPubKey: (_user_public_key = user.public_key) === null || _user_public_key === void 0 ? void 0 : _user_public_key.substring(0, 30),\n                    localPrivKey: keys === null || keys === void 0 ? void 0 : (_keys_privateKey = keys.privateKey) === null || _keys_privateKey === void 0 ? void 0 : _keys_privateKey.substring(0, 30),\n                    LOCAL_MATCHES_SERVER: localServerMatch ? \"✅ YES\" : \"❌ NO\"\n                });\n                if (!localServerMatch && (keys === null || keys === void 0 ? void 0 : keys.publicKey) && user.public_key) {\n                    console.error(\"\\uD83D\\uDEA8 CRITICAL: Local public key does not match server! This will cause decryption failures.\");\n                    console.log(\"\\uD83D\\uDD27 Attempting to force upload correct key...\");\n                    try {\n                        var _user_public_key2;\n                        await _api__WEBPACK_IMPORTED_MODULE_0__.api.uploadKeys({\n                            public_key: keys.publicKey || \"\",\n                            identity_key: keys.identityKey || \"\",\n                            signed_prekey: keys.signedPrekey || keys.publicKey || \"\",\n                            signed_prekey_signature: keys.signedPrekeySignature || \"\",\n                            one_time_prekeys: keys.oneTimePrekeys || []\n                        });\n                        user = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getCurrentUser();\n                        console.log(\"✅ Force upload complete, server now has:\", (_user_public_key2 = user.public_key) === null || _user_public_key2 === void 0 ? void 0 : _user_public_key2.substring(0, 30));\n                    } catch (e) {\n                        console.error(\"❌ Force upload failed:\", e);\n                    }\n                }\n                set({\n                    user,\n                    token: response.access_token,\n                    isAuthenticated: true,\n                    isLoading: false,\n                    privateKey: keys.privateKey || null,\n                    publicKey: keys.publicKey || null,\n                    identityKey: keys.identityKey || null\n                });\n                // Connect WebSocket\n                _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.connect(user.id.toString(), response.access_token);\n                // Setup message handlers\n                if (!window._wsHandlersRegistered) {\n                    setupWebSocketHandlers(get, set);\n                    window._wsHandlersRegistered = true;\n                }\n            } catch (error) {\n                var _error_response_data, _error_response;\n                set({\n                    isLoading: false,\n                    error: ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.detail) || \"Login failed\"\n                });\n                throw error;\n            }\n        },\n        register: async (username, email, password)=>{\n            set({\n                isLoading: true,\n                error: null\n            });\n            try {\n                const deviceId = \"web-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).slice(2));\n                await _api__WEBPACK_IMPORTED_MODULE_0__.api.register(username, email, password, deviceId);\n                // Auto-login after registration\n                await get().login(username, password);\n            } catch (error) {\n                var _error_response_data, _error_response;\n                set({\n                    isLoading: false,\n                    error: ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.detail) || \"Registration failed\"\n                });\n                throw error;\n            }\n        },\n        logout: ()=>{\n            _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.disconnect();\n            window._wsHandlersRegistered = false;\n            localStorage.removeItem(\"cipherlink_token\");\n            localStorage.removeItem(\"cipherlink_username\");\n            _api__WEBPACK_IMPORTED_MODULE_0__.api.setToken(null);\n            set({\n                user: null,\n                token: null,\n                isAuthenticated: false,\n                privateKey: null,\n                publicKey: null,\n                identityKey: null,\n                identityPrivateKey: null,\n                contacts: [],\n                conversations: [],\n                currentConversation: null,\n                messages: new Map(),\n                onlineUsers: new Set(),\n                typingUsers: new Map(),\n                callHistory: []\n            });\n        },\n        initializeWebSocket: ()=>{\n            const { user, token } = get();\n            if (user && token) {\n                _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.connect(user.id.toString(), token);\n                if (!window._wsHandlersRegistered) {\n                    setupWebSocketHandlers(get, set);\n                    window._wsHandlersRegistered = true;\n                }\n            }\n        },\n        loadStoredAuth: async ()=>{\n            const token = localStorage.getItem(\"cipherlink_token\");\n            const username = localStorage.getItem(\"cipherlink_username\");\n            if (token && username) {\n                _api__WEBPACK_IMPORTED_MODULE_0__.api.setToken(token);\n                try {\n                    const user = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getCurrentUser();\n                    const keys = _crypto__WEBPACK_IMPORTED_MODULE_1__.KeyStorage.load(username);\n                    set({\n                        user,\n                        token,\n                        isAuthenticated: true,\n                        privateKey: (keys === null || keys === void 0 ? void 0 : keys.privateKey) || null,\n                        publicKey: (keys === null || keys === void 0 ? void 0 : keys.publicKey) || null,\n                        identityKey: (keys === null || keys === void 0 ? void 0 : keys.identityKey) || null\n                    });\n                    // Connect WebSocket\n                    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.connect(user.id.toString(), token);\n                    // Setup message handlers\n                    if (!window._wsHandlersRegistered) {\n                        setupWebSocketHandlers(get, set);\n                        window._wsHandlersRegistered = true;\n                    }\n                    // Load persistent data from IndexedDB\n                    await get().loadPersistedData();\n                    // Sync with server in background\n                    get().syncWithServer().catch(console.error);\n                    return;\n                } catch (e) {\n                    // Token expired or invalid\n                    localStorage.removeItem(\"cipherlink_token\");\n                    localStorage.removeItem(\"cipherlink_username\");\n                }\n            }\n        },\n        // ============ Crypto Actions ============\n        generateAndUploadKeys: async ()=>{\n            const { user } = get();\n            if (!user) return;\n            const keyPair = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.generateKeyPair)();\n            const signingPair = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.generateSigningKeyPair)();\n            // Save locally\n            _crypto__WEBPACK_IMPORTED_MODULE_1__.KeyStorage.save(user.username, {\n                privateKey: keyPair.privateKey,\n                publicKey: keyPair.publicKey,\n                identityKey: signingPair.publicKey\n            });\n            // Upload to server\n            await _api__WEBPACK_IMPORTED_MODULE_0__.api.uploadKeys({\n                public_key: keyPair.publicKey,\n                identity_key: signingPair.publicKey,\n                signed_prekey: keyPair.publicKey,\n                signed_prekey_signature: signingPair.publicKey,\n                one_time_prekeys: []\n            });\n            set({\n                privateKey: keyPair.privateKey,\n                publicKey: keyPair.publicKey,\n                identityKey: signingPair.publicKey\n            });\n        },\n        loadStoredKeys: ()=>{\n            const { user } = get();\n            if (!user) return;\n            const keys = _crypto__WEBPACK_IMPORTED_MODULE_1__.KeyStorage.load(user.username);\n            if (keys) {\n                set({\n                    privateKey: keys.privateKey,\n                    publicKey: keys.publicKey,\n                    identityKey: keys.identityKey\n                });\n            }\n        },\n        // ============ Chat Actions ============\n        loadContacts: async ()=>{\n            try {\n                const contacts = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getContacts();\n                set({\n                    contacts\n                });\n            } catch (error) {\n                console.error(\"Failed to load contacts:\", error);\n            }\n        },\n        loadConversations: async ()=>{\n            try {\n                const conversations = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getConversations();\n                set({\n                    conversations\n                });\n            } catch (error) {\n                console.error(\"Failed to load conversations:\", error);\n            }\n        },\n        loadMessages: async (username)=>{\n            try {\n                const messages = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getConversation(username);\n                // Try to decrypt messages\n                const { privateKey, contacts, user } = get();\n                if (privateKey) {\n                    for (const msg of messages){\n                        if (msg.encrypted_content && !msg._decryptedContent) {\n                            try {\n                                const encryptedData = JSON.parse(msg.encrypted_content);\n                                // v2 protocol: senderPublicKey is embedded in message\n                                // v1 protocol: use contact's cached public key as fallback\n                                let fallbackPublicKey;\n                                if (msg.sender_username === (user === null || user === void 0 ? void 0 : user.username)) {\n                                    var _contacts_find;\n                                    // Sent by me -> fallback is recipient's public key\n                                    fallbackPublicKey = (_contacts_find = contacts.find((c)=>c.contact_username === msg.recipient_username)) === null || _contacts_find === void 0 ? void 0 : _contacts_find.public_key;\n                                } else {\n                                    // Received by me -> fallback is sender's public key\n                                    const contact = contacts.find((c)=>c.contact_username === msg.sender_username);\n                                    fallbackPublicKey = contact === null || contact === void 0 ? void 0 : contact.public_key;\n                                }\n                                // decryptMessage now handles v2 (embedded key) and v1 (fallback key)\n                                const decrypted = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.decryptMessage)(encryptedData, fallbackPublicKey || \"\", privateKey);\n                                msg._decryptedContent = decrypted;\n                            } catch (e) {\n                                console.warn(\"Failed to decrypt message:\", msg.id, e);\n                            }\n                        }\n                    }\n                }\n                const newMessages = new Map(get().messages);\n                newMessages.set(username, messages);\n                set({\n                    messages: newMessages\n                });\n            } catch (error) {\n                console.error(\"Failed to load messages:\", error);\n            }\n        },\n        sendMessage: async function(recipientUsername, content) {\n            let messageType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"text\", fileData = arguments.length > 3 ? arguments[3] : void 0;\n            console.log(\"\\uD83D\\uDCE4 sendMessage called:\", {\n                recipientUsername,\n                content: content.substring(0, 50),\n                messageType\n            });\n            let { privateKey, publicKey, user } = get();\n            if (!privateKey || !publicKey || !user) {\n                console.error(\"Cannot send message: missing keys or user\", {\n                    hasPrivateKey: !!privateKey,\n                    hasPublicKey: !!publicKey,\n                    hasUser: !!user\n                });\n                return;\n            }\n            // CRITICAL: Verify our key pair is valid before sending\n            const isValidPair = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.verifyKeyPair)(privateKey, publicKey);\n            if (!isValidPair) {\n                console.warn(\"⚠️ Invalid key pair detected in sendMessage! Deriving correct public key...\");\n                publicKey = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.derivePublicKeyFromPrivate)(privateKey);\n                console.log(\"\\uD83D\\uDD27 Using derived publicKey:\", publicKey === null || publicKey === void 0 ? void 0 : publicKey.substring(0, 30));\n                // Update store with corrected key\n                set({\n                    publicKey\n                });\n            }\n            // Always fetch the latest recipient public key from the server\n            console.log(\"\\uD83D\\uDCE4 Fetching public key from server for:\", recipientUsername);\n            let recipientPublicKey;\n            try {\n                const keyData = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getPublicKey(recipientUsername);\n                recipientPublicKey = keyData.public_key;\n                console.log(\"\\uD83D\\uDCE4 Got recipient public key from server:\", recipientPublicKey === null || recipientPublicKey === void 0 ? void 0 : recipientPublicKey.substring(0, 30));\n            } catch (error) {\n                console.error(\"Failed to get recipient public key:\", error);\n                throw new Error(\"Could not get recipient encryption key\");\n            }\n            if (!recipientPublicKey) {\n                throw new Error(\"Recipient has not set up encryption\");\n            }\n            // Encrypt message using static key pair (X25519)\n            // v2 protocol: includes sender's public key in the payload for reliable decryption\n            console.log(\"\\uD83D\\uDCE4 Encrypting with:\", {\n                recipientPubKey: recipientPublicKey === null || recipientPublicKey === void 0 ? void 0 : recipientPublicKey.substring(0, 30),\n                senderPrivKey: privateKey === null || privateKey === void 0 ? void 0 : privateKey.substring(0, 30),\n                senderPubKey: publicKey === null || publicKey === void 0 ? void 0 : publicKey.substring(0, 30)\n            });\n            const encrypted = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.encryptMessage)(content, recipientPublicKey, privateKey, publicKey);\n            const encryptedContent = JSON.stringify(encrypted);\n            // Add to local messages optimistically\n            const currentMessages = get().messages.get(recipientUsername) || [];\n            const optimisticId = -Date.now();\n            const optimisticMessage = {\n                id: optimisticId,\n                sender_id: user.id,\n                sender_username: user.username,\n                recipient_id: 0,\n                recipient_username: recipientUsername,\n                encrypted_content: encryptedContent,\n                message_type: messageType,\n                status: \"sending\",\n                expiry_type: \"none\",\n                created_at: new Date().toISOString(),\n                _decryptedContent: content\n            };\n            const newMessages = new Map(get().messages);\n            newMessages.set(recipientUsername, [\n                ...currentMessages,\n                optimisticMessage\n            ]);\n            set({\n                messages: newMessages\n            });\n            try {\n                console.log(\"\\uD83D\\uDCE4 Sending to API...\");\n                const sentMessage = await _api__WEBPACK_IMPORTED_MODULE_0__.api.sendMessage(recipientUsername, encryptedContent, undefined, \"none\", messageType, fileData);\n                console.log(\"✅ Message sent successfully\", sentMessage);\n                // Update optimistic message with real one while preserving decrypted content\n                sentMessage._decryptedContent = content;\n                const updatedMessages = new Map(get().messages);\n                const userMessages = updatedMessages.get(recipientUsername) || [];\n                const index = userMessages.findIndex((m)=>m.id === optimisticId);\n                if (index !== -1) {\n                    userMessages[index] = sentMessage;\n                } else {\n                    userMessages.push(sentMessage);\n                }\n                updatedMessages.set(recipientUsername, userMessages);\n                set({\n                    messages: updatedMessages\n                });\n                // Persist message and update/persist conversation snapshot for history\n                try {\n                    await get().persistMessage(sentMessage);\n                } catch (e) {\n                    console.error(\"❌ Failed to persist sent message:\", e);\n                }\n                // Update conversation preview & persist\n                const stateAfterSend = get();\n                const existingConvIndex = stateAfterSend.conversations.findIndex((c)=>c.username === recipientUsername);\n                if (existingConvIndex >= 0) {\n                    const conversations = [\n                        ...stateAfterSend.conversations\n                    ];\n                    const conv = conversations[existingConvIndex];\n                    const updatedConv = {\n                        ...conv,\n                        last_message_time: sentMessage.created_at,\n                        last_message_preview: messageType === \"image\" ? \"\\uD83D\\uDCF7 Image\" : content\n                    };\n                    conversations[existingConvIndex] = updatedConv;\n                    set({\n                        conversations\n                    });\n                    try {\n                        await get().persistConversation(updatedConv);\n                    } catch (e) {\n                        console.error(\"❌ Failed to persist conversation after send:\", e);\n                    }\n                }\n            } catch (error) {\n                console.error(\"Failed to send message:\", error);\n                // Mark as failed\n                const updatedMessages = new Map(get().messages);\n                const userMessages = updatedMessages.get(recipientUsername) || [];\n                const index = userMessages.findIndex((m)=>m.id === optimisticId);\n                if (index !== -1) {\n                    userMessages[index].status = \"failed\";\n                    updatedMessages.set(recipientUsername, userMessages);\n                    set({\n                        messages: updatedMessages\n                    });\n                }\n                throw error;\n            }\n        },\n        setCurrentConversation: (username)=>{\n            set({\n                currentConversation: username\n            });\n            if (username) {\n                get().loadMessages(username);\n                // Clear typing indicator for this user\n                const state = get();\n                const newTypingUsers = new Map(state.typingUsers);\n                newTypingUsers.delete(username);\n                set({\n                    typingUsers: newTypingUsers\n                });\n            }\n        },\n        addContact: async (username)=>{\n            try {\n                const contact = await _api__WEBPACK_IMPORTED_MODULE_0__.api.addContact(username);\n                const state = get();\n                set({\n                    contacts: [\n                        ...state.contacts,\n                        contact\n                    ]\n                });\n                // Also add to conversations immediately\n                const existingConv = state.conversations.find((c)=>c.username === username);\n                if (!existingConv) {\n                    const newConversation = {\n                        user_id: contact.contact_id,\n                        username: contact.contact_username,\n                        public_key: contact.public_key,\n                        identity_key: contact.identity_key,\n                        last_message_time: undefined,\n                        last_message_preview: undefined,\n                        unread_count: 0,\n                        is_online: false\n                    };\n                    set({\n                        conversations: [\n                            newConversation,\n                            ...state.conversations\n                        ]\n                    });\n                }\n            } catch (error) {\n                console.error(\"Failed to add contact:\", error);\n                throw error;\n            }\n        },\n        searchUsers: async (query)=>{\n            try {\n                return await _api__WEBPACK_IMPORTED_MODULE_0__.api.searchUsers(query);\n            } catch (error) {\n                console.error(\"Failed to search users:\", error);\n                return [];\n            }\n        },\n        addIncomingMessage: (message)=>{\n            const state = get();\n            const senderUsername = message.sender_username;\n            // Check if message already exists\n            const currentMessages = get().messages.get(senderUsername) || [];\n            const exists = currentMessages.some((m)=>m.id === message.id);\n            if (!exists) {\n                // Decrypt immediately if possible\n                // v2 protocol: senderPublicKey is embedded in the message payload\n                const { privateKey, contacts } = get();\n                if (privateKey && message.encrypted_content) {\n                    try {\n                        const encryptedData = JSON.parse(message.encrypted_content);\n                        // Get fallback public key from contacts (for v1 messages)\n                        const contact = contacts.find((c)=>c.contact_username === message.sender_username);\n                        const fallbackPublicKey = (contact === null || contact === void 0 ? void 0 : contact.public_key) || \"\";\n                        // decryptMessage handles v2 (uses embedded senderPublicKey) and v1 (uses fallback)\n                        message._decryptedContent = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.decryptMessage)(encryptedData, fallbackPublicKey, privateKey);\n                        if (message._decryptedContent) {\n                            console.log(\"✅ Successfully decrypted incoming message\");\n                        } else {\n                            console.warn(\"⚠️ Decryption returned null for message:\", message.id);\n                        }\n                    } catch (e) {\n                        console.error(\"❌ Decryption failed for incoming:\", e);\n                    }\n                }\n                const newMessages = new Map(get().messages);\n                newMessages.set(senderUsername, [\n                    ...currentMessages,\n                    message\n                ]);\n                set({\n                    messages: newMessages\n                });\n                // Update conversation list\n                const convIndex = state.conversations.findIndex((c)=>c.username === senderUsername);\n                if (convIndex >= 0) {\n                    const conversations = [\n                        ...state.conversations\n                    ];\n                    const updatedConv = {\n                        ...conversations[convIndex],\n                        last_message_time: message.created_at,\n                        last_message_preview: message._decryptedContent ? message.message_type === \"image\" ? \"\\uD83D\\uDCF7 Image\" : message._decryptedContent : \"[Encrypted Message]\",\n                        unread_count: (conversations[convIndex].unread_count || 0) + 1\n                    };\n                    conversations[convIndex] = updatedConv;\n                    set({\n                        conversations\n                    });\n                    // Persist latest conversation snapshot and message for history\n                    get().persistMessage(message).catch((err)=>console.error(\"❌ Failed to persist incoming message:\", err));\n                    get().persistConversation(updatedConv).catch((err)=>console.error(\"❌ Failed to persist conversation for incoming message:\", err));\n                } else {\n                    // Message from user without an existing conversation entry – create a lightweight one\n                    const newConversation = {\n                        user_id: message.sender_id,\n                        username: senderUsername,\n                        public_key: undefined,\n                        identity_key: undefined,\n                        last_message_time: message.created_at,\n                        last_message_preview: message._decryptedContent ? message.message_type === \"image\" ? \"\\uD83D\\uDCF7 Image\" : message._decryptedContent : \"[Encrypted Message]\",\n                        unread_count: 1,\n                        is_online: false\n                    };\n                    set({\n                        conversations: [\n                            newConversation,\n                            ...state.conversations\n                        ]\n                    });\n                    get().persistMessage(message).catch((err)=>console.error(\"❌ Failed to persist incoming message:\", err));\n                    get().persistConversation(newConversation).catch((err)=>console.error(\"❌ Failed to persist new conversation for incoming message:\", err));\n                }\n            }\n        },\n        loadCallHistory: async ()=>{\n            try {\n                const history = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getCallHistory();\n                set({\n                    callHistory: history\n                });\n            } catch (error) {\n                console.error(\"Failed to load call history:\", error);\n            }\n        },\n        // ============ Presence ============\n        setUserOnline: (userId, isOnline)=>{\n            const state = get();\n            const newOnlineUsers = new Set(state.onlineUsers);\n            if (isOnline) {\n                newOnlineUsers.add(userId);\n            } else {\n                newOnlineUsers.delete(userId);\n            }\n            set({\n                onlineUsers: newOnlineUsers\n            });\n        },\n        setUserTyping: (username, isTyping)=>{\n            const state = get();\n            const newTypingUsers = new Map(state.typingUsers);\n            if (isTyping) {\n                newTypingUsers.set(username, true);\n            } else {\n                newTypingUsers.delete(username);\n            }\n            set({\n                typingUsers: newTypingUsers\n            });\n        },\n        clearError: ()=>set({\n                error: null\n            }),\n        // ============ Deletion Actions ============\n        deleteMessageForMe: async (messageId, conversationUsername)=>{\n            // Delete locally only - does not affect the other user\n            try {\n                // Remove from local state\n                const currentMessages = new Map(get().messages);\n                const convMessages = currentMessages.get(conversationUsername) || [];\n                const updatedMessages = convMessages.filter((m)=>m.id !== messageId);\n                currentMessages.set(conversationUsername, updatedMessages);\n                set({\n                    messages: currentMessages\n                });\n                // Remove from IndexedDB\n                await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.deleteMessage(messageId);\n                console.log(\"\\uD83D\\uDDD1️ Message deleted locally:\", messageId);\n            } catch (error) {\n                console.error(\"Failed to delete message locally:\", error);\n            }\n        },\n        deleteMessageForEveryone: async (messageId, conversationUsername)=>{\n            // Delete for everyone - sends delete event to recipient\n            try {\n                // First mark locally as deleted\n                const currentMessages = new Map(get().messages);\n                const convMessages = currentMessages.get(conversationUsername) || [];\n                const updatedMessages = convMessages.map((m)=>{\n                    if (m.id === messageId) {\n                        return {\n                            ...m,\n                            _decryptedContent: null,\n                            encrypted_content: JSON.stringify({\n                                deleted: true\n                            }),\n                            message_type: \"deleted\"\n                        };\n                    }\n                    return m;\n                });\n                currentMessages.set(conversationUsername, updatedMessages);\n                set({\n                    messages: currentMessages\n                });\n                // Mark as deleted in IndexedDB\n                await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.markMessageAsDeleted(messageId);\n                // Send delete event to recipient via WebSocket\n                _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.sendDeleteMessage(messageId, conversationUsername);\n                // Also try to delete on server\n                try {\n                    await _api__WEBPACK_IMPORTED_MODULE_0__.api.deleteMessage(messageId);\n                } catch (e) {\n                    console.warn(\"Could not delete message on server:\", e);\n                }\n                console.log(\"\\uD83D\\uDDD1️ Message deleted for everyone:\", messageId);\n            } catch (error) {\n                console.error(\"Failed to delete message for everyone:\", error);\n            }\n        },\n        clearChat: async (username)=>{\n            // Clear local chat history only - does not affect the other user\n            try {\n                const { user } = get();\n                if (!user) return;\n                // Clear from local state\n                const currentMessages = new Map(get().messages);\n                currentMessages.set(username, []);\n                set({\n                    messages: currentMessages\n                });\n                // Clear from IndexedDB\n                await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.clearConversationMessages(username, user.username);\n                // Update conversation preview\n                const conversations = [\n                    ...get().conversations\n                ];\n                const convIndex = conversations.findIndex((c)=>c.username === username);\n                if (convIndex >= 0) {\n                    conversations[convIndex] = {\n                        ...conversations[convIndex],\n                        last_message_preview: undefined,\n                        last_message_time: undefined,\n                        unread_count: 0\n                    };\n                    set({\n                        conversations\n                    });\n                }\n                console.log(\"\\uD83E\\uDDF9 Chat cleared locally:\", username);\n            } catch (error) {\n                console.error(\"Failed to clear chat:\", error);\n            }\n        },\n        deleteConversationForEveryone: async (username)=>{\n            // Delete entire conversation for both sides\n            try {\n                const { user } = get();\n                if (!user) return;\n                // Remove from local state\n                const currentMessages = new Map(get().messages);\n                currentMessages.delete(username);\n                set({\n                    messages: currentMessages\n                });\n                // Remove conversation from list\n                const conversations = get().conversations.filter((c)=>c.username !== username);\n                set({\n                    conversations\n                });\n                // Clear current conversation if it was the deleted one\n                if (get().currentConversation === username) {\n                    set({\n                        currentConversation: null\n                    });\n                }\n                // Delete from IndexedDB\n                await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.deleteConversation(username);\n                // Send delete event to recipient via WebSocket\n                _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.sendDeleteConversation(username);\n                // Also try to delete on server\n                try {\n                    await _api__WEBPACK_IMPORTED_MODULE_0__.api.deleteConversation(username);\n                } catch (e) {\n                    console.warn(\"Could not delete conversation on server:\", e);\n                }\n                console.log(\"\\uD83D\\uDDD1️ Conversation deleted for everyone:\", username);\n            } catch (error) {\n                console.error(\"Failed to delete conversation for everyone:\", error);\n            }\n        },\n        handleRemoteDeleteMessage: (messageId, senderUsername)=>{\n            // Handle incoming delete message event from another user\n            const currentMessages = new Map(get().messages);\n            const convMessages = currentMessages.get(senderUsername) || [];\n            const updatedMessages = convMessages.map((m)=>{\n                if (m.id === messageId) {\n                    return {\n                        ...m,\n                        _decryptedContent: null,\n                        encrypted_content: JSON.stringify({\n                            deleted: true\n                        }),\n                        message_type: \"deleted\"\n                    };\n                }\n                return m;\n            });\n            currentMessages.set(senderUsername, updatedMessages);\n            set({\n                messages: currentMessages\n            });\n            // Update IndexedDB\n            _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.markMessageAsDeleted(messageId).catch(console.error);\n            console.log(\"\\uD83D\\uDCE8 Remote message deletion received:\", messageId);\n        },\n        handleRemoteDeleteConversation: (senderUsername)=>{\n            // Handle incoming delete conversation event from another user\n            const currentMessages = new Map(get().messages);\n            currentMessages.delete(senderUsername);\n            set({\n                messages: currentMessages\n            });\n            // Remove conversation from list\n            const conversations = get().conversations.filter((c)=>c.username !== senderUsername);\n            set({\n                conversations\n            });\n            // Clear current conversation if it was the deleted one\n            if (get().currentConversation === senderUsername) {\n                set({\n                    currentConversation: null\n                });\n            }\n            // Delete from IndexedDB\n            _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.deleteConversation(senderUsername).catch(console.error);\n            console.log(\"\\uD83D\\uDCE8 Remote conversation deletion received:\", senderUsername);\n        },\n        // ============ Persistent Storage ============\n        loadPersistedData: async ()=>{\n            try {\n                console.log(\"\\uD83D\\uDCC2 Loading persisted data from IndexedDB...\");\n                // Load conversations\n                const storedConversations = await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.getAllConversations();\n                if (storedConversations.length > 0) {\n                    const conversations = storedConversations.map((conv)=>({\n                            user_id: conv.user_id,\n                            username: conv.username,\n                            public_key: conv.public_key,\n                            identity_key: conv.identity_key,\n                            last_message_time: conv.last_message_time,\n                            last_message_preview: conv.last_message_preview,\n                            unread_count: conv.unread_count,\n                            is_online: conv.is_online\n                        }));\n                    set({\n                        conversations\n                    });\n                    console.log(\"\\uD83D\\uDCC2 Loaded \".concat(conversations.length, \" conversations from storage\"));\n                }\n                // Load contacts\n                const storedContacts = await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.getAllContacts();\n                if (storedContacts.length > 0) {\n                    const contacts = storedContacts.map((contact)=>({\n                            id: contact.id,\n                            user_id: contact.user_id,\n                            contact_id: contact.contact_id,\n                            contact_username: contact.contact_username,\n                            contact_email: contact.contact_email,\n                            public_key: contact.public_key,\n                            identity_key: contact.identity_key,\n                            nickname: contact.nickname,\n                            is_blocked: contact.is_blocked,\n                            is_verified: contact.is_verified,\n                            added_at: contact.added_at\n                        }));\n                    set({\n                        contacts\n                    });\n                    console.log(\"\\uD83D\\uDCC2 Loaded \".concat(contacts.length, \" contacts from storage\"));\n                }\n                // Load messages for all conversations\n                const { user } = get();\n                if (user) {\n                    const messagesMap = new Map();\n                    for (const conv of storedConversations){\n                        const storedMessages = await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.getConversationMessages(conv.username, user.username, 50);\n                        if (storedMessages.length > 0) {\n                            const messages = storedMessages.map((msg)=>({\n                                    id: msg.id,\n                                    sender_id: msg.sender_id,\n                                    sender_username: msg.sender_username,\n                                    recipient_id: msg.recipient_id,\n                                    recipient_username: msg.recipient_username,\n                                    encrypted_content: msg.encrypted_content,\n                                    encrypted_key: msg.encrypted_key,\n                                    message_type: msg.message_type,\n                                    status: msg.status,\n                                    created_at: msg.created_at,\n                                    delivered_at: msg.delivered_at,\n                                    read_at: msg.read_at,\n                                    expiry_type: msg.expiry_type,\n                                    expires_at: msg.expires_at,\n                                    file_metadata: msg.file_metadata\n                                }));\n                            messagesMap.set(conv.username, messages);\n                        }\n                    }\n                    set({\n                        messages: messagesMap\n                    });\n                    console.log(\"\\uD83D\\uDCC2 Loaded messages for \".concat(messagesMap.size, \" conversations\"));\n                }\n            } catch (error) {\n                console.error(\"❌ Failed to load persisted data:\", error);\n            }\n        },\n        syncWithServer: async ()=>{\n            try {\n                console.log(\"\\uD83D\\uDD04 Syncing with server...\");\n                // Load fresh data from server\n                await get().loadContacts();\n                await get().loadConversations();\n                // Get all conversations with messages from server\n                const allConversationsData = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getAllConversationsWithMessages();\n                // Update local storage with server data\n                const { user, contacts, conversations } = get();\n                if (user) {\n                    // Save conversations to IndexedDB\n                    const storedConversations = conversations.map((conv)=>({\n                            username: conv.username,\n                            user_id: conv.user_id,\n                            public_key: conv.public_key,\n                            identity_key: conv.identity_key,\n                            last_message_time: conv.last_message_time,\n                            last_message_preview: conv.last_message_preview,\n                            unread_count: conv.unread_count,\n                            is_online: conv.is_online\n                        }));\n                    await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.saveConversations(storedConversations);\n                    // Save contacts to IndexedDB\n                    const storedContacts = contacts.map((contact)=>({\n                            id: contact.id,\n                            user_id: contact.user_id,\n                            contact_id: contact.contact_id,\n                            contact_username: contact.contact_username,\n                            contact_email: contact.contact_email,\n                            public_key: contact.public_key,\n                            identity_key: contact.identity_key,\n                            nickname: contact.nickname,\n                            is_blocked: contact.is_blocked,\n                            is_verified: contact.is_verified,\n                            added_at: contact.added_at\n                        }));\n                    await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.saveContacts(storedContacts);\n                    // Save messages to IndexedDB\n                    for (const [username, messages] of Object.entries(allConversationsData)){\n                        const storedMessages = messages.map((msg)=>({\n                                id: msg.id,\n                                sender_id: msg.sender_id,\n                                sender_username: msg.sender_username,\n                                recipient_id: msg.recipient_id,\n                                recipient_username: msg.recipient_username,\n                                encrypted_content: msg.encrypted_content,\n                                encrypted_key: msg.encrypted_key,\n                                message_type: msg.message_type,\n                                status: msg.status,\n                                created_at: msg.created_at,\n                                delivered_at: msg.delivered_at,\n                                read_at: msg.read_at,\n                                expiry_type: msg.expiry_type,\n                                expires_at: msg.expires_at,\n                                file_metadata: msg.file_metadata\n                            }));\n                        await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.saveMessages(storedMessages);\n                    }\n                    // Update in-memory state\n                    const messagesMap = new Map();\n                    for (const [username, messages] of Object.entries(allConversationsData)){\n                        messagesMap.set(username, messages);\n                    }\n                    set({\n                        messages: messagesMap\n                    });\n                    console.log(\"✅ Sync completed successfully\");\n                }\n            } catch (error) {\n                console.error(\"❌ Sync failed:\", error);\n            }\n        },\n        persistMessage: async (message)=>{\n            try {\n                const storedMessage = {\n                    id: message.id,\n                    sender_id: message.sender_id,\n                    sender_username: message.sender_username,\n                    recipient_id: message.recipient_id,\n                    recipient_username: message.recipient_username,\n                    encrypted_content: message.encrypted_content,\n                    encrypted_key: message.encrypted_key,\n                    message_type: message.message_type,\n                    status: message.status,\n                    created_at: message.created_at,\n                    delivered_at: message.delivered_at,\n                    read_at: message.read_at,\n                    expiry_type: message.expiry_type,\n                    expires_at: message.expires_at,\n                    file_metadata: message.file_metadata\n                };\n                await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.saveMessage(storedMessage);\n            } catch (error) {\n                console.error(\"❌ Failed to persist message:\", error);\n            }\n        },\n        persistConversation: async (conversation)=>{\n            try {\n                const storedConversation = {\n                    username: conversation.username,\n                    user_id: conversation.user_id,\n                    public_key: conversation.public_key,\n                    identity_key: conversation.identity_key,\n                    last_message_time: conversation.last_message_time,\n                    last_message_preview: conversation.last_message_preview,\n                    unread_count: conversation.unread_count,\n                    is_online: conversation.is_online\n                };\n                await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.saveConversation(storedConversation);\n            } catch (error) {\n                console.error(\"❌ Failed to persist conversation:\", error);\n            }\n        },\n        loadAllConversationHistory: async ()=>{\n            try {\n                const { conversations } = get();\n                console.log(\"\\uD83D\\uDCDA Loading history for \".concat(conversations.length, \" conversations...\"));\n                for (const conv of conversations){\n                    await get().loadMessages(conv.username);\n                    // Small delay to prevent overwhelming the server\n                    await new Promise((resolve)=>setTimeout(resolve, 100));\n                }\n                console.log(\"✅ All conversation history loaded\");\n            } catch (error) {\n                console.error(\"❌ Failed to load conversation history:\", error);\n            }\n        }\n    }), {\n    name: \"cipherlink-store\",\n    partialize: (state)=>({\n            // Only persist non-sensitive data\n            currentConversation: state.currentConversation\n        })\n}));\n// Setup WebSocket message handlers\nfunction setupWebSocketHandlers(get, set) {\n    // Handle incoming messages\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"message\", (data)=>{\n        var _state_user, _state_user1;\n        console.log(\"\\uD83D\\uDCE8 Received message:\", data);\n        const state = get();\n        const senderUsername = data.sender_username;\n        // Create message object\n        const message = {\n            id: data.message_id,\n            sender_id: data.sender_id,\n            sender_username: senderUsername,\n            recipient_id: ((_state_user = state.user) === null || _state_user === void 0 ? void 0 : _state_user.id) || 0,\n            recipient_username: ((_state_user1 = state.user) === null || _state_user1 === void 0 ? void 0 : _state_user1.username) || \"\",\n            encrypted_content: data.content || data.encrypted_content,\n            encrypted_key: data.encrypted_key,\n            message_type: data.message_type || \"text\",\n            status: \"delivered\",\n            expiry_type: data.expiry_type || \"none\",\n            created_at: data.timestamp\n        };\n        get().addIncomingMessage(message);\n        // Send delivery receipt\n        _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.sendDeliveryReceipt(data.message_id, data.sender_id);\n    });\n    // Handle typing indicators\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"typing\", (data)=>{\n        get().setUserTyping(data.sender_username, data.is_typing);\n        // Auto-clear typing after 3 seconds\n        if (data.is_typing) {\n            setTimeout(()=>{\n                get().setUserTyping(data.sender_username, false);\n            }, 3000);\n        }\n    });\n    // Handle presence updates\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"presence\", (data)=>{\n        get().setUserOnline(data.user_id, data.is_online);\n    });\n    // Handle message sent confirmations\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"message_sent\", (data)=>{\n        console.log(\"✅ Message sent confirmation:\", data);\n    });\n    // Handle read receipts\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"read_receipt\", (data)=>{\n        console.log(\"\\uD83D\\uDC41️ Read receipt:\", data);\n    // Could update message status in UI here\n    });\n    // Handle delivery receipts\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"delivery_receipt\", (data)=>{\n        console.log(\"\\uD83D\\uDCEC Delivery receipt:\", data);\n    // Could update message status in UI here\n    });\n    // Handle connection confirmation\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"connected\", (data)=>{\n        console.log(\"✅ WebSocket connected:\", data);\n    });\n    // Handle errors\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"error\", (data)=>{\n        console.error(\"❌ WebSocket error:\", data);\n    });\n    // Handle remote message deletion\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"delete_message_received\", (data)=>{\n        var _data_data, _data_data1;\n        console.log(\"\\uD83D\\uDDD1️ Remote delete message received:\", data);\n        const messageId = data.message_id || ((_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.message_id);\n        const senderUsername = data.sender_username || ((_data_data1 = data.data) === null || _data_data1 === void 0 ? void 0 : _data_data1.sender_username);\n        if (messageId && senderUsername) {\n            get().handleRemoteDeleteMessage(messageId, senderUsername);\n        }\n    });\n    // Handle remote conversation deletion\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"delete_conversation_received\", (data)=>{\n        var _data_data;\n        console.log(\"\\uD83D\\uDDD1️ Remote delete conversation received:\", data);\n        const senderUsername = data.sender_username || ((_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.sender_username);\n        if (senderUsername) {\n            get().handleRemoteDeleteConversation(senderUsername);\n        }\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RCxlQUFlLE1BQUlqRCxhQUFBQSxLQUFLQSxJQUFJLGNBQVRBLGlDQUFBQSxXQUFXaUQsZUFBZTtRQUN6RSxJQUFJbUUsZ0JBQWdCO1lBQ2xCNUssTUFBTTZNLDhCQUE4QixDQUFDakM7UUFDdkM7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvc3RvcmUudHM/YWQzMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ2lwaGVyTGluayBHbG9iYWwgU3RhdGUgU3RvcmVcclxuICogVXNlcyBadXN0YW5kIGZvciBzdGF0ZSBtYW5hZ2VtZW50XHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCc7XHJcbmltcG9ydCB7IHBlcnNpc3QgfSBmcm9tICd6dXN0YW5kL21pZGRsZXdhcmUnO1xyXG5pbXBvcnQgeyBhcGksIFVzZXIsIENvbnRhY3QsIENvbnZlcnNhdGlvbiwgTWVzc2FnZSwgQ2FsbExvZyB9IGZyb20gJy4vYXBpJztcclxuaW1wb3J0IHtcclxuICBnZW5lcmF0ZUtleVBhaXIsXHJcbiAgZ2VuZXJhdGVTaWduaW5nS2V5UGFpcixcclxuICBnZW5lcmF0ZUtleUJ1bmRsZSxcclxuICBLZXlTdG9yYWdlLFxyXG4gIGVuY3J5cHRNZXNzYWdlLFxyXG4gIGRlY3J5cHRNZXNzYWdlLFxyXG4gIEVuY3J5cHRlZE1lc3NhZ2UsXHJcbiAgdmVyaWZ5S2V5UGFpcixcclxuICBkZXJpdmVQdWJsaWNLZXlGcm9tUHJpdmF0ZVxyXG59IGZyb20gJy4vY3J5cHRvJztcclxuaW1wb3J0IHsgd3NNYW5hZ2VyIH0gZnJvbSAnLi93ZWJzb2NrZXQnO1xyXG5pbXBvcnQgeyBsb2NhbFN0b3JhZ2VNYW5hZ2VyLCBTdG9yZWRNZXNzYWdlLCBTdG9yZWRDb252ZXJzYXRpb24sIFN0b3JlZENvbnRhY3QgfSBmcm9tICcuL3N0b3JhZ2UnO1xyXG5pbXBvcnQgeyBidWlsZE1lc3NhZ2VUaGVtZSB9IGZyb20gJy4vdGhlbWVTeW5jJztcclxuXHJcbmludGVyZmFjZSBBdXRoU3RhdGUge1xyXG4gIHVzZXI6IFVzZXIgfCBudWxsO1xyXG4gIHRva2VuOiBzdHJpbmcgfCBudWxsO1xyXG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcclxuICBpc0xvYWRpbmc6IGJvb2xlYW47XHJcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XHJcbn1cclxuXHJcbmludGVyZmFjZSBDcnlwdG9TdGF0ZSB7XHJcbiAgcHJpdmF0ZUtleTogc3RyaW5nIHwgbnVsbDtcclxuICBwdWJsaWNLZXk6IHN0cmluZyB8IG51bGw7XHJcbiAgaWRlbnRpdHlLZXk6IHN0cmluZyB8IG51bGw7XHJcbiAgaWRlbnRpdHlQcml2YXRlS2V5OiBzdHJpbmcgfCBudWxsO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQ2hhdFN0YXRlIHtcclxuICBjb250YWN0czogQ29udGFjdFtdO1xyXG4gIGNvbnZlcnNhdGlvbnM6IENvbnZlcnNhdGlvbltdO1xyXG4gIGN1cnJlbnRDb252ZXJzYXRpb246IHN0cmluZyB8IG51bGw7IC8vIHVzZXJuYW1lXHJcbiAgbWVzc2FnZXM6IE1hcDxzdHJpbmcsIE1lc3NhZ2VbXT47IC8vIHVzZXJuYW1lIC0+IG1lc3NhZ2VzXHJcbiAgb25saW5lVXNlcnM6IFNldDxudW1iZXI+O1xyXG4gIHR5cGluZ1VzZXJzOiBNYXA8c3RyaW5nLCBib29sZWFuPjsgLy8gdXNlcm5hbWUgLT4gaXNUeXBpbmdcclxuICBjYWxsSGlzdG9yeTogQ2FsbExvZ1tdO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQXBwU3RhdGUgZXh0ZW5kcyBBdXRoU3RhdGUsIENyeXB0b1N0YXRlLCBDaGF0U3RhdGUge1xyXG4gIC8vIEF1dGggYWN0aW9uc1xyXG4gIGxvZ2luOiAodXNlcm5hbWU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxuICByZWdpc3RlcjogKHVzZXJuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XHJcbiAgbG9nb3V0OiAoKSA9PiB2b2lkO1xyXG4gIGxvYWRTdG9yZWRBdXRoOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAvLyBDcnlwdG8gYWN0aW9uc1xyXG4gIGdlbmVyYXRlQW5kVXBsb2FkS2V5czogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBsb2FkU3RvcmVkS2V5czogKCkgPT4gdm9pZDtcclxuXHJcbiAgLy8gQ2hhdCBhY3Rpb25zXHJcbiAgbG9hZENvbnRhY3RzOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGxvYWRDb252ZXJzYXRpb25zOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGxvYWRNZXNzYWdlczogKHVzZXJuYW1lOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XHJcbiAgbG9hZEFsbENvbnZlcnNhdGlvbkhpc3Rvcnk6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbiAgc3luY1dpdGhTZXJ2ZXI6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbiAgcGVyc2lzdE1lc3NhZ2U6IChtZXNzYWdlOiBNZXNzYWdlKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIHBlcnNpc3RDb252ZXJzYXRpb246IChjb252ZXJzYXRpb246IENvbnZlcnNhdGlvbikgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBsb2FkUGVyc2lzdGVkRGF0YTogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBzZW5kTWVzc2FnZTogKHJlY2lwaWVudFVzZXJuYW1lOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZywgbWVzc2FnZVR5cGU/OiBzdHJpbmcsIGZpbGVEYXRhPzogYW55KSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIHNldEN1cnJlbnRDb252ZXJzYXRpb246ICh1c2VybmFtZTogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcclxuICBhZGRDb250YWN0OiAodXNlcm5hbWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBzZWFyY2hVc2VyczogKHF1ZXJ5OiBzdHJpbmcpID0+IFByb21pc2U8QXJyYXk8eyBpZDogbnVtYmVyOyB1c2VybmFtZTogc3RyaW5nIH0+PjtcclxuICBhZGRJbmNvbWluZ01lc3NhZ2U6IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB2b2lkO1xyXG4gIGxvYWRDYWxsSGlzdG9yeTogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgLy8gRGVsZXRpb24gYWN0aW9uc1xyXG4gIGRlbGV0ZU1lc3NhZ2VGb3JNZTogKG1lc3NhZ2VJZDogbnVtYmVyLCBjb252ZXJzYXRpb25Vc2VybmFtZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGRlbGV0ZU1lc3NhZ2VGb3JFdmVyeW9uZTogKG1lc3NhZ2VJZDogbnVtYmVyLCBjb252ZXJzYXRpb25Vc2VybmFtZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGNsZWFyQ2hhdDogKHVzZXJuYW1lOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XHJcbiAgZGVsZXRlQ29udmVyc2F0aW9uRm9yRXZlcnlvbmU6ICh1c2VybmFtZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGhhbmRsZVJlbW90ZURlbGV0ZU1lc3NhZ2U6IChtZXNzYWdlSWQ6IG51bWJlciwgc2VuZGVyVXNlcm5hbWU6IHN0cmluZykgPT4gdm9pZDtcclxuICBoYW5kbGVSZW1vdGVEZWxldGVDb252ZXJzYXRpb246IChzZW5kZXJVc2VybmFtZTogc3RyaW5nKSA9PiB2b2lkO1xyXG5cclxuICAvLyBQcmVzZW5jZVxyXG4gIHNldFVzZXJPbmxpbmU6ICh1c2VySWQ6IG51bWJlciwgaXNPbmxpbmU6IGJvb2xlYW4pID0+IHZvaWQ7XHJcbiAgc2V0VXNlclR5cGluZzogKHVzZXJuYW1lOiBzdHJpbmcsIGlzVHlwaW5nOiBib29sZWFuKSA9PiB2b2lkO1xyXG5cclxuICAvLyBDbGVhciBzdGF0ZVxyXG4gIGNsZWFyRXJyb3I6ICgpID0+IHZvaWQ7XHJcbiAgaW5pdGlhbGl6ZVdlYlNvY2tldDogKCkgPT4gdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHVzZVN0b3JlID0gY3JlYXRlPEFwcFN0YXRlPigpKFxyXG4gIHBlcnNpc3QoXHJcbiAgICAoc2V0LCBnZXQpID0+ICh7XHJcbiAgICAgIC8vIEluaXRpYWwgc3RhdGVcclxuICAgICAgdXNlcjogbnVsbCxcclxuICAgICAgdG9rZW46IG51bGwsXHJcbiAgICAgIGlzQXV0aGVudGljYXRlZDogZmFsc2UsXHJcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgICBwcml2YXRlS2V5OiBudWxsLFxyXG4gICAgICBwdWJsaWNLZXk6IG51bGwsXHJcbiAgICAgIGlkZW50aXR5S2V5OiBudWxsLFxyXG4gICAgICBpZGVudGl0eVByaXZhdGVLZXk6IG51bGwsXHJcbiAgICAgIGNvbnRhY3RzOiBbXSxcclxuICAgICAgY29udmVyc2F0aW9uczogW10sXHJcbiAgICAgIGN1cnJlbnRDb252ZXJzYXRpb246IG51bGwsXHJcbiAgICAgIG1lc3NhZ2VzOiBuZXcgTWFwKCksXHJcbiAgICAgIG9ubGluZVVzZXJzOiBuZXcgU2V0KCksXHJcbiAgICAgIHR5cGluZ1VzZXJzOiBuZXcgTWFwKCksXHJcbiAgICAgIGNhbGxIaXN0b3J5OiBbXSxcclxuXHJcbiAgICAgIC8vID09PT09PT09PT09PSBBdXRoIEFjdGlvbnMgPT09PT09PT09PT09XHJcblxyXG4gICAgICBsb2dpbjogYXN5bmMgKHVzZXJuYW1lOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBzZXQoeyBpc0xvYWRpbmc6IHRydWUsIGVycm9yOiBudWxsIH0pO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5sb2dpbih1c2VybmFtZSwgcGFzc3dvcmQpO1xyXG4gICAgICAgICAgbGV0IHVzZXIgPSBhd2FpdCBhcGkuZ2V0Q3VycmVudFVzZXIoKTtcclxuXHJcbiAgICAgICAgICAvLyBTdG9yZSB0b2tlblxyXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NpcGhlcmxpbmtfdG9rZW4nLCByZXNwb25zZS5hY2Nlc3NfdG9rZW4pO1xyXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NpcGhlcmxpbmtfdXNlcm5hbWUnLCB1c2VybmFtZSk7XHJcblxyXG4gICAgICAgICAgLy8gTG9hZCBvciBnZW5lcmF0ZSBrZXlzXHJcbiAgICAgICAgICBsZXQga2V5cyA9IEtleVN0b3JhZ2UubG9hZCh1c2VybmFtZSk7XHJcbiAgICAgICAgICBsZXQgbmVlZHNVcGxvYWQgPSAhdXNlci5wdWJsaWNfa2V5O1xyXG4gICAgICAgICAgbGV0IGtleU1pc21hdGNoID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgLy8gVmVyaWZ5IGtleSBjb25zaXN0ZW5jeSBpZiBib3RoIGxvY2FsIGFuZCBzZXJ2ZXIga2V5cyBleGlzdFxyXG4gICAgICAgICAgaWYgKGtleXMgJiYgdXNlci5wdWJsaWNfa2V5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzQ29uc2lzdGVudCA9IEtleVN0b3JhZ2UudmVyaWZ5S2V5Q29uc2lzdGVuY3kodXNlcm5hbWUsIHVzZXIucHVibGljX2tleSk7XHJcbiAgICAgICAgICAgIGlmICghaXNDb25zaXN0ZW50KSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gS2V5IG1pc21hdGNoIGRldGVjdGVkISBMb2NhbCBrZXkgZGlmZmVycyBmcm9tIHNlcnZlciBrZXkuJyk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGlzIG1heSBoYXBwZW4gaWYgeW91IGxvZ2dlZCBpbiBmcm9tIGEgZGlmZmVyZW50IGRldmljZS4nKTtcclxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ09sZCBtZXNzYWdlcyBlbmNyeXB0ZWQgd2l0aCB0aGUgc2VydmVyIGtleSBtYXkgbm90IGRlY3J5cHQgY29ycmVjdGx5LicpO1xyXG4gICAgICAgICAgICAgIGtleU1pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAvLyBLZWVwIGxvY2FsIGtleXMgYnV0IG1hcmsgdGhlIG1pc21hdGNoXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoIWtleXMpIHtcclxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgbmV3IHByb3BlciBrZXkgYnVuZGxlXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SQIEdlbmVyYXRpbmcgbmV3IGtleSBidW5kbGUuLi4nKTtcclxuICAgICAgICAgICAgY29uc3QgeyBidW5kbGUsIHByaXZhdGVLZXlzIH0gPSBnZW5lcmF0ZUtleUJ1bmRsZSg1KTtcclxuXHJcbiAgICAgICAgICAgIGtleXMgPSB7XHJcbiAgICAgICAgICAgICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleXMuc2lnbmVkUHJla2V5UHJpdmF0ZSwgLy8gVXNlIHNpZ25lZCBwcmVrZXkgcHJpdmF0ZSBmb3IgZW5jcnlwdGlvblxyXG4gICAgICAgICAgICAgIHB1YmxpY0tleTogYnVuZGxlLnB1YmxpY0tleSxcclxuICAgICAgICAgICAgICBpZGVudGl0eUtleTogYnVuZGxlLmlkZW50aXR5S2V5LFxyXG4gICAgICAgICAgICAgIHNpZ25lZFByZWtleTogYnVuZGxlLnNpZ25lZFByZWtleSxcclxuICAgICAgICAgICAgICBzaWduZWRQcmVrZXlTaWduYXR1cmU6IGJ1bmRsZS5zaWduZWRQcmVrZXlTaWduYXR1cmUsXHJcbiAgICAgICAgICAgICAgaWRlbnRpdHlQcml2YXRlS2V5OiBwcml2YXRlS2V5cy5pZGVudGl0eVByaXZhdGUsXHJcbiAgICAgICAgICAgICAgb25lVGltZVByZWtleXM6IGJ1bmRsZS5vbmVUaW1lUHJla2V5cyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgS2V5U3RvcmFnZS5zYXZlKHVzZXJuYW1lLCBrZXlzKTtcclxuICAgICAgICAgICAgbmVlZHNVcGxvYWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIEtleSBidW5kbGUgZ2VuZXJhdGVkJyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ1JJVElDQUw6IFZlcmlmeSB0aGF0IHByaXZhdGVLZXkgYW5kIHB1YmxpY0tleSBmb3JtIGEgdmFsaWQgcGFpclxyXG4gICAgICAgICAgaWYgKGtleXMucHJpdmF0ZUtleSAmJiBrZXlzLnB1YmxpY0tleSkge1xyXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkUGFpciA9IHZlcmlmeUtleVBhaXIoa2V5cy5wcml2YXRlS2V5LCBrZXlzLnB1YmxpY0tleSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SRIEtleSBwYWlyIHZlcmlmaWNhdGlvbjonLCBpc1ZhbGlkUGFpciA/ICfinIUgVkFMSUQnIDogJ+KdjCBJTlZBTElEJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRQYWlyKSB7XHJcbiAgICAgICAgICAgICAgLy8gVGhlIHN0b3JlZCBwdWJsaWMga2V5IGRvZXNuJ3QgbWF0Y2ggdGhlIHByaXZhdGUga2V5IVxyXG4gICAgICAgICAgICAgIC8vIERlcml2ZSB0aGUgY29ycmVjdCBwdWJsaWMga2V5IGZyb20gdGhlIHByaXZhdGUga2V5XHJcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gS2V5IHBhaXIgbWlzbWF0Y2ggZGV0ZWN0ZWQhIERlcml2aW5nIGNvcnJlY3QgcHVibGljIGtleS4uLicpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGNvcnJlY3RQdWJsaWNLZXkgPSBkZXJpdmVQdWJsaWNLZXlGcm9tUHJpdmF0ZShrZXlzLnByaXZhdGVLZXkpO1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SnIE9yaWdpbmFsIHB1YmxpY0tleTonLCBrZXlzLnB1YmxpY0tleT8uc3Vic3RyaW5nKDAsIDMwKSk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflKcgRGVyaXZlZCBwdWJsaWNLZXk6JywgY29ycmVjdFB1YmxpY0tleT8uc3Vic3RyaW5nKDAsIDMwKSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUga2V5cyB3aXRoIHRoZSBjb3JyZWN0IHB1YmxpYyBrZXlcclxuICAgICAgICAgICAgICBrZXlzLnB1YmxpY0tleSA9IGNvcnJlY3RQdWJsaWNLZXk7XHJcbiAgICAgICAgICAgICAgS2V5U3RvcmFnZS5zYXZlKHVzZXJuYW1lLCBrZXlzKTtcclxuICAgICAgICAgICAgICBuZWVkc1VwbG9hZCA9IHRydWU7IC8vIE5lZWQgdG8gdXBsb2FkIHRoZSBjb3JyZWN0ZWQga2V5XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBLZXkgcGFpciBjb3JyZWN0ZWQgYW5kIHNhdmVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBVcGxvYWQga2V5cyBpZiBub3Qgb24gc2VydmVyIE9SIGlmIHdlIGNvcnJlY3RlZCB0aGUga2V5IHBhaXJcclxuICAgICAgICAgIGlmIChuZWVkc1VwbG9hZCAmJiBrZXlzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OkIFVwbG9hZGluZyBrZXlzIHRvIHNlcnZlci4uLicsIHtcclxuICAgICAgICAgICAgICBwdWJsaWNLZXlUb1VwbG9hZDoga2V5cy5wdWJsaWNLZXk/LnN1YnN0cmluZygwLCAzMCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGF3YWl0IGFwaS51cGxvYWRLZXlzKHtcclxuICAgICAgICAgICAgICAgIHB1YmxpY19rZXk6IGtleXMucHVibGljS2V5IHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgaWRlbnRpdHlfa2V5OiBrZXlzLmlkZW50aXR5S2V5IHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgc2lnbmVkX3ByZWtleToga2V5cy5zaWduZWRQcmVrZXkgfHwga2V5cy5wdWJsaWNLZXkgfHwgJycsXHJcbiAgICAgICAgICAgICAgICBzaWduZWRfcHJla2V5X3NpZ25hdHVyZToga2V5cy5zaWduZWRQcmVrZXlTaWduYXR1cmUgfHwgJycsXHJcbiAgICAgICAgICAgICAgICBvbmVfdGltZV9wcmVrZXlzOiBrZXlzLm9uZVRpbWVQcmVrZXlzIHx8IFtdLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIC8vIFJlZnJlc2ggdXNlciB0byBnZXQgdXBkYXRlZCBwdWJsaWNfa2V5XHJcbiAgICAgICAgICAgICAgdXNlciA9IGF3YWl0IGFwaS5nZXRDdXJyZW50VXNlcigpO1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgS2V5cyB1cGxvYWRlZCBzdWNjZXNzZnVsbHkhJywge1xyXG4gICAgICAgICAgICAgICAgc2VydmVyTm93SGFzOiB1c2VyLnB1YmxpY19rZXk/LnN1YnN0cmluZygwLCAzMCksXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKHVwbG9hZEVycm9yOiBhbnkpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIHVwbG9hZCBrZXlzOicsIHVwbG9hZEVycm9yPy5yZXNwb25zZT8uZGF0YSB8fCB1cGxvYWRFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGaW5hbCB2ZXJpZmljYXRpb246IGVuc3VyZSBsb2NhbCBrZXkgbWF0Y2hlcyBzZXJ2ZXIga2V5XHJcbiAgICAgICAgICBjb25zdCBsb2NhbFNlcnZlck1hdGNoID0ga2V5cz8ucHVibGljS2V5ID09PSB1c2VyLnB1YmxpY19rZXk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UkCBGaW5hbCBLZXkgU3RhdHVzOicsIHtcclxuICAgICAgICAgICAgdXNlcm5hbWUsXHJcbiAgICAgICAgICAgIGxvY2FsUHViS2V5OiBrZXlzPy5wdWJsaWNLZXk/LnN1YnN0cmluZygwLCAzMCksXHJcbiAgICAgICAgICAgIHNlcnZlclB1YktleTogdXNlci5wdWJsaWNfa2V5Py5zdWJzdHJpbmcoMCwgMzApLFxyXG4gICAgICAgICAgICBsb2NhbFByaXZLZXk6IGtleXM/LnByaXZhdGVLZXk/LnN1YnN0cmluZygwLCAzMCksXHJcbiAgICAgICAgICAgIExPQ0FMX01BVENIRVNfU0VSVkVSOiBsb2NhbFNlcnZlck1hdGNoID8gJ+KchSBZRVMnIDogJ+KdjCBOTycsXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBpZiAoIWxvY2FsU2VydmVyTWF0Y2ggJiYga2V5cz8ucHVibGljS2V5ICYmIHVzZXIucHVibGljX2tleSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCfwn5qoIENSSVRJQ0FMOiBMb2NhbCBwdWJsaWMga2V5IGRvZXMgbm90IG1hdGNoIHNlcnZlciEgVGhpcyB3aWxsIGNhdXNlIGRlY3J5cHRpb24gZmFpbHVyZXMuJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SnIEF0dGVtcHRpbmcgdG8gZm9yY2UgdXBsb2FkIGNvcnJlY3Qga2V5Li4uJyk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgYXdhaXQgYXBpLnVwbG9hZEtleXMoe1xyXG4gICAgICAgICAgICAgICAgcHVibGljX2tleToga2V5cy5wdWJsaWNLZXkgfHwgJycsXHJcbiAgICAgICAgICAgICAgICBpZGVudGl0eV9rZXk6IGtleXMuaWRlbnRpdHlLZXkgfHwgJycsXHJcbiAgICAgICAgICAgICAgICBzaWduZWRfcHJla2V5OiBrZXlzLnNpZ25lZFByZWtleSB8fCBrZXlzLnB1YmxpY0tleSB8fCAnJyxcclxuICAgICAgICAgICAgICAgIHNpZ25lZF9wcmVrZXlfc2lnbmF0dXJlOiBrZXlzLnNpZ25lZFByZWtleVNpZ25hdHVyZSB8fCAnJyxcclxuICAgICAgICAgICAgICAgIG9uZV90aW1lX3ByZWtleXM6IGtleXMub25lVGltZVByZWtleXMgfHwgW10sXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgdXNlciA9IGF3YWl0IGFwaS5nZXRDdXJyZW50VXNlcigpO1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgRm9yY2UgdXBsb2FkIGNvbXBsZXRlLCBzZXJ2ZXIgbm93IGhhczonLCB1c2VyLnB1YmxpY19rZXk/LnN1YnN0cmluZygwLCAzMCkpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZvcmNlIHVwbG9hZCBmYWlsZWQ6JywgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzZXQoe1xyXG4gICAgICAgICAgICB1c2VyLFxyXG4gICAgICAgICAgICB0b2tlbjogcmVzcG9uc2UuYWNjZXNzX3Rva2VuLFxyXG4gICAgICAgICAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IGtleXMucHJpdmF0ZUtleSB8fCBudWxsLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IGtleXMucHVibGljS2V5IHx8IG51bGwsXHJcbiAgICAgICAgICAgIGlkZW50aXR5S2V5OiBrZXlzLmlkZW50aXR5S2V5IHx8IG51bGwsXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAvLyBDb25uZWN0IFdlYlNvY2tldFxyXG4gICAgICAgICAgd3NNYW5hZ2VyLmNvbm5lY3QodXNlci5pZC50b1N0cmluZygpLCByZXNwb25zZS5hY2Nlc3NfdG9rZW4pO1xyXG5cclxuICAgICAgICAgIC8vIFNldHVwIG1lc3NhZ2UgaGFuZGxlcnNcclxuICAgICAgICAgIGlmICghKHdpbmRvdyBhcyBhbnkpLl93c0hhbmRsZXJzUmVnaXN0ZXJlZCkge1xyXG4gICAgICAgICAgICBzZXR1cFdlYlNvY2tldEhhbmRsZXJzKGdldCwgc2V0KTtcclxuICAgICAgICAgICAgKHdpbmRvdyBhcyBhbnkpLl93c0hhbmRsZXJzUmVnaXN0ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgICAgIHNldCh7XHJcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgIGVycm9yOiBlcnJvci5yZXNwb25zZT8uZGF0YT8uZGV0YWlsIHx8ICdMb2dpbiBmYWlsZWQnLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICByZWdpc3RlcjogYXN5bmMgKHVzZXJuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBzZXQoeyBpc0xvYWRpbmc6IHRydWUsIGVycm9yOiBudWxsIH0pO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBkZXZpY2VJZCA9IGB3ZWItJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpfWA7XHJcbiAgICAgICAgICBhd2FpdCBhcGkucmVnaXN0ZXIodXNlcm5hbWUsIGVtYWlsLCBwYXNzd29yZCwgZGV2aWNlSWQpO1xyXG5cclxuICAgICAgICAgIC8vIEF1dG8tbG9naW4gYWZ0ZXIgcmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICBhd2FpdCBnZXQoKS5sb2dpbih1c2VybmFtZSwgcGFzc3dvcmQpO1xyXG5cclxuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgICBzZXQoe1xyXG4gICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxyXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IucmVzcG9uc2U/LmRhdGE/LmRldGFpbCB8fCAnUmVnaXN0cmF0aW9uIGZhaWxlZCcsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIGxvZ291dDogKCkgPT4ge1xyXG4gICAgICAgIHdzTWFuYWdlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgKHdpbmRvdyBhcyBhbnkpLl93c0hhbmRsZXJzUmVnaXN0ZXJlZCA9IGZhbHNlO1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdjaXBoZXJsaW5rX3Rva2VuJyk7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2NpcGhlcmxpbmtfdXNlcm5hbWUnKTtcclxuICAgICAgICBhcGkuc2V0VG9rZW4obnVsbCk7XHJcblxyXG4gICAgICAgIHNldCh7XHJcbiAgICAgICAgICB1c2VyOiBudWxsLFxyXG4gICAgICAgICAgdG9rZW46IG51bGwsXHJcbiAgICAgICAgICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgcHJpdmF0ZUtleTogbnVsbCxcclxuICAgICAgICAgIHB1YmxpY0tleTogbnVsbCxcclxuICAgICAgICAgIGlkZW50aXR5S2V5OiBudWxsLFxyXG4gICAgICAgICAgaWRlbnRpdHlQcml2YXRlS2V5OiBudWxsLFxyXG4gICAgICAgICAgY29udGFjdHM6IFtdLFxyXG4gICAgICAgICAgY29udmVyc2F0aW9uczogW10sXHJcbiAgICAgICAgICBjdXJyZW50Q29udmVyc2F0aW9uOiBudWxsLFxyXG4gICAgICAgICAgbWVzc2FnZXM6IG5ldyBNYXAoKSxcclxuICAgICAgICAgIG9ubGluZVVzZXJzOiBuZXcgU2V0KCksXHJcbiAgICAgICAgICB0eXBpbmdVc2VyczogbmV3IE1hcCgpLFxyXG4gICAgICAgICAgY2FsbEhpc3Rvcnk6IFtdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgaW5pdGlhbGl6ZVdlYlNvY2tldDogKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlciwgdG9rZW4gfSA9IGdldCgpO1xyXG4gICAgICAgIGlmICh1c2VyICYmIHRva2VuKSB7XHJcbiAgICAgICAgICB3c01hbmFnZXIuY29ubmVjdCh1c2VyLmlkLnRvU3RyaW5nKCksIHRva2VuKTtcclxuICAgICAgICAgIGlmICghKHdpbmRvdyBhcyBhbnkpLl93c0hhbmRsZXJzUmVnaXN0ZXJlZCkge1xyXG4gICAgICAgICAgICBzZXR1cFdlYlNvY2tldEhhbmRsZXJzKGdldCwgc2V0KTtcclxuICAgICAgICAgICAgKHdpbmRvdyBhcyBhbnkpLl93c0hhbmRsZXJzUmVnaXN0ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgbG9hZFN0b3JlZEF1dGg6IGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjaXBoZXJsaW5rX3Rva2VuJyk7XHJcbiAgICAgICAgY29uc3QgdXNlcm5hbWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY2lwaGVybGlua191c2VybmFtZScpO1xyXG5cclxuICAgICAgICBpZiAodG9rZW4gJiYgdXNlcm5hbWUpIHtcclxuICAgICAgICAgIGFwaS5zZXRUb2tlbih0b2tlbik7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgYXBpLmdldEN1cnJlbnRVc2VyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBLZXlTdG9yYWdlLmxvYWQodXNlcm5hbWUpO1xyXG5cclxuICAgICAgICAgICAgc2V0KHtcclxuICAgICAgICAgICAgICB1c2VyLFxyXG4gICAgICAgICAgICAgIHRva2VuLFxyXG4gICAgICAgICAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICBwcml2YXRlS2V5OiBrZXlzPy5wcml2YXRlS2V5IHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgcHVibGljS2V5OiBrZXlzPy5wdWJsaWNLZXkgfHwgbnVsbCxcclxuICAgICAgICAgICAgICBpZGVudGl0eUtleToga2V5cz8uaWRlbnRpdHlLZXkgfHwgbnVsbCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb25uZWN0IFdlYlNvY2tldFxyXG4gICAgICAgICAgICB3c01hbmFnZXIuY29ubmVjdCh1c2VyLmlkLnRvU3RyaW5nKCksIHRva2VuKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldHVwIG1lc3NhZ2UgaGFuZGxlcnNcclxuICAgICAgICAgICAgaWYgKCEod2luZG93IGFzIGFueSkuX3dzSGFuZGxlcnNSZWdpc3RlcmVkKSB7XHJcbiAgICAgICAgICAgICAgc2V0dXBXZWJTb2NrZXRIYW5kbGVycyhnZXQsIHNldCk7XHJcbiAgICAgICAgICAgICAgKHdpbmRvdyBhcyBhbnkpLl93c0hhbmRsZXJzUmVnaXN0ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExvYWQgcGVyc2lzdGVudCBkYXRhIGZyb20gSW5kZXhlZERCXHJcbiAgICAgICAgICAgIGF3YWl0IGdldCgpLmxvYWRQZXJzaXN0ZWREYXRhKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTeW5jIHdpdGggc2VydmVyIGluIGJhY2tncm91bmRcclxuICAgICAgICAgICAgZ2V0KCkuc3luY1dpdGhTZXJ2ZXIoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgICAvLyBUb2tlbiBleHBpcmVkIG9yIGludmFsaWRcclxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2NpcGhlcmxpbmtfdG9rZW4nKTtcclxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2NpcGhlcmxpbmtfdXNlcm5hbWUnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyA9PT09PT09PT09PT0gQ3J5cHRvIEFjdGlvbnMgPT09PT09PT09PT09XHJcblxyXG4gICAgICBnZW5lcmF0ZUFuZFVwbG9hZEtleXM6IGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZXIgfSA9IGdldCgpO1xyXG4gICAgICAgIGlmICghdXNlcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBrZXlQYWlyID0gZ2VuZXJhdGVLZXlQYWlyKCk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmluZ1BhaXIgPSBnZW5lcmF0ZVNpZ25pbmdLZXlQYWlyKCk7XHJcblxyXG4gICAgICAgIC8vIFNhdmUgbG9jYWxseVxyXG4gICAgICAgIEtleVN0b3JhZ2Uuc2F2ZSh1c2VyLnVzZXJuYW1lLCB7XHJcbiAgICAgICAgICBwcml2YXRlS2V5OiBrZXlQYWlyLnByaXZhdGVLZXksXHJcbiAgICAgICAgICBwdWJsaWNLZXk6IGtleVBhaXIucHVibGljS2V5LFxyXG4gICAgICAgICAgaWRlbnRpdHlLZXk6IHNpZ25pbmdQYWlyLnB1YmxpY0tleSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gVXBsb2FkIHRvIHNlcnZlclxyXG4gICAgICAgIGF3YWl0IGFwaS51cGxvYWRLZXlzKHtcclxuICAgICAgICAgIHB1YmxpY19rZXk6IGtleVBhaXIucHVibGljS2V5LFxyXG4gICAgICAgICAgaWRlbnRpdHlfa2V5OiBzaWduaW5nUGFpci5wdWJsaWNLZXksXHJcbiAgICAgICAgICBzaWduZWRfcHJla2V5OiBrZXlQYWlyLnB1YmxpY0tleSxcclxuICAgICAgICAgIHNpZ25lZF9wcmVrZXlfc2lnbmF0dXJlOiBzaWduaW5nUGFpci5wdWJsaWNLZXksXHJcbiAgICAgICAgICBvbmVfdGltZV9wcmVrZXlzOiBbXSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2V0KHtcclxuICAgICAgICAgIHByaXZhdGVLZXk6IGtleVBhaXIucHJpdmF0ZUtleSxcclxuICAgICAgICAgIHB1YmxpY0tleToga2V5UGFpci5wdWJsaWNLZXksXHJcbiAgICAgICAgICBpZGVudGl0eUtleTogc2lnbmluZ1BhaXIucHVibGljS2V5LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgbG9hZFN0b3JlZEtleXM6ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZXIgfSA9IGdldCgpO1xyXG4gICAgICAgIGlmICghdXNlcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBrZXlzID0gS2V5U3RvcmFnZS5sb2FkKHVzZXIudXNlcm5hbWUpO1xyXG4gICAgICAgIGlmIChrZXlzKSB7XHJcbiAgICAgICAgICBzZXQoe1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBrZXlzLnByaXZhdGVLZXksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleToga2V5cy5wdWJsaWNLZXksXHJcbiAgICAgICAgICAgIGlkZW50aXR5S2V5OiBrZXlzLmlkZW50aXR5S2V5LFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gPT09PT09PT09PT09IENoYXQgQWN0aW9ucyA9PT09PT09PT09PT1cclxuXHJcbiAgICAgIGxvYWRDb250YWN0czogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBjb250YWN0cyA9IGF3YWl0IGFwaS5nZXRDb250YWN0cygpO1xyXG4gICAgICAgICAgc2V0KHsgY29udGFjdHMgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNvbnRhY3RzOicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBsb2FkQ29udmVyc2F0aW9uczogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBjb252ZXJzYXRpb25zID0gYXdhaXQgYXBpLmdldENvbnZlcnNhdGlvbnMoKTtcclxuICAgICAgICAgIHNldCh7IGNvbnZlcnNhdGlvbnMgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNvbnZlcnNhdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIGxvYWRNZXNzYWdlczogYXN5bmMgKHVzZXJuYW1lOiBzdHJpbmcpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBhd2FpdCBhcGkuZ2V0Q29udmVyc2F0aW9uKHVzZXJuYW1lKTtcclxuXHJcbiAgICAgICAgICAvLyBUcnkgdG8gZGVjcnlwdCBtZXNzYWdlc1xyXG4gICAgICAgICAgY29uc3QgeyBwcml2YXRlS2V5LCBjb250YWN0cywgdXNlciB9ID0gZ2V0KCk7XHJcblxyXG4gICAgICAgICAgaWYgKHByaXZhdGVLZXkpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBtc2cgb2YgbWVzc2FnZXMpIHtcclxuICAgICAgICAgICAgICBpZiAobXNnLmVuY3J5cHRlZF9jb250ZW50ICYmICFtc2cuX2RlY3J5cHRlZENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSBKU09OLnBhcnNlKG1zZy5lbmNyeXB0ZWRfY29udGVudCkgYXMgRW5jcnlwdGVkTWVzc2FnZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIHYyIHByb3RvY29sOiBzZW5kZXJQdWJsaWNLZXkgaXMgZW1iZWRkZWQgaW4gbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAvLyB2MSBwcm90b2NvbDogdXNlIGNvbnRhY3QncyBjYWNoZWQgcHVibGljIGtleSBhcyBmYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICBsZXQgZmFsbGJhY2tQdWJsaWNLZXk6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmIChtc2cuc2VuZGVyX3VzZXJuYW1lID09PSB1c2VyPy51c2VybmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlbnQgYnkgbWUgLT4gZmFsbGJhY2sgaXMgcmVjaXBpZW50J3MgcHVibGljIGtleVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrUHVibGljS2V5ID0gY29udGFjdHMuZmluZChcclxuICAgICAgICAgICAgICAgICAgICAgIGMgPT4gYy5jb250YWN0X3VzZXJuYW1lID09PSBtc2cucmVjaXBpZW50X3VzZXJuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgKT8ucHVibGljX2tleTtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZWNlaXZlZCBieSBtZSAtPiBmYWxsYmFjayBpcyBzZW5kZXIncyBwdWJsaWMga2V5XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGFjdCA9IGNvbnRhY3RzLmZpbmQoXHJcbiAgICAgICAgICAgICAgICAgICAgICBjID0+IGMuY29udGFjdF91c2VybmFtZSA9PT0gbXNnLnNlbmRlcl91c2VybmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tQdWJsaWNLZXkgPSBjb250YWN0Py5wdWJsaWNfa2V5O1xyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBkZWNyeXB0TWVzc2FnZSBub3cgaGFuZGxlcyB2MiAoZW1iZWRkZWQga2V5KSBhbmQgdjEgKGZhbGxiYWNrIGtleSlcclxuICAgICAgICAgICAgICAgICAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdE1lc3NhZ2UoZW5jcnlwdGVkRGF0YSwgZmFsbGJhY2tQdWJsaWNLZXkgfHwgJycsIHByaXZhdGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgICBtc2cuX2RlY3J5cHRlZENvbnRlbnQgPSBkZWNyeXB0ZWQ7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGRlY3J5cHQgbWVzc2FnZTonLCBtc2cuaWQsIGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnN0IG5ld01lc3NhZ2VzID0gbmV3IE1hcChnZXQoKS5tZXNzYWdlcyk7XHJcbiAgICAgICAgICBuZXdNZXNzYWdlcy5zZXQodXNlcm5hbWUsIG1lc3NhZ2VzKTtcclxuICAgICAgICAgIHNldCh7IG1lc3NhZ2VzOiBuZXdNZXNzYWdlcyB9KTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgbWVzc2FnZXM6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIHNlbmRNZXNzYWdlOiBhc3luYyAocmVjaXBpZW50VXNlcm5hbWU6IHN0cmluZywgY29udGVudDogc3RyaW5nLCBtZXNzYWdlVHlwZTogc3RyaW5nID0gJ3RleHQnLCBmaWxlRGF0YT86IGFueSkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OkIHNlbmRNZXNzYWdlIGNhbGxlZDonLCB7IHJlY2lwaWVudFVzZXJuYW1lLCBjb250ZW50OiBjb250ZW50LnN1YnN0cmluZygwLCA1MCksIG1lc3NhZ2VUeXBlIH0pO1xyXG5cclxuICAgICAgICBsZXQgeyBwcml2YXRlS2V5LCBwdWJsaWNLZXksIHVzZXIgfSA9IGdldCgpO1xyXG4gICAgICAgIGlmICghcHJpdmF0ZUtleSB8fCAhcHVibGljS2V5IHx8ICF1c2VyKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3Qgc2VuZCBtZXNzYWdlOiBtaXNzaW5nIGtleXMgb3IgdXNlcicsIHsgaGFzUHJpdmF0ZUtleTogISFwcml2YXRlS2V5LCBoYXNQdWJsaWNLZXk6ICEhcHVibGljS2V5LCBoYXNVc2VyOiAhIXVzZXIgfSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDUklUSUNBTDogVmVyaWZ5IG91ciBrZXkgcGFpciBpcyB2YWxpZCBiZWZvcmUgc2VuZGluZ1xyXG4gICAgICAgIGNvbnN0IGlzVmFsaWRQYWlyID0gdmVyaWZ5S2V5UGFpcihwcml2YXRlS2V5LCBwdWJsaWNLZXkpO1xyXG4gICAgICAgIGlmICghaXNWYWxpZFBhaXIpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIEludmFsaWQga2V5IHBhaXIgZGV0ZWN0ZWQgaW4gc2VuZE1lc3NhZ2UhIERlcml2aW5nIGNvcnJlY3QgcHVibGljIGtleS4uLicpO1xyXG4gICAgICAgICAgcHVibGljS2V5ID0gZGVyaXZlUHVibGljS2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleSk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UpyBVc2luZyBkZXJpdmVkIHB1YmxpY0tleTonLCBwdWJsaWNLZXk/LnN1YnN0cmluZygwLCAzMCkpO1xyXG4gICAgICAgICAgLy8gVXBkYXRlIHN0b3JlIHdpdGggY29ycmVjdGVkIGtleVxyXG4gICAgICAgICAgc2V0KHsgcHVibGljS2V5IH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWx3YXlzIGZldGNoIHRoZSBsYXRlc3QgcmVjaXBpZW50IHB1YmxpYyBrZXkgZnJvbSB0aGUgc2VydmVyXHJcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk6QgRmV0Y2hpbmcgcHVibGljIGtleSBmcm9tIHNlcnZlciBmb3I6JywgcmVjaXBpZW50VXNlcm5hbWUpO1xyXG4gICAgICAgIGxldCByZWNpcGllbnRQdWJsaWNLZXk6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3Qga2V5RGF0YSA9IGF3YWl0IGFwaS5nZXRQdWJsaWNLZXkocmVjaXBpZW50VXNlcm5hbWUpO1xyXG4gICAgICAgICAgcmVjaXBpZW50UHVibGljS2V5ID0ga2V5RGF0YS5wdWJsaWNfa2V5O1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfk6QgR290IHJlY2lwaWVudCBwdWJsaWMga2V5IGZyb20gc2VydmVyOicsIHJlY2lwaWVudFB1YmxpY0tleT8uc3Vic3RyaW5nKDAsIDMwKSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgcmVjaXBpZW50IHB1YmxpYyBrZXk6JywgZXJyb3IpO1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IHJlY2lwaWVudCBlbmNyeXB0aW9uIGtleScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFyZWNpcGllbnRQdWJsaWNLZXkpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVjaXBpZW50IGhhcyBub3Qgc2V0IHVwIGVuY3J5cHRpb24nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVuY3J5cHQgbWVzc2FnZSB1c2luZyBzdGF0aWMga2V5IHBhaXIgKFgyNTUxOSlcclxuICAgICAgICAvLyB2MiBwcm90b2NvbDogaW5jbHVkZXMgc2VuZGVyJ3MgcHVibGljIGtleSBpbiB0aGUgcGF5bG9hZCBmb3IgcmVsaWFibGUgZGVjcnlwdGlvblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OkIEVuY3J5cHRpbmcgd2l0aDonLCB7XHJcbiAgICAgICAgICByZWNpcGllbnRQdWJLZXk6IHJlY2lwaWVudFB1YmxpY0tleT8uc3Vic3RyaW5nKDAsIDMwKSxcclxuICAgICAgICAgIHNlbmRlclByaXZLZXk6IHByaXZhdGVLZXk/LnN1YnN0cmluZygwLCAzMCksXHJcbiAgICAgICAgICBzZW5kZXJQdWJLZXk6IHB1YmxpY0tleT8uc3Vic3RyaW5nKDAsIDMwKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0TWVzc2FnZShjb250ZW50LCByZWNpcGllbnRQdWJsaWNLZXksIHByaXZhdGVLZXksIHB1YmxpY0tleSk7XHJcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkQ29udGVudCA9IEpTT04uc3RyaW5naWZ5KGVuY3J5cHRlZCk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0byBsb2NhbCBtZXNzYWdlcyBvcHRpbWlzdGljYWxseVxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRNZXNzYWdlcyA9IGdldCgpLm1lc3NhZ2VzLmdldChyZWNpcGllbnRVc2VybmFtZSkgfHwgW107XHJcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gLURhdGUubm93KCk7XHJcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY01lc3NhZ2U6IE1lc3NhZ2UgPSB7XHJcbiAgICAgICAgICBpZDogb3B0aW1pc3RpY0lkLFxyXG4gICAgICAgICAgc2VuZGVyX2lkOiB1c2VyLmlkLFxyXG4gICAgICAgICAgc2VuZGVyX3VzZXJuYW1lOiB1c2VyLnVzZXJuYW1lLFxyXG4gICAgICAgICAgcmVjaXBpZW50X2lkOiAwLCAvLyBVbmtub3duIElEIGZvciBub3dcclxuICAgICAgICAgIHJlY2lwaWVudF91c2VybmFtZTogcmVjaXBpZW50VXNlcm5hbWUsXHJcbiAgICAgICAgICBlbmNyeXB0ZWRfY29udGVudDogZW5jcnlwdGVkQ29udGVudCxcclxuICAgICAgICAgIG1lc3NhZ2VfdHlwZTogbWVzc2FnZVR5cGUsXHJcbiAgICAgICAgICBzdGF0dXM6ICdzZW5kaW5nJyxcclxuICAgICAgICAgIGV4cGlyeV90eXBlOiAnbm9uZScsXHJcbiAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICBfZGVjcnlwdGVkQ29udGVudDogY29udGVudCwgLy8gV2Uga25vdyB3aGF0IHdlIHNlbnRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBuZXdNZXNzYWdlcyA9IG5ldyBNYXAoZ2V0KCkubWVzc2FnZXMpO1xyXG4gICAgICAgIG5ld01lc3NhZ2VzLnNldChyZWNpcGllbnRVc2VybmFtZSwgWy4uLmN1cnJlbnRNZXNzYWdlcywgb3B0aW1pc3RpY01lc3NhZ2VdKTtcclxuICAgICAgICBzZXQoeyBtZXNzYWdlczogbmV3TWVzc2FnZXMgfSk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+TpCBTZW5kaW5nIHRvIEFQSS4uLicpO1xyXG4gICAgICAgICAgY29uc3Qgc2VudE1lc3NhZ2UgPSBhd2FpdCBhcGkuc2VuZE1lc3NhZ2UoXHJcbiAgICAgICAgICAgIHJlY2lwaWVudFVzZXJuYW1lLFxyXG4gICAgICAgICAgICBlbmNyeXB0ZWRDb250ZW50LFxyXG4gICAgICAgICAgICB1bmRlZmluZWQsIC8vIGVuY3J5cHRlZEtleVxyXG4gICAgICAgICAgICAnbm9uZScsXHJcbiAgICAgICAgICAgIG1lc3NhZ2VUeXBlLFxyXG4gICAgICAgICAgICBmaWxlRGF0YVxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIE1lc3NhZ2Ugc2VudCBzdWNjZXNzZnVsbHknLCBzZW50TWVzc2FnZSk7XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIG9wdGltaXN0aWMgbWVzc2FnZSB3aXRoIHJlYWwgb25lIHdoaWxlIHByZXNlcnZpbmcgZGVjcnlwdGVkIGNvbnRlbnRcclxuICAgICAgICAgIHNlbnRNZXNzYWdlLl9kZWNyeXB0ZWRDb250ZW50ID0gY29udGVudDtcclxuXHJcbiAgICAgICAgICBjb25zdCB1cGRhdGVkTWVzc2FnZXMgPSBuZXcgTWFwKGdldCgpLm1lc3NhZ2VzKTtcclxuICAgICAgICAgIGNvbnN0IHVzZXJNZXNzYWdlcyA9IHVwZGF0ZWRNZXNzYWdlcy5nZXQocmVjaXBpZW50VXNlcm5hbWUpIHx8IFtdO1xyXG4gICAgICAgICAgY29uc3QgaW5kZXggPSB1c2VyTWVzc2FnZXMuZmluZEluZGV4KG0gPT4gbS5pZCA9PT0gb3B0aW1pc3RpY0lkKTtcclxuXHJcbiAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHVzZXJNZXNzYWdlc1tpbmRleF0gPSBzZW50TWVzc2FnZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHVzZXJNZXNzYWdlcy5wdXNoKHNlbnRNZXNzYWdlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB1cGRhdGVkTWVzc2FnZXMuc2V0KHJlY2lwaWVudFVzZXJuYW1lLCB1c2VyTWVzc2FnZXMpO1xyXG4gICAgICAgICAgc2V0KHsgbWVzc2FnZXM6IHVwZGF0ZWRNZXNzYWdlcyB9KTtcclxuXHJcbiAgICAgICAgICAvLyBQZXJzaXN0IG1lc3NhZ2UgYW5kIHVwZGF0ZS9wZXJzaXN0IGNvbnZlcnNhdGlvbiBzbmFwc2hvdCBmb3IgaGlzdG9yeVxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgZ2V0KCkucGVyc2lzdE1lc3NhZ2Uoc2VudE1lc3NhZ2UpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIHBlcnNpc3Qgc2VudCBtZXNzYWdlOicsIGUpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFVwZGF0ZSBjb252ZXJzYXRpb24gcHJldmlldyAmIHBlcnNpc3RcclxuICAgICAgICAgIGNvbnN0IHN0YXRlQWZ0ZXJTZW5kID0gZ2V0KCk7XHJcbiAgICAgICAgICBjb25zdCBleGlzdGluZ0NvbnZJbmRleCA9IHN0YXRlQWZ0ZXJTZW5kLmNvbnZlcnNhdGlvbnMuZmluZEluZGV4KGMgPT4gYy51c2VybmFtZSA9PT0gcmVjaXBpZW50VXNlcm5hbWUpO1xyXG4gICAgICAgICAgaWYgKGV4aXN0aW5nQ29udkluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgY29uc3QgY29udmVyc2F0aW9ucyA9IFsuLi5zdGF0ZUFmdGVyU2VuZC5jb252ZXJzYXRpb25zXTtcclxuICAgICAgICAgICAgY29uc3QgY29udiA9IGNvbnZlcnNhdGlvbnNbZXhpc3RpbmdDb252SW5kZXhdO1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkQ29udiA9IHtcclxuICAgICAgICAgICAgICAuLi5jb252LFxyXG4gICAgICAgICAgICAgIGxhc3RfbWVzc2FnZV90aW1lOiBzZW50TWVzc2FnZS5jcmVhdGVkX2F0LFxyXG4gICAgICAgICAgICAgIGxhc3RfbWVzc2FnZV9wcmV2aWV3OiBtZXNzYWdlVHlwZSA9PT0gJ2ltYWdlJyA/ICfwn5O3IEltYWdlJyA6IGNvbnRlbnQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbnNbZXhpc3RpbmdDb252SW5kZXhdID0gdXBkYXRlZENvbnY7XHJcbiAgICAgICAgICAgIHNldCh7IGNvbnZlcnNhdGlvbnMgfSk7XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGF3YWl0IGdldCgpLnBlcnNpc3RDb252ZXJzYXRpb24odXBkYXRlZENvbnYpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBwZXJzaXN0IGNvbnZlcnNhdGlvbiBhZnRlciBzZW5kOicsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2VuZCBtZXNzYWdlOicsIGVycm9yKTtcclxuICAgICAgICAgIC8vIE1hcmsgYXMgZmFpbGVkXHJcbiAgICAgICAgICBjb25zdCB1cGRhdGVkTWVzc2FnZXMgPSBuZXcgTWFwKGdldCgpLm1lc3NhZ2VzKTtcclxuICAgICAgICAgIGNvbnN0IHVzZXJNZXNzYWdlcyA9IHVwZGF0ZWRNZXNzYWdlcy5nZXQocmVjaXBpZW50VXNlcm5hbWUpIHx8IFtdO1xyXG4gICAgICAgICAgY29uc3QgaW5kZXggPSB1c2VyTWVzc2FnZXMuZmluZEluZGV4KG0gPT4gbS5pZCA9PT0gb3B0aW1pc3RpY0lkKTtcclxuICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdXNlck1lc3NhZ2VzW2luZGV4XS5zdGF0dXMgPSAnZmFpbGVkJztcclxuICAgICAgICAgICAgdXBkYXRlZE1lc3NhZ2VzLnNldChyZWNpcGllbnRVc2VybmFtZSwgdXNlck1lc3NhZ2VzKTtcclxuICAgICAgICAgICAgc2V0KHsgbWVzc2FnZXM6IHVwZGF0ZWRNZXNzYWdlcyB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIHNldEN1cnJlbnRDb252ZXJzYXRpb246ICh1c2VybmFtZTogc3RyaW5nIHwgbnVsbCkgPT4ge1xyXG4gICAgICAgIHNldCh7IGN1cnJlbnRDb252ZXJzYXRpb246IHVzZXJuYW1lIH0pO1xyXG4gICAgICAgIGlmICh1c2VybmFtZSkge1xyXG4gICAgICAgICAgZ2V0KCkubG9hZE1lc3NhZ2VzKHVzZXJuYW1lKTtcclxuXHJcbiAgICAgICAgICAvLyBDbGVhciB0eXBpbmcgaW5kaWNhdG9yIGZvciB0aGlzIHVzZXJcclxuICAgICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XHJcbiAgICAgICAgICBjb25zdCBuZXdUeXBpbmdVc2VycyA9IG5ldyBNYXAoc3RhdGUudHlwaW5nVXNlcnMpO1xyXG4gICAgICAgICAgbmV3VHlwaW5nVXNlcnMuZGVsZXRlKHVzZXJuYW1lKTtcclxuICAgICAgICAgIHNldCh7IHR5cGluZ1VzZXJzOiBuZXdUeXBpbmdVc2VycyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBhZGRDb250YWN0OiBhc3luYyAodXNlcm5hbWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBjb250YWN0ID0gYXdhaXQgYXBpLmFkZENvbnRhY3QodXNlcm5hbWUpO1xyXG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcclxuICAgICAgICAgIHNldCh7IGNvbnRhY3RzOiBbLi4uc3RhdGUuY29udGFjdHMsIGNvbnRhY3RdIH0pO1xyXG5cclxuICAgICAgICAgIC8vIEFsc28gYWRkIHRvIGNvbnZlcnNhdGlvbnMgaW1tZWRpYXRlbHlcclxuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ29udiA9IHN0YXRlLmNvbnZlcnNhdGlvbnMuZmluZChjID0+IGMudXNlcm5hbWUgPT09IHVzZXJuYW1lKTtcclxuICAgICAgICAgIGlmICghZXhpc3RpbmdDb252KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbnZlcnNhdGlvbjogQ29udmVyc2F0aW9uID0ge1xyXG4gICAgICAgICAgICAgIHVzZXJfaWQ6IGNvbnRhY3QuY29udGFjdF9pZCxcclxuICAgICAgICAgICAgICB1c2VybmFtZTogY29udGFjdC5jb250YWN0X3VzZXJuYW1lLFxyXG4gICAgICAgICAgICAgIHB1YmxpY19rZXk6IGNvbnRhY3QucHVibGljX2tleSxcclxuICAgICAgICAgICAgICBpZGVudGl0eV9rZXk6IGNvbnRhY3QuaWRlbnRpdHlfa2V5LFxyXG4gICAgICAgICAgICAgIGxhc3RfbWVzc2FnZV90aW1lOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3ByZXZpZXc6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICB1bnJlYWRfY291bnQ6IDAsXHJcbiAgICAgICAgICAgICAgaXNfb25saW5lOiBmYWxzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBzZXQoeyBjb252ZXJzYXRpb25zOiBbbmV3Q29udmVyc2F0aW9uLCAuLi5zdGF0ZS5jb252ZXJzYXRpb25zXSB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGFkZCBjb250YWN0OicsIGVycm9yKTtcclxuICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIHNlYXJjaFVzZXJzOiBhc3luYyAocXVlcnk6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICByZXR1cm4gYXdhaXQgYXBpLnNlYXJjaFVzZXJzKHF1ZXJ5KTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNlYXJjaCB1c2VyczonLCBlcnJvcik7XHJcbiAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgYWRkSW5jb21pbmdNZXNzYWdlOiAobWVzc2FnZTogTWVzc2FnZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XHJcbiAgICAgICAgY29uc3Qgc2VuZGVyVXNlcm5hbWUgPSBtZXNzYWdlLnNlbmRlcl91c2VybmFtZTtcclxuICAgICAgICAvLyBDaGVjayBpZiBtZXNzYWdlIGFscmVhZHkgZXhpc3RzXHJcbiAgICAgICAgY29uc3QgY3VycmVudE1lc3NhZ2VzID0gZ2V0KCkubWVzc2FnZXMuZ2V0KHNlbmRlclVzZXJuYW1lKSB8fCBbXTtcclxuICAgICAgICBjb25zdCBleGlzdHMgPSBjdXJyZW50TWVzc2FnZXMuc29tZShtID0+IG0uaWQgPT09IG1lc3NhZ2UuaWQpO1xyXG5cclxuICAgICAgICBpZiAoIWV4aXN0cykge1xyXG4gICAgICAgICAgLy8gRGVjcnlwdCBpbW1lZGlhdGVseSBpZiBwb3NzaWJsZVxyXG4gICAgICAgICAgLy8gdjIgcHJvdG9jb2w6IHNlbmRlclB1YmxpY0tleSBpcyBlbWJlZGRlZCBpbiB0aGUgbWVzc2FnZSBwYXlsb2FkXHJcbiAgICAgICAgICBjb25zdCB7IHByaXZhdGVLZXksIGNvbnRhY3RzIH0gPSBnZXQoKTtcclxuICAgICAgICAgIGlmIChwcml2YXRlS2V5ICYmIG1lc3NhZ2UuZW5jcnlwdGVkX2NvbnRlbnQpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlLmVuY3J5cHRlZF9jb250ZW50KSBhcyBFbmNyeXB0ZWRNZXNzYWdlO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgZmFsbGJhY2sgcHVibGljIGtleSBmcm9tIGNvbnRhY3RzIChmb3IgdjEgbWVzc2FnZXMpXHJcbiAgICAgICAgICAgICAgY29uc3QgY29udGFjdCA9IGNvbnRhY3RzLmZpbmQoXHJcbiAgICAgICAgICAgICAgICBjID0+IGMuY29udGFjdF91c2VybmFtZSA9PT0gbWVzc2FnZS5zZW5kZXJfdXNlcm5hbWVcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrUHVibGljS2V5ID0gY29udGFjdD8ucHVibGljX2tleSB8fCAnJztcclxuXHJcbiAgICAgICAgICAgICAgLy8gZGVjcnlwdE1lc3NhZ2UgaGFuZGxlcyB2MiAodXNlcyBlbWJlZGRlZCBzZW5kZXJQdWJsaWNLZXkpIGFuZCB2MSAodXNlcyBmYWxsYmFjaylcclxuICAgICAgICAgICAgICBtZXNzYWdlLl9kZWNyeXB0ZWRDb250ZW50ID0gZGVjcnlwdE1lc3NhZ2UoXHJcbiAgICAgICAgICAgICAgICBlbmNyeXB0ZWREYXRhLFxyXG4gICAgICAgICAgICAgICAgZmFsbGJhY2tQdWJsaWNLZXksXHJcbiAgICAgICAgICAgICAgICBwcml2YXRlS2V5XHJcbiAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuX2RlY3J5cHRlZENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgU3VjY2Vzc2Z1bGx5IGRlY3J5cHRlZCBpbmNvbWluZyBtZXNzYWdlJyk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIERlY3J5cHRpb24gcmV0dXJuZWQgbnVsbCBmb3IgbWVzc2FnZTonLCBtZXNzYWdlLmlkKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRGVjcnlwdGlvbiBmYWlsZWQgZm9yIGluY29taW5nOicsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc3QgbmV3TWVzc2FnZXMgPSBuZXcgTWFwKGdldCgpLm1lc3NhZ2VzKTtcclxuICAgICAgICAgIG5ld01lc3NhZ2VzLnNldChzZW5kZXJVc2VybmFtZSwgWy4uLmN1cnJlbnRNZXNzYWdlcywgbWVzc2FnZV0pO1xyXG4gICAgICAgICAgc2V0KHsgbWVzc2FnZXM6IG5ld01lc3NhZ2VzIH0pO1xyXG5cclxuICAgICAgICAgIC8vIFVwZGF0ZSBjb252ZXJzYXRpb24gbGlzdFxyXG4gICAgICAgICAgY29uc3QgY29udkluZGV4ID0gc3RhdGUuY29udmVyc2F0aW9ucy5maW5kSW5kZXgoYyA9PiBjLnVzZXJuYW1lID09PSBzZW5kZXJVc2VybmFtZSk7XHJcbiAgICAgICAgICBpZiAoY29udkluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgY29uc3QgY29udmVyc2F0aW9ucyA9IFsuLi5zdGF0ZS5jb252ZXJzYXRpb25zXTtcclxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZENvbnYgPSB7XHJcbiAgICAgICAgICAgICAgLi4uY29udmVyc2F0aW9uc1tjb252SW5kZXhdLFxyXG4gICAgICAgICAgICAgIGxhc3RfbWVzc2FnZV90aW1lOiBtZXNzYWdlLmNyZWF0ZWRfYXQsXHJcbiAgICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3ByZXZpZXc6IG1lc3NhZ2UuX2RlY3J5cHRlZENvbnRlbnRcclxuICAgICAgICAgICAgICAgID8gKG1lc3NhZ2UubWVzc2FnZV90eXBlID09PSAnaW1hZ2UnID8gJ/Cfk7cgSW1hZ2UnIDogbWVzc2FnZS5fZGVjcnlwdGVkQ29udGVudClcclxuICAgICAgICAgICAgICAgIDogJ1tFbmNyeXB0ZWQgTWVzc2FnZV0nLFxyXG4gICAgICAgICAgICAgIHVucmVhZF9jb3VudDogKGNvbnZlcnNhdGlvbnNbY29udkluZGV4XS51bnJlYWRfY291bnQgfHwgMCkgKyAxXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbnNbY29udkluZGV4XSA9IHVwZGF0ZWRDb252O1xyXG4gICAgICAgICAgICBzZXQoeyBjb252ZXJzYXRpb25zIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gUGVyc2lzdCBsYXRlc3QgY29udmVyc2F0aW9uIHNuYXBzaG90IGFuZCBtZXNzYWdlIGZvciBoaXN0b3J5XHJcbiAgICAgICAgICAgIGdldCgpLnBlcnNpc3RNZXNzYWdlKG1lc3NhZ2UpLmNhdGNoKGVyciA9PlxyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gcGVyc2lzdCBpbmNvbWluZyBtZXNzYWdlOicsIGVycilcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZ2V0KCkucGVyc2lzdENvbnZlcnNhdGlvbih1cGRhdGVkQ29udikuY2F0Y2goZXJyID0+XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBwZXJzaXN0IGNvbnZlcnNhdGlvbiBmb3IgaW5jb21pbmcgbWVzc2FnZTonLCBlcnIpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNZXNzYWdlIGZyb20gdXNlciB3aXRob3V0IGFuIGV4aXN0aW5nIGNvbnZlcnNhdGlvbiBlbnRyeSDigJMgY3JlYXRlIGEgbGlnaHR3ZWlnaHQgb25lXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbnZlcnNhdGlvbiA9IHtcclxuICAgICAgICAgICAgICB1c2VyX2lkOiBtZXNzYWdlLnNlbmRlcl9pZCxcclxuICAgICAgICAgICAgICB1c2VybmFtZTogc2VuZGVyVXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgcHVibGljX2tleTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIGlkZW50aXR5X2tleTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIGxhc3RfbWVzc2FnZV90aW1lOiBtZXNzYWdlLmNyZWF0ZWRfYXQsXHJcbiAgICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3ByZXZpZXc6IG1lc3NhZ2UuX2RlY3J5cHRlZENvbnRlbnRcclxuICAgICAgICAgICAgICAgID8gKG1lc3NhZ2UubWVzc2FnZV90eXBlID09PSAnaW1hZ2UnID8gJ/Cfk7cgSW1hZ2UnIDogbWVzc2FnZS5fZGVjcnlwdGVkQ29udGVudClcclxuICAgICAgICAgICAgICAgIDogJ1tFbmNyeXB0ZWQgTWVzc2FnZV0nLFxyXG4gICAgICAgICAgICAgIHVucmVhZF9jb3VudDogMSxcclxuICAgICAgICAgICAgICBpc19vbmxpbmU6IGZhbHNlLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBzZXQoeyBjb252ZXJzYXRpb25zOiBbbmV3Q29udmVyc2F0aW9uLCAuLi5zdGF0ZS5jb252ZXJzYXRpb25zXSB9KTtcclxuXHJcbiAgICAgICAgICAgIGdldCgpLnBlcnNpc3RNZXNzYWdlKG1lc3NhZ2UpLmNhdGNoKGVyciA9PlxyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gcGVyc2lzdCBpbmNvbWluZyBtZXNzYWdlOicsIGVycilcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZ2V0KCkucGVyc2lzdENvbnZlcnNhdGlvbihuZXdDb252ZXJzYXRpb24pLmNhdGNoKGVyciA9PlxyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gcGVyc2lzdCBuZXcgY29udmVyc2F0aW9uIGZvciBpbmNvbWluZyBtZXNzYWdlOicsIGVycilcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBsb2FkQ2FsbEhpc3Rvcnk6IGFzeW5jICgpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgaGlzdG9yeSA9IGF3YWl0IGFwaS5nZXRDYWxsSGlzdG9yeSgpO1xyXG4gICAgICAgICAgc2V0KHsgY2FsbEhpc3Rvcnk6IGhpc3RvcnkgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNhbGwgaGlzdG9yeTonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gPT09PT09PT09PT09IFByZXNlbmNlID09PT09PT09PT09PVxyXG5cclxuICAgICAgc2V0VXNlck9ubGluZTogKHVzZXJJZDogbnVtYmVyLCBpc09ubGluZTogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XHJcbiAgICAgICAgY29uc3QgbmV3T25saW5lVXNlcnMgPSBuZXcgU2V0KHN0YXRlLm9ubGluZVVzZXJzKTtcclxuICAgICAgICBpZiAoaXNPbmxpbmUpIHtcclxuICAgICAgICAgIG5ld09ubGluZVVzZXJzLmFkZCh1c2VySWQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdPbmxpbmVVc2Vycy5kZWxldGUodXNlcklkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0KHsgb25saW5lVXNlcnM6IG5ld09ubGluZVVzZXJzIH0pO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgc2V0VXNlclR5cGluZzogKHVzZXJuYW1lOiBzdHJpbmcsIGlzVHlwaW5nOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcclxuICAgICAgICBjb25zdCBuZXdUeXBpbmdVc2VycyA9IG5ldyBNYXAoc3RhdGUudHlwaW5nVXNlcnMpO1xyXG4gICAgICAgIGlmIChpc1R5cGluZykge1xyXG4gICAgICAgICAgbmV3VHlwaW5nVXNlcnMuc2V0KHVzZXJuYW1lLCB0cnVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV3VHlwaW5nVXNlcnMuZGVsZXRlKHVzZXJuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0KHsgdHlwaW5nVXNlcnM6IG5ld1R5cGluZ1VzZXJzIH0pO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgY2xlYXJFcnJvcjogKCkgPT4gc2V0KHsgZXJyb3I6IG51bGwgfSksXHJcblxyXG4gICAgICAvLyA9PT09PT09PT09PT0gRGVsZXRpb24gQWN0aW9ucyA9PT09PT09PT09PT1cclxuXHJcbiAgICAgIGRlbGV0ZU1lc3NhZ2VGb3JNZTogYXN5bmMgKG1lc3NhZ2VJZDogbnVtYmVyLCBjb252ZXJzYXRpb25Vc2VybmFtZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgLy8gRGVsZXRlIGxvY2FsbHkgb25seSAtIGRvZXMgbm90IGFmZmVjdCB0aGUgb3RoZXIgdXNlclxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBsb2NhbCBzdGF0ZVxyXG4gICAgICAgICAgY29uc3QgY3VycmVudE1lc3NhZ2VzID0gbmV3IE1hcChnZXQoKS5tZXNzYWdlcyk7XHJcbiAgICAgICAgICBjb25zdCBjb252TWVzc2FnZXMgPSBjdXJyZW50TWVzc2FnZXMuZ2V0KGNvbnZlcnNhdGlvblVzZXJuYW1lKSB8fCBbXTtcclxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRNZXNzYWdlcyA9IGNvbnZNZXNzYWdlcy5maWx0ZXIobSA9PiBtLmlkICE9PSBtZXNzYWdlSWQpO1xyXG4gICAgICAgICAgY3VycmVudE1lc3NhZ2VzLnNldChjb252ZXJzYXRpb25Vc2VybmFtZSwgdXBkYXRlZE1lc3NhZ2VzKTtcclxuICAgICAgICAgIHNldCh7IG1lc3NhZ2VzOiBjdXJyZW50TWVzc2FnZXMgfSk7XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGZyb20gSW5kZXhlZERCXHJcbiAgICAgICAgICBhd2FpdCBsb2NhbFN0b3JhZ2VNYW5hZ2VyLmRlbGV0ZU1lc3NhZ2UobWVzc2FnZUlkKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5eR77iPIE1lc3NhZ2UgZGVsZXRlZCBsb2NhbGx5OicsIG1lc3NhZ2VJZCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgbWVzc2FnZSBsb2NhbGx5OicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBkZWxldGVNZXNzYWdlRm9yRXZlcnlvbmU6IGFzeW5jIChtZXNzYWdlSWQ6IG51bWJlciwgY29udmVyc2F0aW9uVXNlcm5hbWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIC8vIERlbGV0ZSBmb3IgZXZlcnlvbmUgLSBzZW5kcyBkZWxldGUgZXZlbnQgdG8gcmVjaXBpZW50XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIEZpcnN0IG1hcmsgbG9jYWxseSBhcyBkZWxldGVkXHJcbiAgICAgICAgICBjb25zdCBjdXJyZW50TWVzc2FnZXMgPSBuZXcgTWFwKGdldCgpLm1lc3NhZ2VzKTtcclxuICAgICAgICAgIGNvbnN0IGNvbnZNZXNzYWdlcyA9IGN1cnJlbnRNZXNzYWdlcy5nZXQoY29udmVyc2F0aW9uVXNlcm5hbWUpIHx8IFtdO1xyXG4gICAgICAgICAgY29uc3QgdXBkYXRlZE1lc3NhZ2VzID0gY29udk1lc3NhZ2VzLm1hcChtID0+IHtcclxuICAgICAgICAgICAgaWYgKG0uaWQgPT09IG1lc3NhZ2VJZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAuLi5tLFxyXG4gICAgICAgICAgICAgICAgX2RlY3J5cHRlZENvbnRlbnQ6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBlbmNyeXB0ZWRfY29udGVudDogSlNPTi5zdHJpbmdpZnkoeyBkZWxldGVkOiB0cnVlIH0pLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZV90eXBlOiAnZGVsZXRlZCcsXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY3VycmVudE1lc3NhZ2VzLnNldChjb252ZXJzYXRpb25Vc2VybmFtZSwgdXBkYXRlZE1lc3NhZ2VzKTtcclxuICAgICAgICAgIHNldCh7IG1lc3NhZ2VzOiBjdXJyZW50TWVzc2FnZXMgfSk7XHJcblxyXG4gICAgICAgICAgLy8gTWFyayBhcyBkZWxldGVkIGluIEluZGV4ZWREQlxyXG4gICAgICAgICAgYXdhaXQgbG9jYWxTdG9yYWdlTWFuYWdlci5tYXJrTWVzc2FnZUFzRGVsZXRlZChtZXNzYWdlSWQpO1xyXG5cclxuICAgICAgICAgIC8vIFNlbmQgZGVsZXRlIGV2ZW50IHRvIHJlY2lwaWVudCB2aWEgV2ViU29ja2V0XHJcbiAgICAgICAgICB3c01hbmFnZXIuc2VuZERlbGV0ZU1lc3NhZ2UobWVzc2FnZUlkLCBjb252ZXJzYXRpb25Vc2VybmFtZSk7XHJcblxyXG4gICAgICAgICAgLy8gQWxzbyB0cnkgdG8gZGVsZXRlIG9uIHNlcnZlclxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgYXBpLmRlbGV0ZU1lc3NhZ2UobWVzc2FnZUlkKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZGVsZXRlIG1lc3NhZ2Ugb24gc2VydmVyOicsIGUpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5eR77iPIE1lc3NhZ2UgZGVsZXRlZCBmb3IgZXZlcnlvbmU6JywgbWVzc2FnZUlkKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBtZXNzYWdlIGZvciBldmVyeW9uZTonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgY2xlYXJDaGF0OiBhc3luYyAodXNlcm5hbWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIC8vIENsZWFyIGxvY2FsIGNoYXQgaGlzdG9yeSBvbmx5IC0gZG9lcyBub3QgYWZmZWN0IHRoZSBvdGhlciB1c2VyXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHsgdXNlciB9ID0gZ2V0KCk7XHJcbiAgICAgICAgICBpZiAoIXVzZXIpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAvLyBDbGVhciBmcm9tIGxvY2FsIHN0YXRlXHJcbiAgICAgICAgICBjb25zdCBjdXJyZW50TWVzc2FnZXMgPSBuZXcgTWFwKGdldCgpLm1lc3NhZ2VzKTtcclxuICAgICAgICAgIGN1cnJlbnRNZXNzYWdlcy5zZXQodXNlcm5hbWUsIFtdKTtcclxuICAgICAgICAgIHNldCh7IG1lc3NhZ2VzOiBjdXJyZW50TWVzc2FnZXMgfSk7XHJcblxyXG4gICAgICAgICAgLy8gQ2xlYXIgZnJvbSBJbmRleGVkREJcclxuICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmFnZU1hbmFnZXIuY2xlYXJDb252ZXJzYXRpb25NZXNzYWdlcyh1c2VybmFtZSwgdXNlci51c2VybmFtZSk7XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIGNvbnZlcnNhdGlvbiBwcmV2aWV3XHJcbiAgICAgICAgICBjb25zdCBjb252ZXJzYXRpb25zID0gWy4uLmdldCgpLmNvbnZlcnNhdGlvbnNdO1xyXG4gICAgICAgICAgY29uc3QgY29udkluZGV4ID0gY29udmVyc2F0aW9ucy5maW5kSW5kZXgoYyA9PiBjLnVzZXJuYW1lID09PSB1c2VybmFtZSk7XHJcbiAgICAgICAgICBpZiAoY29udkluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgY29udmVyc2F0aW9uc1tjb252SW5kZXhdID0ge1xyXG4gICAgICAgICAgICAgIC4uLmNvbnZlcnNhdGlvbnNbY29udkluZGV4XSxcclxuICAgICAgICAgICAgICBsYXN0X21lc3NhZ2VfcHJldmlldzogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIGxhc3RfbWVzc2FnZV90aW1lOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgdW5yZWFkX2NvdW50OiAwLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBzZXQoeyBjb252ZXJzYXRpb25zIH0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn6e5IENoYXQgY2xlYXJlZCBsb2NhbGx5OicsIHVzZXJuYW1lKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNsZWFyIGNoYXQ6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIGRlbGV0ZUNvbnZlcnNhdGlvbkZvckV2ZXJ5b25lOiBhc3luYyAodXNlcm5hbWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIC8vIERlbGV0ZSBlbnRpcmUgY29udmVyc2F0aW9uIGZvciBib3RoIHNpZGVzXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHsgdXNlciB9ID0gZ2V0KCk7XHJcbiAgICAgICAgICBpZiAoIXVzZXIpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBsb2NhbCBzdGF0ZVxyXG4gICAgICAgICAgY29uc3QgY3VycmVudE1lc3NhZ2VzID0gbmV3IE1hcChnZXQoKS5tZXNzYWdlcyk7XHJcbiAgICAgICAgICBjdXJyZW50TWVzc2FnZXMuZGVsZXRlKHVzZXJuYW1lKTtcclxuICAgICAgICAgIHNldCh7IG1lc3NhZ2VzOiBjdXJyZW50TWVzc2FnZXMgfSk7XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGNvbnZlcnNhdGlvbiBmcm9tIGxpc3RcclxuICAgICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbnMgPSBnZXQoKS5jb252ZXJzYXRpb25zLmZpbHRlcihjID0+IGMudXNlcm5hbWUgIT09IHVzZXJuYW1lKTtcclxuICAgICAgICAgIHNldCh7IGNvbnZlcnNhdGlvbnMgfSk7XHJcblxyXG4gICAgICAgICAgLy8gQ2xlYXIgY3VycmVudCBjb252ZXJzYXRpb24gaWYgaXQgd2FzIHRoZSBkZWxldGVkIG9uZVxyXG4gICAgICAgICAgaWYgKGdldCgpLmN1cnJlbnRDb252ZXJzYXRpb24gPT09IHVzZXJuYW1lKSB7XHJcbiAgICAgICAgICAgIHNldCh7IGN1cnJlbnRDb252ZXJzYXRpb246IG51bGwgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRGVsZXRlIGZyb20gSW5kZXhlZERCXHJcbiAgICAgICAgICBhd2FpdCBsb2NhbFN0b3JhZ2VNYW5hZ2VyLmRlbGV0ZUNvbnZlcnNhdGlvbih1c2VybmFtZSk7XHJcblxyXG4gICAgICAgICAgLy8gU2VuZCBkZWxldGUgZXZlbnQgdG8gcmVjaXBpZW50IHZpYSBXZWJTb2NrZXRcclxuICAgICAgICAgIHdzTWFuYWdlci5zZW5kRGVsZXRlQ29udmVyc2F0aW9uKHVzZXJuYW1lKTtcclxuXHJcbiAgICAgICAgICAvLyBBbHNvIHRyeSB0byBkZWxldGUgb24gc2VydmVyXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBhcGkuZGVsZXRlQ29udmVyc2F0aW9uKHVzZXJuYW1lKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZGVsZXRlIGNvbnZlcnNhdGlvbiBvbiBzZXJ2ZXI6JywgZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfl5HvuI8gQ29udmVyc2F0aW9uIGRlbGV0ZWQgZm9yIGV2ZXJ5b25lOicsIHVzZXJuYW1lKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBjb252ZXJzYXRpb24gZm9yIGV2ZXJ5b25lOicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBoYW5kbGVSZW1vdGVEZWxldGVNZXNzYWdlOiAobWVzc2FnZUlkOiBudW1iZXIsIHNlbmRlclVzZXJuYW1lOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAvLyBIYW5kbGUgaW5jb21pbmcgZGVsZXRlIG1lc3NhZ2UgZXZlbnQgZnJvbSBhbm90aGVyIHVzZXJcclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzc2FnZXMgPSBuZXcgTWFwKGdldCgpLm1lc3NhZ2VzKTtcclxuICAgICAgICBjb25zdCBjb252TWVzc2FnZXMgPSBjdXJyZW50TWVzc2FnZXMuZ2V0KHNlbmRlclVzZXJuYW1lKSB8fCBbXTtcclxuICAgICAgICBjb25zdCB1cGRhdGVkTWVzc2FnZXMgPSBjb252TWVzc2FnZXMubWFwKG0gPT4ge1xyXG4gICAgICAgICAgaWYgKG0uaWQgPT09IG1lc3NhZ2VJZCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIC4uLm0sXHJcbiAgICAgICAgICAgICAgX2RlY3J5cHRlZENvbnRlbnQ6IG51bGwsXHJcbiAgICAgICAgICAgICAgZW5jcnlwdGVkX2NvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHsgZGVsZXRlZDogdHJ1ZSB9KSxcclxuICAgICAgICAgICAgICBtZXNzYWdlX3R5cGU6ICdkZWxldGVkJyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGN1cnJlbnRNZXNzYWdlcy5zZXQoc2VuZGVyVXNlcm5hbWUsIHVwZGF0ZWRNZXNzYWdlcyk7XHJcbiAgICAgICAgc2V0KHsgbWVzc2FnZXM6IGN1cnJlbnRNZXNzYWdlcyB9KTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIEluZGV4ZWREQlxyXG4gICAgICAgIGxvY2FsU3RvcmFnZU1hbmFnZXIubWFya01lc3NhZ2VBc0RlbGV0ZWQobWVzc2FnZUlkKS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+TqCBSZW1vdGUgbWVzc2FnZSBkZWxldGlvbiByZWNlaXZlZDonLCBtZXNzYWdlSWQpO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgaGFuZGxlUmVtb3RlRGVsZXRlQ29udmVyc2F0aW9uOiAoc2VuZGVyVXNlcm5hbWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIC8vIEhhbmRsZSBpbmNvbWluZyBkZWxldGUgY29udmVyc2F0aW9uIGV2ZW50IGZyb20gYW5vdGhlciB1c2VyXHJcbiAgICAgICAgY29uc3QgY3VycmVudE1lc3NhZ2VzID0gbmV3IE1hcChnZXQoKS5tZXNzYWdlcyk7XHJcbiAgICAgICAgY3VycmVudE1lc3NhZ2VzLmRlbGV0ZShzZW5kZXJVc2VybmFtZSk7XHJcbiAgICAgICAgc2V0KHsgbWVzc2FnZXM6IGN1cnJlbnRNZXNzYWdlcyB9KTtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGNvbnZlcnNhdGlvbiBmcm9tIGxpc3RcclxuICAgICAgICBjb25zdCBjb252ZXJzYXRpb25zID0gZ2V0KCkuY29udmVyc2F0aW9ucy5maWx0ZXIoYyA9PiBjLnVzZXJuYW1lICE9PSBzZW5kZXJVc2VybmFtZSk7XHJcbiAgICAgICAgc2V0KHsgY29udmVyc2F0aW9ucyB9KTtcclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgY3VycmVudCBjb252ZXJzYXRpb24gaWYgaXQgd2FzIHRoZSBkZWxldGVkIG9uZVxyXG4gICAgICAgIGlmIChnZXQoKS5jdXJyZW50Q29udmVyc2F0aW9uID09PSBzZW5kZXJVc2VybmFtZSkge1xyXG4gICAgICAgICAgc2V0KHsgY3VycmVudENvbnZlcnNhdGlvbjogbnVsbCB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlbGV0ZSBmcm9tIEluZGV4ZWREQlxyXG4gICAgICAgIGxvY2FsU3RvcmFnZU1hbmFnZXIuZGVsZXRlQ29udmVyc2F0aW9uKHNlbmRlclVzZXJuYW1lKS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+TqCBSZW1vdGUgY29udmVyc2F0aW9uIGRlbGV0aW9uIHJlY2VpdmVkOicsIHNlbmRlclVzZXJuYW1lKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vID09PT09PT09PT09PSBQZXJzaXN0ZW50IFN0b3JhZ2UgPT09PT09PT09PT09XHJcblxyXG4gICAgICBsb2FkUGVyc2lzdGVkRGF0YTogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+TgiBMb2FkaW5nIHBlcnNpc3RlZCBkYXRhIGZyb20gSW5kZXhlZERCLi4uJyk7XHJcblxyXG4gICAgICAgICAgLy8gTG9hZCBjb252ZXJzYXRpb25zXHJcbiAgICAgICAgICBjb25zdCBzdG9yZWRDb252ZXJzYXRpb25zID0gYXdhaXQgbG9jYWxTdG9yYWdlTWFuYWdlci5nZXRBbGxDb252ZXJzYXRpb25zKCk7XHJcbiAgICAgICAgICBpZiAoc3RvcmVkQ29udmVyc2F0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbnMgPSBzdG9yZWRDb252ZXJzYXRpb25zLm1hcChjb252ID0+ICh7XHJcbiAgICAgICAgICAgICAgdXNlcl9pZDogY29udi51c2VyX2lkLFxyXG4gICAgICAgICAgICAgIHVzZXJuYW1lOiBjb252LnVzZXJuYW1lLFxyXG4gICAgICAgICAgICAgIHB1YmxpY19rZXk6IGNvbnYucHVibGljX2tleSxcclxuICAgICAgICAgICAgICBpZGVudGl0eV9rZXk6IGNvbnYuaWRlbnRpdHlfa2V5LFxyXG4gICAgICAgICAgICAgIGxhc3RfbWVzc2FnZV90aW1lOiBjb252Lmxhc3RfbWVzc2FnZV90aW1lLFxyXG4gICAgICAgICAgICAgIGxhc3RfbWVzc2FnZV9wcmV2aWV3OiBjb252Lmxhc3RfbWVzc2FnZV9wcmV2aWV3LFxyXG4gICAgICAgICAgICAgIHVucmVhZF9jb3VudDogY29udi51bnJlYWRfY291bnQsXHJcbiAgICAgICAgICAgICAgaXNfb25saW5lOiBjb252LmlzX29ubGluZVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHNldCh7IGNvbnZlcnNhdGlvbnMgfSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OCIExvYWRlZCAke2NvbnZlcnNhdGlvbnMubGVuZ3RofSBjb252ZXJzYXRpb25zIGZyb20gc3RvcmFnZWApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIExvYWQgY29udGFjdHNcclxuICAgICAgICAgIGNvbnN0IHN0b3JlZENvbnRhY3RzID0gYXdhaXQgbG9jYWxTdG9yYWdlTWFuYWdlci5nZXRBbGxDb250YWN0cygpO1xyXG4gICAgICAgICAgaWYgKHN0b3JlZENvbnRhY3RzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgY29udGFjdHMgPSBzdG9yZWRDb250YWN0cy5tYXAoY29udGFjdCA9PiAoe1xyXG4gICAgICAgICAgICAgIGlkOiBjb250YWN0LmlkLFxyXG4gICAgICAgICAgICAgIHVzZXJfaWQ6IGNvbnRhY3QudXNlcl9pZCxcclxuICAgICAgICAgICAgICBjb250YWN0X2lkOiBjb250YWN0LmNvbnRhY3RfaWQsXHJcbiAgICAgICAgICAgICAgY29udGFjdF91c2VybmFtZTogY29udGFjdC5jb250YWN0X3VzZXJuYW1lLFxyXG4gICAgICAgICAgICAgIGNvbnRhY3RfZW1haWw6IGNvbnRhY3QuY29udGFjdF9lbWFpbCxcclxuICAgICAgICAgICAgICBwdWJsaWNfa2V5OiBjb250YWN0LnB1YmxpY19rZXksXHJcbiAgICAgICAgICAgICAgaWRlbnRpdHlfa2V5OiBjb250YWN0LmlkZW50aXR5X2tleSxcclxuICAgICAgICAgICAgICBuaWNrbmFtZTogY29udGFjdC5uaWNrbmFtZSxcclxuICAgICAgICAgICAgICBpc19ibG9ja2VkOiBjb250YWN0LmlzX2Jsb2NrZWQsXHJcbiAgICAgICAgICAgICAgaXNfdmVyaWZpZWQ6IGNvbnRhY3QuaXNfdmVyaWZpZWQsXHJcbiAgICAgICAgICAgICAgYWRkZWRfYXQ6IGNvbnRhY3QuYWRkZWRfYXRcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBzZXQoeyBjb250YWN0cyB9KTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk4IgTG9hZGVkICR7Y29udGFjdHMubGVuZ3RofSBjb250YWN0cyBmcm9tIHN0b3JhZ2VgKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBMb2FkIG1lc3NhZ2VzIGZvciBhbGwgY29udmVyc2F0aW9uc1xyXG4gICAgICAgICAgY29uc3QgeyB1c2VyIH0gPSBnZXQoKTtcclxuICAgICAgICAgIGlmICh1c2VyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnYgb2Ygc3RvcmVkQ29udmVyc2F0aW9ucykge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHN0b3JlZE1lc3NhZ2VzID0gYXdhaXQgbG9jYWxTdG9yYWdlTWFuYWdlci5nZXRDb252ZXJzYXRpb25NZXNzYWdlcyhcclxuICAgICAgICAgICAgICAgIGNvbnYudXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgICB1c2VyLnVzZXJuYW1lLFxyXG4gICAgICAgICAgICAgICAgNTBcclxuICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoc3RvcmVkTWVzc2FnZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBzdG9yZWRNZXNzYWdlcy5tYXAobXNnID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgIGlkOiBtc2cuaWQsXHJcbiAgICAgICAgICAgICAgICAgIHNlbmRlcl9pZDogbXNnLnNlbmRlcl9pZCxcclxuICAgICAgICAgICAgICAgICAgc2VuZGVyX3VzZXJuYW1lOiBtc2cuc2VuZGVyX3VzZXJuYW1lLFxyXG4gICAgICAgICAgICAgICAgICByZWNpcGllbnRfaWQ6IG1zZy5yZWNpcGllbnRfaWQsXHJcbiAgICAgICAgICAgICAgICAgIHJlY2lwaWVudF91c2VybmFtZTogbXNnLnJlY2lwaWVudF91c2VybmFtZSxcclxuICAgICAgICAgICAgICAgICAgZW5jcnlwdGVkX2NvbnRlbnQ6IG1zZy5lbmNyeXB0ZWRfY29udGVudCxcclxuICAgICAgICAgICAgICAgICAgZW5jcnlwdGVkX2tleTogbXNnLmVuY3J5cHRlZF9rZXksXHJcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VfdHlwZTogbXNnLm1lc3NhZ2VfdHlwZSxcclxuICAgICAgICAgICAgICAgICAgc3RhdHVzOiBtc2cuc3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBtc2cuY3JlYXRlZF9hdCxcclxuICAgICAgICAgICAgICAgICAgZGVsaXZlcmVkX2F0OiBtc2cuZGVsaXZlcmVkX2F0LFxyXG4gICAgICAgICAgICAgICAgICByZWFkX2F0OiBtc2cucmVhZF9hdCxcclxuICAgICAgICAgICAgICAgICAgZXhwaXJ5X3R5cGU6IG1zZy5leHBpcnlfdHlwZSxcclxuICAgICAgICAgICAgICAgICAgZXhwaXJlc19hdDogbXNnLmV4cGlyZXNfYXQsXHJcbiAgICAgICAgICAgICAgICAgIGZpbGVfbWV0YWRhdGE6IG1zZy5maWxlX21ldGFkYXRhXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlc01hcC5zZXQoY29udi51c2VybmFtZSwgbWVzc2FnZXMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXQoeyBtZXNzYWdlczogbWVzc2FnZXNNYXAgfSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OCIExvYWRlZCBtZXNzYWdlcyBmb3IgJHttZXNzYWdlc01hcC5zaXplfSBjb252ZXJzYXRpb25zYCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIGxvYWQgcGVyc2lzdGVkIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIHN5bmNXaXRoU2VydmVyOiBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFN5bmNpbmcgd2l0aCBzZXJ2ZXIuLi4nKTtcclxuXHJcbiAgICAgICAgICAvLyBMb2FkIGZyZXNoIGRhdGEgZnJvbSBzZXJ2ZXJcclxuICAgICAgICAgIGF3YWl0IGdldCgpLmxvYWRDb250YWN0cygpO1xyXG4gICAgICAgICAgYXdhaXQgZ2V0KCkubG9hZENvbnZlcnNhdGlvbnMoKTtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgYWxsIGNvbnZlcnNhdGlvbnMgd2l0aCBtZXNzYWdlcyBmcm9tIHNlcnZlclxyXG4gICAgICAgICAgY29uc3QgYWxsQ29udmVyc2F0aW9uc0RhdGEgPSBhd2FpdCBhcGkuZ2V0QWxsQ29udmVyc2F0aW9uc1dpdGhNZXNzYWdlcygpO1xyXG5cclxuICAgICAgICAgIC8vIFVwZGF0ZSBsb2NhbCBzdG9yYWdlIHdpdGggc2VydmVyIGRhdGFcclxuICAgICAgICAgIGNvbnN0IHsgdXNlciwgY29udGFjdHMsIGNvbnZlcnNhdGlvbnMgfSA9IGdldCgpO1xyXG4gICAgICAgICAgaWYgKHVzZXIpIHtcclxuICAgICAgICAgICAgLy8gU2F2ZSBjb252ZXJzYXRpb25zIHRvIEluZGV4ZWREQlxyXG4gICAgICAgICAgICBjb25zdCBzdG9yZWRDb252ZXJzYXRpb25zOiBTdG9yZWRDb252ZXJzYXRpb25bXSA9IGNvbnZlcnNhdGlvbnMubWFwKGNvbnYgPT4gKHtcclxuICAgICAgICAgICAgICB1c2VybmFtZTogY29udi51c2VybmFtZSxcclxuICAgICAgICAgICAgICB1c2VyX2lkOiBjb252LnVzZXJfaWQsXHJcbiAgICAgICAgICAgICAgcHVibGljX2tleTogY29udi5wdWJsaWNfa2V5LFxyXG4gICAgICAgICAgICAgIGlkZW50aXR5X2tleTogY29udi5pZGVudGl0eV9rZXksXHJcbiAgICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3RpbWU6IGNvbnYubGFzdF9tZXNzYWdlX3RpbWUsXHJcbiAgICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3ByZXZpZXc6IGNvbnYubGFzdF9tZXNzYWdlX3ByZXZpZXcsXHJcbiAgICAgICAgICAgICAgdW5yZWFkX2NvdW50OiBjb252LnVucmVhZF9jb3VudCxcclxuICAgICAgICAgICAgICBpc19vbmxpbmU6IGNvbnYuaXNfb25saW5lXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgYXdhaXQgbG9jYWxTdG9yYWdlTWFuYWdlci5zYXZlQ29udmVyc2F0aW9ucyhzdG9yZWRDb252ZXJzYXRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNhdmUgY29udGFjdHMgdG8gSW5kZXhlZERCXHJcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZENvbnRhY3RzOiBTdG9yZWRDb250YWN0W10gPSBjb250YWN0cy5tYXAoY29udGFjdCA9PiAoe1xyXG4gICAgICAgICAgICAgIGlkOiBjb250YWN0LmlkLFxyXG4gICAgICAgICAgICAgIHVzZXJfaWQ6IGNvbnRhY3QudXNlcl9pZCxcclxuICAgICAgICAgICAgICBjb250YWN0X2lkOiBjb250YWN0LmNvbnRhY3RfaWQsXHJcbiAgICAgICAgICAgICAgY29udGFjdF91c2VybmFtZTogY29udGFjdC5jb250YWN0X3VzZXJuYW1lLFxyXG4gICAgICAgICAgICAgIGNvbnRhY3RfZW1haWw6IGNvbnRhY3QuY29udGFjdF9lbWFpbCxcclxuICAgICAgICAgICAgICBwdWJsaWNfa2V5OiBjb250YWN0LnB1YmxpY19rZXksXHJcbiAgICAgICAgICAgICAgaWRlbnRpdHlfa2V5OiBjb250YWN0LmlkZW50aXR5X2tleSxcclxuICAgICAgICAgICAgICBuaWNrbmFtZTogY29udGFjdC5uaWNrbmFtZSxcclxuICAgICAgICAgICAgICBpc19ibG9ja2VkOiBjb250YWN0LmlzX2Jsb2NrZWQsXHJcbiAgICAgICAgICAgICAgaXNfdmVyaWZpZWQ6IGNvbnRhY3QuaXNfdmVyaWZpZWQsXHJcbiAgICAgICAgICAgICAgYWRkZWRfYXQ6IGNvbnRhY3QuYWRkZWRfYXRcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBhd2FpdCBsb2NhbFN0b3JhZ2VNYW5hZ2VyLnNhdmVDb250YWN0cyhzdG9yZWRDb250YWN0cyk7XHJcblxyXG4gICAgICAgICAgICAvLyBTYXZlIG1lc3NhZ2VzIHRvIEluZGV4ZWREQlxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFt1c2VybmFtZSwgbWVzc2FnZXNdIG9mIE9iamVjdC5lbnRyaWVzKGFsbENvbnZlcnNhdGlvbnNEYXRhKSkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHN0b3JlZE1lc3NhZ2VzOiBTdG9yZWRNZXNzYWdlW10gPSAobWVzc2FnZXMgYXMgTWVzc2FnZVtdKS5tYXAobXNnID0+ICh7XHJcbiAgICAgICAgICAgICAgICBpZDogbXNnLmlkLFxyXG4gICAgICAgICAgICAgICAgc2VuZGVyX2lkOiBtc2cuc2VuZGVyX2lkLFxyXG4gICAgICAgICAgICAgICAgc2VuZGVyX3VzZXJuYW1lOiBtc2cuc2VuZGVyX3VzZXJuYW1lLFxyXG4gICAgICAgICAgICAgICAgcmVjaXBpZW50X2lkOiBtc2cucmVjaXBpZW50X2lkLFxyXG4gICAgICAgICAgICAgICAgcmVjaXBpZW50X3VzZXJuYW1lOiBtc2cucmVjaXBpZW50X3VzZXJuYW1lLFxyXG4gICAgICAgICAgICAgICAgZW5jcnlwdGVkX2NvbnRlbnQ6IG1zZy5lbmNyeXB0ZWRfY29udGVudCxcclxuICAgICAgICAgICAgICAgIGVuY3J5cHRlZF9rZXk6IG1zZy5lbmNyeXB0ZWRfa2V5LFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZV90eXBlOiBtc2cubWVzc2FnZV90eXBlLFxyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBtc2cuc3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogbXNnLmNyZWF0ZWRfYXQsXHJcbiAgICAgICAgICAgICAgICBkZWxpdmVyZWRfYXQ6IG1zZy5kZWxpdmVyZWRfYXQsXHJcbiAgICAgICAgICAgICAgICByZWFkX2F0OiBtc2cucmVhZF9hdCxcclxuICAgICAgICAgICAgICAgIGV4cGlyeV90eXBlOiBtc2cuZXhwaXJ5X3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBpcmVzX2F0OiBtc2cuZXhwaXJlc19hdCxcclxuICAgICAgICAgICAgICAgIGZpbGVfbWV0YWRhdGE6IG1zZy5maWxlX21ldGFkYXRhXHJcbiAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmFnZU1hbmFnZXIuc2F2ZU1lc3NhZ2VzKHN0b3JlZE1lc3NhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIGluLW1lbW9yeSBzdGF0ZVxyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlc01hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBbdXNlcm5hbWUsIG1lc3NhZ2VzXSBvZiBPYmplY3QuZW50cmllcyhhbGxDb252ZXJzYXRpb25zRGF0YSkpIHtcclxuICAgICAgICAgICAgICBtZXNzYWdlc01hcC5zZXQodXNlcm5hbWUsIG1lc3NhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXQoeyBtZXNzYWdlczogbWVzc2FnZXNNYXAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFN5bmMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgU3luYyBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIHBlcnNpc3RNZXNzYWdlOiBhc3luYyAobWVzc2FnZTogTWVzc2FnZSkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBzdG9yZWRNZXNzYWdlOiBTdG9yZWRNZXNzYWdlID0ge1xyXG4gICAgICAgICAgICBpZDogbWVzc2FnZS5pZCxcclxuICAgICAgICAgICAgc2VuZGVyX2lkOiBtZXNzYWdlLnNlbmRlcl9pZCxcclxuICAgICAgICAgICAgc2VuZGVyX3VzZXJuYW1lOiBtZXNzYWdlLnNlbmRlcl91c2VybmFtZSxcclxuICAgICAgICAgICAgcmVjaXBpZW50X2lkOiBtZXNzYWdlLnJlY2lwaWVudF9pZCxcclxuICAgICAgICAgICAgcmVjaXBpZW50X3VzZXJuYW1lOiBtZXNzYWdlLnJlY2lwaWVudF91c2VybmFtZSxcclxuICAgICAgICAgICAgZW5jcnlwdGVkX2NvbnRlbnQ6IG1lc3NhZ2UuZW5jcnlwdGVkX2NvbnRlbnQsXHJcbiAgICAgICAgICAgIGVuY3J5cHRlZF9rZXk6IG1lc3NhZ2UuZW5jcnlwdGVkX2tleSxcclxuICAgICAgICAgICAgbWVzc2FnZV90eXBlOiBtZXNzYWdlLm1lc3NhZ2VfdHlwZSxcclxuICAgICAgICAgICAgc3RhdHVzOiBtZXNzYWdlLnN0YXR1cyxcclxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbWVzc2FnZS5jcmVhdGVkX2F0LFxyXG4gICAgICAgICAgICBkZWxpdmVyZWRfYXQ6IG1lc3NhZ2UuZGVsaXZlcmVkX2F0LFxyXG4gICAgICAgICAgICByZWFkX2F0OiBtZXNzYWdlLnJlYWRfYXQsXHJcbiAgICAgICAgICAgIGV4cGlyeV90eXBlOiBtZXNzYWdlLmV4cGlyeV90eXBlLFxyXG4gICAgICAgICAgICBleHBpcmVzX2F0OiBtZXNzYWdlLmV4cGlyZXNfYXQsXHJcbiAgICAgICAgICAgIGZpbGVfbWV0YWRhdGE6IG1lc3NhZ2UuZmlsZV9tZXRhZGF0YVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmFnZU1hbmFnZXIuc2F2ZU1lc3NhZ2Uoc3RvcmVkTWVzc2FnZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gcGVyc2lzdCBtZXNzYWdlOicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBwZXJzaXN0Q29udmVyc2F0aW9uOiBhc3luYyAoY29udmVyc2F0aW9uOiBDb252ZXJzYXRpb24pID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3Qgc3RvcmVkQ29udmVyc2F0aW9uOiBTdG9yZWRDb252ZXJzYXRpb24gPSB7XHJcbiAgICAgICAgICAgIHVzZXJuYW1lOiBjb252ZXJzYXRpb24udXNlcm5hbWUsXHJcbiAgICAgICAgICAgIHVzZXJfaWQ6IGNvbnZlcnNhdGlvbi51c2VyX2lkLFxyXG4gICAgICAgICAgICBwdWJsaWNfa2V5OiBjb252ZXJzYXRpb24ucHVibGljX2tleSxcclxuICAgICAgICAgICAgaWRlbnRpdHlfa2V5OiBjb252ZXJzYXRpb24uaWRlbnRpdHlfa2V5LFxyXG4gICAgICAgICAgICBsYXN0X21lc3NhZ2VfdGltZTogY29udmVyc2F0aW9uLmxhc3RfbWVzc2FnZV90aW1lLFxyXG4gICAgICAgICAgICBsYXN0X21lc3NhZ2VfcHJldmlldzogY29udmVyc2F0aW9uLmxhc3RfbWVzc2FnZV9wcmV2aWV3LFxyXG4gICAgICAgICAgICB1bnJlYWRfY291bnQ6IGNvbnZlcnNhdGlvbi51bnJlYWRfY291bnQsXHJcbiAgICAgICAgICAgIGlzX29ubGluZTogY29udmVyc2F0aW9uLmlzX29ubGluZVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmFnZU1hbmFnZXIuc2F2ZUNvbnZlcnNhdGlvbihzdG9yZWRDb252ZXJzYXRpb24pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIHBlcnNpc3QgY29udmVyc2F0aW9uOicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBsb2FkQWxsQ29udmVyc2F0aW9uSGlzdG9yeTogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCB7IGNvbnZlcnNhdGlvbnMgfSA9IGdldCgpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYPCfk5ogTG9hZGluZyBoaXN0b3J5IGZvciAke2NvbnZlcnNhdGlvbnMubGVuZ3RofSBjb252ZXJzYXRpb25zLi4uYCk7XHJcblxyXG4gICAgICAgICAgZm9yIChjb25zdCBjb252IG9mIGNvbnZlcnNhdGlvbnMpIHtcclxuICAgICAgICAgICAgYXdhaXQgZ2V0KCkubG9hZE1lc3NhZ2VzKGNvbnYudXNlcm5hbWUpO1xyXG4gICAgICAgICAgICAvLyBTbWFsbCBkZWxheSB0byBwcmV2ZW50IG92ZXJ3aGVsbWluZyB0aGUgc2VydmVyXHJcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIEFsbCBjb252ZXJzYXRpb24gaGlzdG9yeSBsb2FkZWQnKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBsb2FkIGNvbnZlcnNhdGlvbiBoaXN0b3J5OicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICB9KSxcclxuICAgIHtcclxuICAgICAgbmFtZTogJ2NpcGhlcmxpbmstc3RvcmUnLFxyXG4gICAgICBwYXJ0aWFsaXplOiAoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgLy8gT25seSBwZXJzaXN0IG5vbi1zZW5zaXRpdmUgZGF0YVxyXG4gICAgICAgIGN1cnJlbnRDb252ZXJzYXRpb246IHN0YXRlLmN1cnJlbnRDb252ZXJzYXRpb24sXHJcbiAgICAgIH0pLFxyXG4gICAgfVxyXG4gIClcclxuKTtcclxuXHJcbi8vIFNldHVwIFdlYlNvY2tldCBtZXNzYWdlIGhhbmRsZXJzXHJcbmZ1bmN0aW9uIHNldHVwV2ViU29ja2V0SGFuZGxlcnMoZ2V0OiAoKSA9PiBBcHBTdGF0ZSwgc2V0OiAoc3RhdGU6IFBhcnRpYWw8QXBwU3RhdGU+KSA9PiB2b2lkKSB7XHJcbiAgLy8gSGFuZGxlIGluY29taW5nIG1lc3NhZ2VzXHJcbiAgd3NNYW5hZ2VyLm9uKCdtZXNzYWdlJywgKGRhdGEpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKCfwn5OoIFJlY2VpdmVkIG1lc3NhZ2U6JywgZGF0YSk7XHJcblxyXG4gICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcclxuICAgIGNvbnN0IHNlbmRlclVzZXJuYW1lID0gZGF0YS5zZW5kZXJfdXNlcm5hbWU7XHJcblxyXG4gICAgLy8gQ3JlYXRlIG1lc3NhZ2Ugb2JqZWN0XHJcbiAgICBjb25zdCBtZXNzYWdlOiBNZXNzYWdlID0ge1xyXG4gICAgICBpZDogZGF0YS5tZXNzYWdlX2lkLFxyXG4gICAgICBzZW5kZXJfaWQ6IGRhdGEuc2VuZGVyX2lkLFxyXG4gICAgICBzZW5kZXJfdXNlcm5hbWU6IHNlbmRlclVzZXJuYW1lLFxyXG4gICAgICByZWNpcGllbnRfaWQ6IHN0YXRlLnVzZXI/LmlkIHx8IDAsXHJcbiAgICAgIHJlY2lwaWVudF91c2VybmFtZTogc3RhdGUudXNlcj8udXNlcm5hbWUgfHwgJycsXHJcbiAgICAgIGVuY3J5cHRlZF9jb250ZW50OiBkYXRhLmNvbnRlbnQgfHwgZGF0YS5lbmNyeXB0ZWRfY29udGVudCxcclxuICAgICAgZW5jcnlwdGVkX2tleTogZGF0YS5lbmNyeXB0ZWRfa2V5LFxyXG4gICAgICBtZXNzYWdlX3R5cGU6IGRhdGEubWVzc2FnZV90eXBlIHx8ICd0ZXh0JyxcclxuICAgICAgc3RhdHVzOiAnZGVsaXZlcmVkJyxcclxuICAgICAgZXhwaXJ5X3R5cGU6IGRhdGEuZXhwaXJ5X3R5cGUgfHwgJ25vbmUnLFxyXG4gICAgICBjcmVhdGVkX2F0OiBkYXRhLnRpbWVzdGFtcCxcclxuICAgIH07XHJcblxyXG4gICAgZ2V0KCkuYWRkSW5jb21pbmdNZXNzYWdlKG1lc3NhZ2UpO1xyXG5cclxuICAgIC8vIFNlbmQgZGVsaXZlcnkgcmVjZWlwdFxyXG4gICAgd3NNYW5hZ2VyLnNlbmREZWxpdmVyeVJlY2VpcHQoZGF0YS5tZXNzYWdlX2lkLCBkYXRhLnNlbmRlcl9pZCk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIEhhbmRsZSB0eXBpbmcgaW5kaWNhdG9yc1xyXG4gIHdzTWFuYWdlci5vbigndHlwaW5nJywgKGRhdGEpID0+IHtcclxuICAgIGdldCgpLnNldFVzZXJUeXBpbmcoZGF0YS5zZW5kZXJfdXNlcm5hbWUsIGRhdGEuaXNfdHlwaW5nKTtcclxuXHJcbiAgICAvLyBBdXRvLWNsZWFyIHR5cGluZyBhZnRlciAzIHNlY29uZHNcclxuICAgIGlmIChkYXRhLmlzX3R5cGluZykge1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBnZXQoKS5zZXRVc2VyVHlwaW5nKGRhdGEuc2VuZGVyX3VzZXJuYW1lLCBmYWxzZSk7XHJcbiAgICAgIH0sIDMwMDApO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBIYW5kbGUgcHJlc2VuY2UgdXBkYXRlc1xyXG4gIHdzTWFuYWdlci5vbigncHJlc2VuY2UnLCAoZGF0YSkgPT4ge1xyXG4gICAgZ2V0KCkuc2V0VXNlck9ubGluZShkYXRhLnVzZXJfaWQsIGRhdGEuaXNfb25saW5lKTtcclxuICB9KTtcclxuXHJcbiAgLy8gSGFuZGxlIG1lc3NhZ2Ugc2VudCBjb25maXJtYXRpb25zXHJcbiAgd3NNYW5hZ2VyLm9uKCdtZXNzYWdlX3NlbnQnLCAoZGF0YSkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ+KchSBNZXNzYWdlIHNlbnQgY29uZmlybWF0aW9uOicsIGRhdGEpO1xyXG4gIH0pO1xyXG5cclxuICAvLyBIYW5kbGUgcmVhZCByZWNlaXB0c1xyXG4gIHdzTWFuYWdlci5vbigncmVhZF9yZWNlaXB0JywgKGRhdGEpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKCfwn5GB77iPIFJlYWQgcmVjZWlwdDonLCBkYXRhKTtcclxuICAgIC8vIENvdWxkIHVwZGF0ZSBtZXNzYWdlIHN0YXR1cyBpbiBVSSBoZXJlXHJcbiAgfSk7XHJcblxyXG4gIC8vIEhhbmRsZSBkZWxpdmVyeSByZWNlaXB0c1xyXG4gIHdzTWFuYWdlci5vbignZGVsaXZlcnlfcmVjZWlwdCcsIChkYXRhKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+TrCBEZWxpdmVyeSByZWNlaXB0OicsIGRhdGEpO1xyXG4gICAgLy8gQ291bGQgdXBkYXRlIG1lc3NhZ2Ugc3RhdHVzIGluIFVJIGhlcmVcclxuICB9KTtcclxuXHJcbiAgLy8gSGFuZGxlIGNvbm5lY3Rpb24gY29uZmlybWF0aW9uXHJcbiAgd3NNYW5hZ2VyLm9uKCdjb25uZWN0ZWQnLCAoZGF0YSkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ+KchSBXZWJTb2NrZXQgY29ubmVjdGVkOicsIGRhdGEpO1xyXG4gIH0pO1xyXG5cclxuICAvLyBIYW5kbGUgZXJyb3JzXHJcbiAgd3NNYW5hZ2VyLm9uKCdlcnJvcicsIChkYXRhKSA9PiB7XHJcbiAgICBjb25zb2xlLmVycm9yKCfinYwgV2ViU29ja2V0IGVycm9yOicsIGRhdGEpO1xyXG4gIH0pO1xyXG5cclxuICAvLyBIYW5kbGUgcmVtb3RlIG1lc3NhZ2UgZGVsZXRpb25cclxuICB3c01hbmFnZXIub24oJ2RlbGV0ZV9tZXNzYWdlX3JlY2VpdmVkJywgKGRhdGEpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKCfwn5eR77iPIFJlbW90ZSBkZWxldGUgbWVzc2FnZSByZWNlaXZlZDonLCBkYXRhKTtcclxuICAgIGNvbnN0IG1lc3NhZ2VJZCA9IGRhdGEubWVzc2FnZV9pZCB8fCBkYXRhLmRhdGE/Lm1lc3NhZ2VfaWQ7XHJcbiAgICBjb25zdCBzZW5kZXJVc2VybmFtZSA9IGRhdGEuc2VuZGVyX3VzZXJuYW1lIHx8IGRhdGEuZGF0YT8uc2VuZGVyX3VzZXJuYW1lO1xyXG4gICAgaWYgKG1lc3NhZ2VJZCAmJiBzZW5kZXJVc2VybmFtZSkge1xyXG4gICAgICBnZXQoKS5oYW5kbGVSZW1vdGVEZWxldGVNZXNzYWdlKG1lc3NhZ2VJZCwgc2VuZGVyVXNlcm5hbWUpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBIYW5kbGUgcmVtb3RlIGNvbnZlcnNhdGlvbiBkZWxldGlvblxyXG4gIHdzTWFuYWdlci5vbignZGVsZXRlX2NvbnZlcnNhdGlvbl9yZWNlaXZlZCcsIChkYXRhKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+Xke+4jyBSZW1vdGUgZGVsZXRlIGNvbnZlcnNhdGlvbiByZWNlaXZlZDonLCBkYXRhKTtcclxuICAgIGNvbnN0IHNlbmRlclVzZXJuYW1lID0gZGF0YS5zZW5kZXJfdXNlcm5hbWUgfHwgZGF0YS5kYXRhPy5zZW5kZXJfdXNlcm5hbWU7XHJcbiAgICBpZiAoc2VuZGVyVXNlcm5hbWUpIHtcclxuICAgICAgZ2V0KCkuaGFuZGxlUmVtb3RlRGVsZXRlQ29udmVyc2F0aW9uKHNlbmRlclVzZXJuYW1lKTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuLy8gRXh0ZW5kIE1lc3NhZ2UgdHlwZSB0byBpbmNsdWRlIGRlY3J5cHRlZCBjb250ZW50IGZvciBsb2NhbCBkaXNwbGF5XHJcbmRlY2xhcmUgbW9kdWxlICcuL2FwaScge1xyXG4gIGludGVyZmFjZSBNZXNzYWdlIHtcclxuICAgIF9kZWNyeXB0ZWRDb250ZW50Pzogc3RyaW5nIHwgbnVsbDtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbImNyZWF0ZSIsInBlcnNpc3QiLCJhcGkiLCJnZW5lcmF0ZUtleVBhaXIiLCJnZW5lcmF0ZVNpZ25pbmdLZXlQYWlyIiwiZ2VuZXJhdGVLZXlCdW5kbGUiLCJLZXlTdG9yYWdlIiwiZW5jcnlwdE1lc3NhZ2UiLCJkZWNyeXB0TWVzc2FnZSIsInZlcmlmeUtleVBhaXIiLCJkZXJpdmVQdWJsaWNLZXlGcm9tUHJpdmF0ZSIsIndzTWFuYWdlciIsImxvY2FsU3RvcmFnZU1hbmFnZXIiLCJ1c2VTdG9yZSIsInNldCIsImdldCIsInVzZXIiLCJ0b2tlbiIsImlzQXV0aGVudGljYXRlZCIsImlzTG9hZGluZyIsImVycm9yIiwicHJpdmF0ZUtleSIsInB1YmxpY0tleSIsImlkZW50aXR5S2V5IiwiaWRlbnRpdHlQcml2YXRlS2V5IiwiY29udGFjdHMiLCJjb252ZXJzYXRpb25zIiwiY3VycmVudENvbnZlcnNhdGlvbiIsIm1lc3NhZ2VzIiwiTWFwIiwib25saW5lVXNlcnMiLCJTZXQiLCJ0eXBpbmdVc2VycyIsImNhbGxIaXN0b3J5IiwibG9naW4iLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwia2V5cyIsInJlc3BvbnNlIiwiZ2V0Q3VycmVudFVzZXIiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiYWNjZXNzX3Rva2VuIiwibG9hZCIsIm5lZWRzVXBsb2FkIiwicHVibGljX2tleSIsImtleU1pc21hdGNoIiwiaXNDb25zaXN0ZW50IiwidmVyaWZ5S2V5Q29uc2lzdGVuY3kiLCJjb25zb2xlIiwid2FybiIsImxvZyIsImJ1bmRsZSIsInByaXZhdGVLZXlzIiwic2lnbmVkUHJla2V5UHJpdmF0ZSIsInNpZ25lZFByZWtleSIsInNpZ25lZFByZWtleVNpZ25hdHVyZSIsImlkZW50aXR5UHJpdmF0ZSIsIm9uZVRpbWVQcmVrZXlzIiwic2F2ZSIsImlzVmFsaWRQYWlyIiwiY29ycmVjdFB1YmxpY0tleSIsInN1YnN0cmluZyIsInB1YmxpY0tleVRvVXBsb2FkIiwidXBsb2FkS2V5cyIsImlkZW50aXR5X2tleSIsInNpZ25lZF9wcmVrZXkiLCJzaWduZWRfcHJla2V5X3NpZ25hdHVyZSIsIm9uZV90aW1lX3ByZWtleXMiLCJzZXJ2ZXJOb3dIYXMiLCJ1cGxvYWRFcnJvciIsImRhdGEiLCJsb2NhbFNlcnZlck1hdGNoIiwibG9jYWxQdWJLZXkiLCJzZXJ2ZXJQdWJLZXkiLCJsb2NhbFByaXZLZXkiLCJMT0NBTF9NQVRDSEVTX1NFUlZFUiIsImUiLCJjb25uZWN0IiwiaWQiLCJ0b1N0cmluZyIsIndpbmRvdyIsIl93c0hhbmRsZXJzUmVnaXN0ZXJlZCIsInNldHVwV2ViU29ja2V0SGFuZGxlcnMiLCJkZXRhaWwiLCJyZWdpc3RlciIsImVtYWlsIiwiZGV2aWNlSWQiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInNsaWNlIiwibG9nb3V0IiwiZGlzY29ubmVjdCIsInJlbW92ZUl0ZW0iLCJzZXRUb2tlbiIsImluaXRpYWxpemVXZWJTb2NrZXQiLCJsb2FkU3RvcmVkQXV0aCIsImdldEl0ZW0iLCJsb2FkUGVyc2lzdGVkRGF0YSIsInN5bmNXaXRoU2VydmVyIiwiY2F0Y2giLCJnZW5lcmF0ZUFuZFVwbG9hZEtleXMiLCJrZXlQYWlyIiwic2lnbmluZ1BhaXIiLCJsb2FkU3RvcmVkS2V5cyIsImxvYWRDb250YWN0cyIsImdldENvbnRhY3RzIiwibG9hZENvbnZlcnNhdGlvbnMiLCJnZXRDb252ZXJzYXRpb25zIiwibG9hZE1lc3NhZ2VzIiwiZ2V0Q29udmVyc2F0aW9uIiwibXNnIiwiZW5jcnlwdGVkX2NvbnRlbnQiLCJfZGVjcnlwdGVkQ29udGVudCIsImVuY3J5cHRlZERhdGEiLCJKU09OIiwicGFyc2UiLCJmYWxsYmFja1B1YmxpY0tleSIsInNlbmRlcl91c2VybmFtZSIsImZpbmQiLCJjIiwiY29udGFjdF91c2VybmFtZSIsInJlY2lwaWVudF91c2VybmFtZSIsImNvbnRhY3QiLCJkZWNyeXB0ZWQiLCJuZXdNZXNzYWdlcyIsInNlbmRNZXNzYWdlIiwicmVjaXBpZW50VXNlcm5hbWUiLCJjb250ZW50IiwibWVzc2FnZVR5cGUiLCJmaWxlRGF0YSIsImhhc1ByaXZhdGVLZXkiLCJoYXNQdWJsaWNLZXkiLCJoYXNVc2VyIiwicmVjaXBpZW50UHVibGljS2V5Iiwia2V5RGF0YSIsImdldFB1YmxpY0tleSIsIkVycm9yIiwicmVjaXBpZW50UHViS2V5Iiwic2VuZGVyUHJpdktleSIsInNlbmRlclB1YktleSIsImVuY3J5cHRlZCIsImVuY3J5cHRlZENvbnRlbnQiLCJzdHJpbmdpZnkiLCJjdXJyZW50TWVzc2FnZXMiLCJvcHRpbWlzdGljSWQiLCJvcHRpbWlzdGljTWVzc2FnZSIsInNlbmRlcl9pZCIsInJlY2lwaWVudF9pZCIsIm1lc3NhZ2VfdHlwZSIsInN0YXR1cyIsImV4cGlyeV90eXBlIiwiY3JlYXRlZF9hdCIsInRvSVNPU3RyaW5nIiwic2VudE1lc3NhZ2UiLCJ1bmRlZmluZWQiLCJ1cGRhdGVkTWVzc2FnZXMiLCJ1c2VyTWVzc2FnZXMiLCJpbmRleCIsImZpbmRJbmRleCIsIm0iLCJwdXNoIiwicGVyc2lzdE1lc3NhZ2UiLCJzdGF0ZUFmdGVyU2VuZCIsImV4aXN0aW5nQ29udkluZGV4IiwiY29udiIsInVwZGF0ZWRDb252IiwibGFzdF9tZXNzYWdlX3RpbWUiLCJsYXN0X21lc3NhZ2VfcHJldmlldyIsInBlcnNpc3RDb252ZXJzYXRpb24iLCJzZXRDdXJyZW50Q29udmVyc2F0aW9uIiwic3RhdGUiLCJuZXdUeXBpbmdVc2VycyIsImRlbGV0ZSIsImFkZENvbnRhY3QiLCJleGlzdGluZ0NvbnYiLCJuZXdDb252ZXJzYXRpb24iLCJ1c2VyX2lkIiwiY29udGFjdF9pZCIsInVucmVhZF9jb3VudCIsImlzX29ubGluZSIsInNlYXJjaFVzZXJzIiwicXVlcnkiLCJhZGRJbmNvbWluZ01lc3NhZ2UiLCJtZXNzYWdlIiwic2VuZGVyVXNlcm5hbWUiLCJleGlzdHMiLCJzb21lIiwiY29udkluZGV4IiwiZXJyIiwibG9hZENhbGxIaXN0b3J5IiwiaGlzdG9yeSIsImdldENhbGxIaXN0b3J5Iiwic2V0VXNlck9ubGluZSIsInVzZXJJZCIsImlzT25saW5lIiwibmV3T25saW5lVXNlcnMiLCJhZGQiLCJzZXRVc2VyVHlwaW5nIiwiaXNUeXBpbmciLCJjbGVhckVycm9yIiwiZGVsZXRlTWVzc2FnZUZvck1lIiwibWVzc2FnZUlkIiwiY29udmVyc2F0aW9uVXNlcm5hbWUiLCJjb252TWVzc2FnZXMiLCJmaWx0ZXIiLCJkZWxldGVNZXNzYWdlIiwiZGVsZXRlTWVzc2FnZUZvckV2ZXJ5b25lIiwibWFwIiwiZGVsZXRlZCIsIm1hcmtNZXNzYWdlQXNEZWxldGVkIiwic2VuZERlbGV0ZU1lc3NhZ2UiLCJjbGVhckNoYXQiLCJjbGVhckNvbnZlcnNhdGlvbk1lc3NhZ2VzIiwiZGVsZXRlQ29udmVyc2F0aW9uRm9yRXZlcnlvbmUiLCJkZWxldGVDb252ZXJzYXRpb24iLCJzZW5kRGVsZXRlQ29udmVyc2F0aW9uIiwiaGFuZGxlUmVtb3RlRGVsZXRlTWVzc2FnZSIsImhhbmRsZVJlbW90ZURlbGV0ZUNvbnZlcnNhdGlvbiIsInN0b3JlZENvbnZlcnNhdGlvbnMiLCJnZXRBbGxDb252ZXJzYXRpb25zIiwibGVuZ3RoIiwic3RvcmVkQ29udGFjdHMiLCJnZXRBbGxDb250YWN0cyIsImNvbnRhY3RfZW1haWwiLCJuaWNrbmFtZSIsImlzX2Jsb2NrZWQiLCJpc192ZXJpZmllZCIsImFkZGVkX2F0IiwibWVzc2FnZXNNYXAiLCJzdG9yZWRNZXNzYWdlcyIsImdldENvbnZlcnNhdGlvbk1lc3NhZ2VzIiwiZW5jcnlwdGVkX2tleSIsImRlbGl2ZXJlZF9hdCIsInJlYWRfYXQiLCJleHBpcmVzX2F0IiwiZmlsZV9tZXRhZGF0YSIsInNpemUiLCJhbGxDb252ZXJzYXRpb25zRGF0YSIsImdldEFsbENvbnZlcnNhdGlvbnNXaXRoTWVzc2FnZXMiLCJzYXZlQ29udmVyc2F0aW9ucyIsInNhdmVDb250YWN0cyIsIk9iamVjdCIsImVudHJpZXMiLCJzYXZlTWVzc2FnZXMiLCJzdG9yZWRNZXNzYWdlIiwic2F2ZU1lc3NhZ2UiLCJjb252ZXJzYXRpb24iLCJzdG9yZWRDb252ZXJzYXRpb24iLCJzYXZlQ29udmVyc2F0aW9uIiwibG9hZEFsbENvbnZlcnNhdGlvbkhpc3RvcnkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJuYW1lIiwicGFydGlhbGl6ZSIsIm9uIiwibWVzc2FnZV9pZCIsInRpbWVzdGFtcCIsInNlbmREZWxpdmVyeVJlY2VpcHQiLCJpc190eXBpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/store.ts\n"));

/***/ })

});