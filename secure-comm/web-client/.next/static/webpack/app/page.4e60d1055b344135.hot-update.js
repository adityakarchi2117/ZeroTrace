"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/store.ts":
/*!**************************!*\
  !*** ./src/lib/store.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useStore: function() { return /* binding */ useStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"(app-pages-browser)/./src/lib/api.ts\");\n/* harmony import */ var _crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crypto */ \"(app-pages-browser)/./src/lib/crypto.ts\");\n/* harmony import */ var _websocket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./websocket */ \"(app-pages-browser)/./src/lib/websocket.ts\");\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./storage */ \"(app-pages-browser)/./src/lib/storage.ts\");\n/* harmony import */ var _themeSync__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./themeSync */ \"(app-pages-browser)/./src/lib/themeSync.ts\");\n/**\r\n * CipherLink Global State Store\r\n * Uses Zustand for state management\r\n */ \n\n\n\n\n\n\nconst useStore = (0,zustand__WEBPACK_IMPORTED_MODULE_5__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_6__.persist)((set, get)=>({\n        // Initial state\n        user: null,\n        token: null,\n        isAuthenticated: false,\n        isLoading: false,\n        error: null,\n        privateKey: null,\n        publicKey: null,\n        identityKey: null,\n        identityPrivateKey: null,\n        contacts: [],\n        conversations: [],\n        currentConversation: null,\n        messages: new Map(),\n        onlineUsers: new Set(),\n        typingUsers: new Map(),\n        callHistory: [],\n        // ============ Auth Actions ============\n        login: async (username, password)=>{\n            set({\n                isLoading: true,\n                error: null\n            });\n            try {\n                var _keys_publicKey, _user_public_key, _keys_privateKey;\n                const response = await _api__WEBPACK_IMPORTED_MODULE_0__.api.login(username, password);\n                let user = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getCurrentUser();\n                // Store token\n                localStorage.setItem(\"cipherlink_token\", response.access_token);\n                localStorage.setItem(\"cipherlink_username\", username);\n                // Load or generate keys\n                let keys = _crypto__WEBPACK_IMPORTED_MODULE_1__.KeyStorage.load(username);\n                let needsUpload = !user.public_key;\n                let keyMismatch = false;\n                // Verify key consistency if both local and server keys exist\n                if (keys && user.public_key) {\n                    const isConsistent = _crypto__WEBPACK_IMPORTED_MODULE_1__.KeyStorage.verifyKeyConsistency(username, user.public_key);\n                    if (!isConsistent) {\n                        console.warn(\"⚠️ Key mismatch detected! Local key differs from server key.\");\n                        console.warn(\"This may happen if you logged in from a different device.\");\n                        console.warn(\"Old messages encrypted with the server key may not decrypt correctly.\");\n                        keyMismatch = true;\n                    // Keep local keys but mark the mismatch\n                    }\n                }\n                if (!keys) {\n                    // Generate new proper key bundle\n                    console.log(\"\\uD83D\\uDD10 Generating new key bundle...\");\n                    const { bundle, privateKeys } = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.generateKeyBundle)(5);\n                    keys = {\n                        privateKey: privateKeys.signedPrekeyPrivate,\n                        publicKey: bundle.publicKey,\n                        identityKey: bundle.identityKey,\n                        signedPrekey: bundle.signedPrekey,\n                        signedPrekeySignature: bundle.signedPrekeySignature,\n                        identityPrivateKey: privateKeys.identityPrivate,\n                        oneTimePrekeys: bundle.oneTimePrekeys\n                    };\n                    _crypto__WEBPACK_IMPORTED_MODULE_1__.KeyStorage.save(username, keys);\n                    needsUpload = true;\n                    console.log(\"✅ Key bundle generated\");\n                }\n                // CRITICAL: Verify that privateKey and publicKey form a valid pair\n                if (keys.privateKey && keys.publicKey) {\n                    const isValidPair = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.verifyKeyPair)(keys.privateKey, keys.publicKey);\n                    console.log(\"\\uD83D\\uDD11 Key pair verification:\", isValidPair ? \"✅ VALID\" : \"❌ INVALID\");\n                    if (!isValidPair) {\n                        var _keys_publicKey1;\n                        // The stored public key doesn't match the private key!\n                        // Derive the correct public key from the private key\n                        console.warn(\"⚠️ Key pair mismatch detected! Deriving correct public key...\");\n                        const correctPublicKey = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.derivePublicKeyFromPrivate)(keys.privateKey);\n                        console.log(\"\\uD83D\\uDD27 Original publicKey:\", (_keys_publicKey1 = keys.publicKey) === null || _keys_publicKey1 === void 0 ? void 0 : _keys_publicKey1.substring(0, 30));\n                        console.log(\"\\uD83D\\uDD27 Derived publicKey:\", correctPublicKey === null || correctPublicKey === void 0 ? void 0 : correctPublicKey.substring(0, 30));\n                        // Update the keys with the correct public key\n                        keys.publicKey = correctPublicKey;\n                        _crypto__WEBPACK_IMPORTED_MODULE_1__.KeyStorage.save(username, keys);\n                        needsUpload = true; // Need to upload the corrected key\n                        console.log(\"✅ Key pair corrected and saved\");\n                    }\n                }\n                // Upload keys if not on server OR if we corrected the key pair\n                if (needsUpload && keys) {\n                    var _keys_publicKey2;\n                    console.log(\"\\uD83D\\uDCE4 Uploading keys to server...\", {\n                        publicKeyToUpload: (_keys_publicKey2 = keys.publicKey) === null || _keys_publicKey2 === void 0 ? void 0 : _keys_publicKey2.substring(0, 30)\n                    });\n                    try {\n                        var _user_public_key1;\n                        await _api__WEBPACK_IMPORTED_MODULE_0__.api.uploadKeys({\n                            public_key: keys.publicKey || \"\",\n                            identity_key: keys.identityKey || \"\",\n                            signed_prekey: keys.signedPrekey || keys.publicKey || \"\",\n                            signed_prekey_signature: keys.signedPrekeySignature || \"\",\n                            one_time_prekeys: keys.oneTimePrekeys || []\n                        });\n                        // Refresh user to get updated public_key\n                        user = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getCurrentUser();\n                        console.log(\"✅ Keys uploaded successfully!\", {\n                            serverNowHas: (_user_public_key1 = user.public_key) === null || _user_public_key1 === void 0 ? void 0 : _user_public_key1.substring(0, 30)\n                        });\n                    } catch (uploadError) {\n                        var _uploadError_response;\n                        console.error(\"❌ Failed to upload keys:\", (uploadError === null || uploadError === void 0 ? void 0 : (_uploadError_response = uploadError.response) === null || _uploadError_response === void 0 ? void 0 : _uploadError_response.data) || uploadError);\n                    }\n                }\n                // Final verification: ensure local key matches server key\n                const localServerMatch = (keys === null || keys === void 0 ? void 0 : keys.publicKey) === user.public_key;\n                console.log(\"\\uD83D\\uDD10 Final Key Status:\", {\n                    username,\n                    localPubKey: keys === null || keys === void 0 ? void 0 : (_keys_publicKey = keys.publicKey) === null || _keys_publicKey === void 0 ? void 0 : _keys_publicKey.substring(0, 30),\n                    serverPubKey: (_user_public_key = user.public_key) === null || _user_public_key === void 0 ? void 0 : _user_public_key.substring(0, 30),\n                    localPrivKey: keys === null || keys === void 0 ? void 0 : (_keys_privateKey = keys.privateKey) === null || _keys_privateKey === void 0 ? void 0 : _keys_privateKey.substring(0, 30),\n                    LOCAL_MATCHES_SERVER: localServerMatch ? \"✅ YES\" : \"❌ NO\"\n                });\n                if (!localServerMatch && (keys === null || keys === void 0 ? void 0 : keys.publicKey) && user.public_key) {\n                    console.error(\"\\uD83D\\uDEA8 CRITICAL: Local public key does not match server! This will cause decryption failures.\");\n                    console.log(\"\\uD83D\\uDD27 Attempting to force upload correct key...\");\n                    try {\n                        var _user_public_key2;\n                        await _api__WEBPACK_IMPORTED_MODULE_0__.api.uploadKeys({\n                            public_key: keys.publicKey || \"\",\n                            identity_key: keys.identityKey || \"\",\n                            signed_prekey: keys.signedPrekey || keys.publicKey || \"\",\n                            signed_prekey_signature: keys.signedPrekeySignature || \"\",\n                            one_time_prekeys: keys.oneTimePrekeys || []\n                        });\n                        user = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getCurrentUser();\n                        console.log(\"✅ Force upload complete, server now has:\", (_user_public_key2 = user.public_key) === null || _user_public_key2 === void 0 ? void 0 : _user_public_key2.substring(0, 30));\n                    } catch (e) {\n                        console.error(\"❌ Force upload failed:\", e);\n                    }\n                }\n                set({\n                    user,\n                    token: response.access_token,\n                    isAuthenticated: true,\n                    isLoading: false,\n                    privateKey: keys.privateKey || null,\n                    publicKey: keys.publicKey || null,\n                    identityKey: keys.identityKey || null\n                });\n                // Connect WebSocket\n                _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.connect(user.id.toString(), response.access_token);\n                // Setup message handlers\n                if (!window._wsHandlersRegistered) {\n                    setupWebSocketHandlers(get, set);\n                    window._wsHandlersRegistered = true;\n                }\n            } catch (error) {\n                var _error_response_data, _error_response;\n                set({\n                    isLoading: false,\n                    error: ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.detail) || \"Login failed\"\n                });\n                throw error;\n            }\n        },\n        register: async (username, email, password)=>{\n            set({\n                isLoading: true,\n                error: null\n            });\n            try {\n                const deviceId = \"web-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).slice(2));\n                await _api__WEBPACK_IMPORTED_MODULE_0__.api.register(username, email, password, deviceId);\n                // Auto-login after registration\n                await get().login(username, password);\n            } catch (error) {\n                var _error_response_data, _error_response;\n                set({\n                    isLoading: false,\n                    error: ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.detail) || \"Registration failed\"\n                });\n                throw error;\n            }\n        },\n        logout: ()=>{\n            _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.disconnect();\n            window._wsHandlersRegistered = false;\n            localStorage.removeItem(\"cipherlink_token\");\n            localStorage.removeItem(\"cipherlink_username\");\n            _api__WEBPACK_IMPORTED_MODULE_0__.api.setToken(null);\n            set({\n                user: null,\n                token: null,\n                isAuthenticated: false,\n                privateKey: null,\n                publicKey: null,\n                identityKey: null,\n                identityPrivateKey: null,\n                contacts: [],\n                conversations: [],\n                currentConversation: null,\n                messages: new Map(),\n                onlineUsers: new Set(),\n                typingUsers: new Map(),\n                callHistory: []\n            });\n        },\n        initializeWebSocket: ()=>{\n            const { user, token } = get();\n            if (user && token) {\n                _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.connect(user.id.toString(), token);\n                if (!window._wsHandlersRegistered) {\n                    setupWebSocketHandlers(get, set);\n                    window._wsHandlersRegistered = true;\n                }\n            }\n        },\n        loadStoredAuth: async ()=>{\n            const token = localStorage.getItem(\"cipherlink_token\");\n            const username = localStorage.getItem(\"cipherlink_username\");\n            if (token && username) {\n                _api__WEBPACK_IMPORTED_MODULE_0__.api.setToken(token);\n                try {\n                    const user = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getCurrentUser();\n                    const keys = _crypto__WEBPACK_IMPORTED_MODULE_1__.KeyStorage.load(username);\n                    set({\n                        user,\n                        token,\n                        isAuthenticated: true,\n                        privateKey: (keys === null || keys === void 0 ? void 0 : keys.privateKey) || null,\n                        publicKey: (keys === null || keys === void 0 ? void 0 : keys.publicKey) || null,\n                        identityKey: (keys === null || keys === void 0 ? void 0 : keys.identityKey) || null\n                    });\n                    // Connect WebSocket\n                    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.connect(user.id.toString(), token);\n                    // Setup message handlers\n                    if (!window._wsHandlersRegistered) {\n                        setupWebSocketHandlers(get, set);\n                        window._wsHandlersRegistered = true;\n                    }\n                    // Load persistent data from IndexedDB\n                    await get().loadPersistedData();\n                    // Sync with server in background\n                    get().syncWithServer().catch(console.error);\n                    return;\n                } catch (e) {\n                    // Token expired or invalid\n                    localStorage.removeItem(\"cipherlink_token\");\n                    localStorage.removeItem(\"cipherlink_username\");\n                }\n            }\n        },\n        // ============ Crypto Actions ============\n        generateAndUploadKeys: async ()=>{\n            const { user } = get();\n            if (!user) return;\n            const keyPair = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.generateKeyPair)();\n            const signingPair = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.generateSigningKeyPair)();\n            // Save locally\n            _crypto__WEBPACK_IMPORTED_MODULE_1__.KeyStorage.save(user.username, {\n                privateKey: keyPair.privateKey,\n                publicKey: keyPair.publicKey,\n                identityKey: signingPair.publicKey\n            });\n            // Upload to server\n            await _api__WEBPACK_IMPORTED_MODULE_0__.api.uploadKeys({\n                public_key: keyPair.publicKey,\n                identity_key: signingPair.publicKey,\n                signed_prekey: keyPair.publicKey,\n                signed_prekey_signature: signingPair.publicKey,\n                one_time_prekeys: []\n            });\n            set({\n                privateKey: keyPair.privateKey,\n                publicKey: keyPair.publicKey,\n                identityKey: signingPair.publicKey\n            });\n        },\n        loadStoredKeys: ()=>{\n            const { user } = get();\n            if (!user) return;\n            const keys = _crypto__WEBPACK_IMPORTED_MODULE_1__.KeyStorage.load(user.username);\n            if (keys) {\n                set({\n                    privateKey: keys.privateKey,\n                    publicKey: keys.publicKey,\n                    identityKey: keys.identityKey\n                });\n            }\n        },\n        // ============ Chat Actions ============\n        loadContacts: async ()=>{\n            try {\n                const contacts = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getContacts();\n                set({\n                    contacts\n                });\n            } catch (error) {\n                console.error(\"Failed to load contacts:\", error);\n            }\n        },\n        loadConversations: async ()=>{\n            try {\n                const conversations = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getConversations();\n                set({\n                    conversations\n                });\n            } catch (error) {\n                console.error(\"Failed to load conversations:\", error);\n            }\n        },\n        loadMessages: async (username)=>{\n            try {\n                const messages = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getConversation(username);\n                // Try to decrypt messages\n                const { privateKey, contacts, user } = get();\n                if (privateKey) {\n                    for (const msg of messages){\n                        if (msg.encrypted_content && !msg._decryptedContent) {\n                            try {\n                                const encryptedData = JSON.parse(msg.encrypted_content);\n                                // v2 protocol: senderPublicKey is embedded in message\n                                // v1 protocol: use contact's cached public key as fallback\n                                let fallbackPublicKey;\n                                if (msg.sender_username === (user === null || user === void 0 ? void 0 : user.username)) {\n                                    var _contacts_find;\n                                    // Sent by me -> fallback is recipient's public key\n                                    fallbackPublicKey = (_contacts_find = contacts.find((c)=>c.contact_username === msg.recipient_username)) === null || _contacts_find === void 0 ? void 0 : _contacts_find.public_key;\n                                } else {\n                                    // Received by me -> fallback is sender's public key\n                                    const contact = contacts.find((c)=>c.contact_username === msg.sender_username);\n                                    fallbackPublicKey = contact === null || contact === void 0 ? void 0 : contact.public_key;\n                                }\n                                // decryptMessage now handles v2 (embedded key) and v1 (fallback key)\n                                const decrypted = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.decryptMessage)(encryptedData, fallbackPublicKey || \"\", privateKey);\n                                msg._decryptedContent = decrypted;\n                            } catch (e) {\n                                console.warn(\"Failed to decrypt message:\", msg.id, e);\n                            }\n                        }\n                    }\n                }\n                const newMessages = new Map(get().messages);\n                newMessages.set(username, messages);\n                set({\n                    messages: newMessages\n                });\n            } catch (error) {\n                console.error(\"Failed to load messages:\", error);\n            }\n        },\n        sendMessage: async function(recipientUsername, content) {\n            let messageType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"text\", fileData = arguments.length > 3 ? arguments[3] : void 0;\n            console.log(\"\\uD83D\\uDCE4 sendMessage called:\", {\n                recipientUsername,\n                content: content.substring(0, 50),\n                messageType\n            });\n            let { privateKey, publicKey, user } = get();\n            if (!privateKey || !publicKey || !user) {\n                console.error(\"Cannot send message: missing keys or user\", {\n                    hasPrivateKey: !!privateKey,\n                    hasPublicKey: !!publicKey,\n                    hasUser: !!user\n                });\n                return;\n            }\n            // CRITICAL: Verify our key pair is valid before sending\n            const isValidPair = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.verifyKeyPair)(privateKey, publicKey);\n            if (!isValidPair) {\n                console.warn(\"⚠️ Invalid key pair detected in sendMessage! Deriving correct public key...\");\n                publicKey = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.derivePublicKeyFromPrivate)(privateKey);\n                console.log(\"\\uD83D\\uDD27 Using derived publicKey:\", publicKey === null || publicKey === void 0 ? void 0 : publicKey.substring(0, 30));\n                // Update store with corrected key\n                set({\n                    publicKey\n                });\n            }\n            // Always fetch the latest recipient public key from the server\n            console.log(\"\\uD83D\\uDCE4 Fetching public key from server for:\", recipientUsername);\n            let recipientPublicKey;\n            try {\n                const keyData = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getPublicKey(recipientUsername);\n                recipientPublicKey = keyData.public_key;\n                console.log(\"\\uD83D\\uDCE4 Got recipient public key from server:\", recipientPublicKey === null || recipientPublicKey === void 0 ? void 0 : recipientPublicKey.substring(0, 30));\n            } catch (error) {\n                console.error(\"Failed to get recipient public key:\", error);\n                throw new Error(\"Could not get recipient encryption key\");\n            }\n            if (!recipientPublicKey) {\n                throw new Error(\"Recipient has not set up encryption\");\n            }\n            // Encrypt message using static key pair (X25519)\n            // v2 protocol: includes sender's public key in the payload for reliable decryption\n            console.log(\"\\uD83D\\uDCE4 Encrypting with:\", {\n                recipientPubKey: recipientPublicKey === null || recipientPublicKey === void 0 ? void 0 : recipientPublicKey.substring(0, 30),\n                senderPrivKey: privateKey === null || privateKey === void 0 ? void 0 : privateKey.substring(0, 30),\n                senderPubKey: publicKey === null || publicKey === void 0 ? void 0 : publicKey.substring(0, 30)\n            });\n            const encrypted = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.encryptMessage)(content, recipientPublicKey, privateKey, publicKey);\n            const encryptedContent = JSON.stringify(encrypted);\n            // Build sender's theme for theme sync\n            const senderTheme = (0,_themeSync__WEBPACK_IMPORTED_MODULE_4__.buildMessageTheme)();\n            // Add to local messages optimistically\n            const currentMessages = get().messages.get(recipientUsername) || [];\n            const optimisticId = -Date.now();\n            const optimisticMessage = {\n                id: optimisticId,\n                sender_id: user.id,\n                sender_username: user.username,\n                recipient_id: 0,\n                recipient_username: recipientUsername,\n                encrypted_content: encryptedContent,\n                message_type: messageType,\n                status: \"sending\",\n                expiry_type: \"none\",\n                created_at: new Date().toISOString(),\n                _decryptedContent: content,\n                sender_theme: senderTheme\n            };\n            const newMessages = new Map(get().messages);\n            newMessages.set(recipientUsername, [\n                ...currentMessages,\n                optimisticMessage\n            ]);\n            set({\n                messages: newMessages\n            });\n            try {\n                console.log(\"\\uD83D\\uDCE4 Sending to API...\");\n                const sentMessage = await _api__WEBPACK_IMPORTED_MODULE_0__.api.sendMessage(recipientUsername, encryptedContent, undefined, \"none\", messageType, fileData);\n                console.log(\"✅ Message sent successfully\", sentMessage);\n                // Update optimistic message with real one while preserving decrypted content\n                sentMessage._decryptedContent = content;\n                const updatedMessages = new Map(get().messages);\n                const userMessages = updatedMessages.get(recipientUsername) || [];\n                const index = userMessages.findIndex((m)=>m.id === optimisticId);\n                if (index !== -1) {\n                    userMessages[index] = sentMessage;\n                } else {\n                    userMessages.push(sentMessage);\n                }\n                updatedMessages.set(recipientUsername, userMessages);\n                set({\n                    messages: updatedMessages\n                });\n                // Persist message and update/persist conversation snapshot for history\n                try {\n                    await get().persistMessage(sentMessage);\n                } catch (e) {\n                    console.error(\"❌ Failed to persist sent message:\", e);\n                }\n                // Update conversation preview & persist\n                const stateAfterSend = get();\n                const existingConvIndex = stateAfterSend.conversations.findIndex((c)=>c.username === recipientUsername);\n                if (existingConvIndex >= 0) {\n                    const conversations = [\n                        ...stateAfterSend.conversations\n                    ];\n                    const conv = conversations[existingConvIndex];\n                    const updatedConv = {\n                        ...conv,\n                        last_message_time: sentMessage.created_at,\n                        last_message_preview: messageType === \"image\" ? \"\\uD83D\\uDCF7 Image\" : content\n                    };\n                    conversations[existingConvIndex] = updatedConv;\n                    set({\n                        conversations\n                    });\n                    try {\n                        await get().persistConversation(updatedConv);\n                    } catch (e) {\n                        console.error(\"❌ Failed to persist conversation after send:\", e);\n                    }\n                }\n            } catch (error) {\n                console.error(\"Failed to send message:\", error);\n                // Mark as failed\n                const updatedMessages = new Map(get().messages);\n                const userMessages = updatedMessages.get(recipientUsername) || [];\n                const index = userMessages.findIndex((m)=>m.id === optimisticId);\n                if (index !== -1) {\n                    userMessages[index].status = \"failed\";\n                    updatedMessages.set(recipientUsername, userMessages);\n                    set({\n                        messages: updatedMessages\n                    });\n                }\n                throw error;\n            }\n        },\n        setCurrentConversation: (username)=>{\n            set({\n                currentConversation: username\n            });\n            if (username) {\n                get().loadMessages(username);\n                // Clear typing indicator for this user\n                const state = get();\n                const newTypingUsers = new Map(state.typingUsers);\n                newTypingUsers.delete(username);\n                set({\n                    typingUsers: newTypingUsers\n                });\n            }\n        },\n        addContact: async (username)=>{\n            try {\n                const contact = await _api__WEBPACK_IMPORTED_MODULE_0__.api.addContact(username);\n                const state = get();\n                set({\n                    contacts: [\n                        ...state.contacts,\n                        contact\n                    ]\n                });\n                // Also add to conversations immediately\n                const existingConv = state.conversations.find((c)=>c.username === username);\n                if (!existingConv) {\n                    const newConversation = {\n                        user_id: contact.contact_id,\n                        username: contact.contact_username,\n                        public_key: contact.public_key,\n                        identity_key: contact.identity_key,\n                        last_message_time: undefined,\n                        last_message_preview: undefined,\n                        unread_count: 0,\n                        is_online: false\n                    };\n                    set({\n                        conversations: [\n                            newConversation,\n                            ...state.conversations\n                        ]\n                    });\n                }\n            } catch (error) {\n                console.error(\"Failed to add contact:\", error);\n                throw error;\n            }\n        },\n        searchUsers: async (query)=>{\n            try {\n                return await _api__WEBPACK_IMPORTED_MODULE_0__.api.searchUsers(query);\n            } catch (error) {\n                console.error(\"Failed to search users:\", error);\n                return [];\n            }\n        },\n        addIncomingMessage: (message)=>{\n            const state = get();\n            const senderUsername = message.sender_username;\n            // Check if message already exists\n            const currentMessages = get().messages.get(senderUsername) || [];\n            const exists = currentMessages.some((m)=>m.id === message.id);\n            if (!exists) {\n                // Decrypt immediately if possible\n                // v2 protocol: senderPublicKey is embedded in the message payload\n                const { privateKey, contacts } = get();\n                if (privateKey && message.encrypted_content) {\n                    try {\n                        const encryptedData = JSON.parse(message.encrypted_content);\n                        // Get fallback public key from contacts (for v1 messages)\n                        const contact = contacts.find((c)=>c.contact_username === message.sender_username);\n                        const fallbackPublicKey = (contact === null || contact === void 0 ? void 0 : contact.public_key) || \"\";\n                        // decryptMessage handles v2 (uses embedded senderPublicKey) and v1 (uses fallback)\n                        message._decryptedContent = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__.decryptMessage)(encryptedData, fallbackPublicKey, privateKey);\n                        if (message._decryptedContent) {\n                            console.log(\"✅ Successfully decrypted incoming message\");\n                        } else {\n                            console.warn(\"⚠️ Decryption returned null for message:\", message.id);\n                        }\n                    } catch (e) {\n                        console.error(\"❌ Decryption failed for incoming:\", e);\n                    }\n                }\n                const newMessages = new Map(get().messages);\n                newMessages.set(senderUsername, [\n                    ...currentMessages,\n                    message\n                ]);\n                set({\n                    messages: newMessages\n                });\n                // Update conversation list\n                const convIndex = state.conversations.findIndex((c)=>c.username === senderUsername);\n                if (convIndex >= 0) {\n                    const conversations = [\n                        ...state.conversations\n                    ];\n                    const updatedConv = {\n                        ...conversations[convIndex],\n                        last_message_time: message.created_at,\n                        last_message_preview: message._decryptedContent ? message.message_type === \"image\" ? \"\\uD83D\\uDCF7 Image\" : message._decryptedContent : \"[Encrypted Message]\",\n                        unread_count: (conversations[convIndex].unread_count || 0) + 1\n                    };\n                    conversations[convIndex] = updatedConv;\n                    set({\n                        conversations\n                    });\n                    // Persist latest conversation snapshot and message for history\n                    get().persistMessage(message).catch((err)=>console.error(\"❌ Failed to persist incoming message:\", err));\n                    get().persistConversation(updatedConv).catch((err)=>console.error(\"❌ Failed to persist conversation for incoming message:\", err));\n                } else {\n                    // Message from user without an existing conversation entry – create a lightweight one\n                    const newConversation = {\n                        user_id: message.sender_id,\n                        username: senderUsername,\n                        public_key: undefined,\n                        identity_key: undefined,\n                        last_message_time: message.created_at,\n                        last_message_preview: message._decryptedContent ? message.message_type === \"image\" ? \"\\uD83D\\uDCF7 Image\" : message._decryptedContent : \"[Encrypted Message]\",\n                        unread_count: 1,\n                        is_online: false\n                    };\n                    set({\n                        conversations: [\n                            newConversation,\n                            ...state.conversations\n                        ]\n                    });\n                    get().persistMessage(message).catch((err)=>console.error(\"❌ Failed to persist incoming message:\", err));\n                    get().persistConversation(newConversation).catch((err)=>console.error(\"❌ Failed to persist new conversation for incoming message:\", err));\n                }\n            }\n        },\n        loadCallHistory: async ()=>{\n            try {\n                const history = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getCallHistory();\n                set({\n                    callHistory: history\n                });\n            } catch (error) {\n                console.error(\"Failed to load call history:\", error);\n            }\n        },\n        // ============ Presence ============\n        setUserOnline: (userId, isOnline)=>{\n            const state = get();\n            const newOnlineUsers = new Set(state.onlineUsers);\n            if (isOnline) {\n                newOnlineUsers.add(userId);\n            } else {\n                newOnlineUsers.delete(userId);\n            }\n            set({\n                onlineUsers: newOnlineUsers\n            });\n        },\n        setUserTyping: (username, isTyping)=>{\n            const state = get();\n            const newTypingUsers = new Map(state.typingUsers);\n            if (isTyping) {\n                newTypingUsers.set(username, true);\n            } else {\n                newTypingUsers.delete(username);\n            }\n            set({\n                typingUsers: newTypingUsers\n            });\n        },\n        clearError: ()=>set({\n                error: null\n            }),\n        // ============ Deletion Actions ============\n        deleteMessageForMe: async (messageId, conversationUsername)=>{\n            // Delete locally only - does not affect the other user\n            try {\n                // Remove from local state\n                const currentMessages = new Map(get().messages);\n                const convMessages = currentMessages.get(conversationUsername) || [];\n                const updatedMessages = convMessages.filter((m)=>m.id !== messageId);\n                currentMessages.set(conversationUsername, updatedMessages);\n                set({\n                    messages: currentMessages\n                });\n                // Remove from IndexedDB\n                await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.deleteMessage(messageId);\n                console.log(\"\\uD83D\\uDDD1️ Message deleted locally:\", messageId);\n            } catch (error) {\n                console.error(\"Failed to delete message locally:\", error);\n            }\n        },\n        deleteMessageForEveryone: async (messageId, conversationUsername)=>{\n            // Delete for everyone - sends delete event to recipient\n            try {\n                // First mark locally as deleted\n                const currentMessages = new Map(get().messages);\n                const convMessages = currentMessages.get(conversationUsername) || [];\n                const updatedMessages = convMessages.map((m)=>{\n                    if (m.id === messageId) {\n                        return {\n                            ...m,\n                            _decryptedContent: null,\n                            encrypted_content: JSON.stringify({\n                                deleted: true\n                            }),\n                            message_type: \"deleted\"\n                        };\n                    }\n                    return m;\n                });\n                currentMessages.set(conversationUsername, updatedMessages);\n                set({\n                    messages: currentMessages\n                });\n                // Mark as deleted in IndexedDB\n                await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.markMessageAsDeleted(messageId);\n                // Send delete event to recipient via WebSocket\n                _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.sendDeleteMessage(messageId, conversationUsername);\n                // Also try to delete on server\n                try {\n                    await _api__WEBPACK_IMPORTED_MODULE_0__.api.deleteMessage(messageId);\n                } catch (e) {\n                    console.warn(\"Could not delete message on server:\", e);\n                }\n                console.log(\"\\uD83D\\uDDD1️ Message deleted for everyone:\", messageId);\n            } catch (error) {\n                console.error(\"Failed to delete message for everyone:\", error);\n            }\n        },\n        clearChat: async (username)=>{\n            // Clear local chat history only - does not affect the other user\n            try {\n                const { user } = get();\n                if (!user) return;\n                // Clear from local state\n                const currentMessages = new Map(get().messages);\n                currentMessages.set(username, []);\n                set({\n                    messages: currentMessages\n                });\n                // Clear from IndexedDB\n                await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.clearConversationMessages(username, user.username);\n                // Update conversation preview\n                const conversations = [\n                    ...get().conversations\n                ];\n                const convIndex = conversations.findIndex((c)=>c.username === username);\n                if (convIndex >= 0) {\n                    conversations[convIndex] = {\n                        ...conversations[convIndex],\n                        last_message_preview: undefined,\n                        last_message_time: undefined,\n                        unread_count: 0\n                    };\n                    set({\n                        conversations\n                    });\n                }\n                console.log(\"\\uD83E\\uDDF9 Chat cleared locally:\", username);\n            } catch (error) {\n                console.error(\"Failed to clear chat:\", error);\n            }\n        },\n        deleteConversationForEveryone: async (username)=>{\n            // Delete entire conversation for both sides\n            try {\n                const { user } = get();\n                if (!user) return;\n                // Remove from local state\n                const currentMessages = new Map(get().messages);\n                currentMessages.delete(username);\n                set({\n                    messages: currentMessages\n                });\n                // Remove conversation from list\n                const conversations = get().conversations.filter((c)=>c.username !== username);\n                set({\n                    conversations\n                });\n                // Clear current conversation if it was the deleted one\n                if (get().currentConversation === username) {\n                    set({\n                        currentConversation: null\n                    });\n                }\n                // Delete from IndexedDB\n                await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.deleteConversation(username);\n                // Send delete event to recipient via WebSocket\n                _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.sendDeleteConversation(username);\n                // Also try to delete on server\n                try {\n                    await _api__WEBPACK_IMPORTED_MODULE_0__.api.deleteConversation(username);\n                } catch (e) {\n                    console.warn(\"Could not delete conversation on server:\", e);\n                }\n                console.log(\"\\uD83D\\uDDD1️ Conversation deleted for everyone:\", username);\n            } catch (error) {\n                console.error(\"Failed to delete conversation for everyone:\", error);\n            }\n        },\n        handleRemoteDeleteMessage: (messageId, senderUsername)=>{\n            // Handle incoming delete message event from another user\n            const currentMessages = new Map(get().messages);\n            const convMessages = currentMessages.get(senderUsername) || [];\n            const updatedMessages = convMessages.map((m)=>{\n                if (m.id === messageId) {\n                    return {\n                        ...m,\n                        _decryptedContent: null,\n                        encrypted_content: JSON.stringify({\n                            deleted: true\n                        }),\n                        message_type: \"deleted\"\n                    };\n                }\n                return m;\n            });\n            currentMessages.set(senderUsername, updatedMessages);\n            set({\n                messages: currentMessages\n            });\n            // Update IndexedDB\n            _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.markMessageAsDeleted(messageId).catch(console.error);\n            console.log(\"\\uD83D\\uDCE8 Remote message deletion received:\", messageId);\n        },\n        handleRemoteDeleteConversation: (senderUsername)=>{\n            // Handle incoming delete conversation event from another user\n            const currentMessages = new Map(get().messages);\n            currentMessages.delete(senderUsername);\n            set({\n                messages: currentMessages\n            });\n            // Remove conversation from list\n            const conversations = get().conversations.filter((c)=>c.username !== senderUsername);\n            set({\n                conversations\n            });\n            // Clear current conversation if it was the deleted one\n            if (get().currentConversation === senderUsername) {\n                set({\n                    currentConversation: null\n                });\n            }\n            // Delete from IndexedDB\n            _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.deleteConversation(senderUsername).catch(console.error);\n            console.log(\"\\uD83D\\uDCE8 Remote conversation deletion received:\", senderUsername);\n        },\n        // ============ Persistent Storage ============\n        loadPersistedData: async ()=>{\n            try {\n                console.log(\"\\uD83D\\uDCC2 Loading persisted data from IndexedDB...\");\n                // Load conversations\n                const storedConversations = await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.getAllConversations();\n                if (storedConversations.length > 0) {\n                    const conversations = storedConversations.map((conv)=>({\n                            user_id: conv.user_id,\n                            username: conv.username,\n                            public_key: conv.public_key,\n                            identity_key: conv.identity_key,\n                            last_message_time: conv.last_message_time,\n                            last_message_preview: conv.last_message_preview,\n                            unread_count: conv.unread_count,\n                            is_online: conv.is_online\n                        }));\n                    set({\n                        conversations\n                    });\n                    console.log(\"\\uD83D\\uDCC2 Loaded \".concat(conversations.length, \" conversations from storage\"));\n                }\n                // Load contacts\n                const storedContacts = await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.getAllContacts();\n                if (storedContacts.length > 0) {\n                    const contacts = storedContacts.map((contact)=>({\n                            id: contact.id,\n                            user_id: contact.user_id,\n                            contact_id: contact.contact_id,\n                            contact_username: contact.contact_username,\n                            contact_email: contact.contact_email,\n                            public_key: contact.public_key,\n                            identity_key: contact.identity_key,\n                            nickname: contact.nickname,\n                            is_blocked: contact.is_blocked,\n                            is_verified: contact.is_verified,\n                            added_at: contact.added_at\n                        }));\n                    set({\n                        contacts\n                    });\n                    console.log(\"\\uD83D\\uDCC2 Loaded \".concat(contacts.length, \" contacts from storage\"));\n                }\n                // Load messages for all conversations\n                const { user } = get();\n                if (user) {\n                    const messagesMap = new Map();\n                    for (const conv of storedConversations){\n                        const storedMessages = await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.getConversationMessages(conv.username, user.username, 50);\n                        if (storedMessages.length > 0) {\n                            const messages = storedMessages.map((msg)=>({\n                                    id: msg.id,\n                                    sender_id: msg.sender_id,\n                                    sender_username: msg.sender_username,\n                                    recipient_id: msg.recipient_id,\n                                    recipient_username: msg.recipient_username,\n                                    encrypted_content: msg.encrypted_content,\n                                    encrypted_key: msg.encrypted_key,\n                                    message_type: msg.message_type,\n                                    status: msg.status,\n                                    created_at: msg.created_at,\n                                    delivered_at: msg.delivered_at,\n                                    read_at: msg.read_at,\n                                    expiry_type: msg.expiry_type,\n                                    expires_at: msg.expires_at,\n                                    file_metadata: msg.file_metadata\n                                }));\n                            messagesMap.set(conv.username, messages);\n                        }\n                    }\n                    set({\n                        messages: messagesMap\n                    });\n                    console.log(\"\\uD83D\\uDCC2 Loaded messages for \".concat(messagesMap.size, \" conversations\"));\n                }\n            } catch (error) {\n                console.error(\"❌ Failed to load persisted data:\", error);\n            }\n        },\n        syncWithServer: async ()=>{\n            try {\n                console.log(\"\\uD83D\\uDD04 Syncing with server...\");\n                // Load fresh data from server\n                await get().loadContacts();\n                await get().loadConversations();\n                // Get all conversations with messages from server\n                const allConversationsData = await _api__WEBPACK_IMPORTED_MODULE_0__.api.getAllConversationsWithMessages();\n                // Update local storage with server data\n                const { user, contacts, conversations } = get();\n                if (user) {\n                    // Save conversations to IndexedDB\n                    const storedConversations = conversations.map((conv)=>({\n                            username: conv.username,\n                            user_id: conv.user_id,\n                            public_key: conv.public_key,\n                            identity_key: conv.identity_key,\n                            last_message_time: conv.last_message_time,\n                            last_message_preview: conv.last_message_preview,\n                            unread_count: conv.unread_count,\n                            is_online: conv.is_online\n                        }));\n                    await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.saveConversations(storedConversations);\n                    // Save contacts to IndexedDB\n                    const storedContacts = contacts.map((contact)=>({\n                            id: contact.id,\n                            user_id: contact.user_id,\n                            contact_id: contact.contact_id,\n                            contact_username: contact.contact_username,\n                            contact_email: contact.contact_email,\n                            public_key: contact.public_key,\n                            identity_key: contact.identity_key,\n                            nickname: contact.nickname,\n                            is_blocked: contact.is_blocked,\n                            is_verified: contact.is_verified,\n                            added_at: contact.added_at\n                        }));\n                    await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.saveContacts(storedContacts);\n                    // Save messages to IndexedDB\n                    for (const [username, messages] of Object.entries(allConversationsData)){\n                        const storedMessages = messages.map((msg)=>({\n                                id: msg.id,\n                                sender_id: msg.sender_id,\n                                sender_username: msg.sender_username,\n                                recipient_id: msg.recipient_id,\n                                recipient_username: msg.recipient_username,\n                                encrypted_content: msg.encrypted_content,\n                                encrypted_key: msg.encrypted_key,\n                                message_type: msg.message_type,\n                                status: msg.status,\n                                created_at: msg.created_at,\n                                delivered_at: msg.delivered_at,\n                                read_at: msg.read_at,\n                                expiry_type: msg.expiry_type,\n                                expires_at: msg.expires_at,\n                                file_metadata: msg.file_metadata\n                            }));\n                        await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.saveMessages(storedMessages);\n                    }\n                    // Update in-memory state\n                    const messagesMap = new Map();\n                    for (const [username, messages] of Object.entries(allConversationsData)){\n                        messagesMap.set(username, messages);\n                    }\n                    set({\n                        messages: messagesMap\n                    });\n                    console.log(\"✅ Sync completed successfully\");\n                }\n            } catch (error) {\n                console.error(\"❌ Sync failed:\", error);\n            }\n        },\n        persistMessage: async (message)=>{\n            try {\n                const storedMessage = {\n                    id: message.id,\n                    sender_id: message.sender_id,\n                    sender_username: message.sender_username,\n                    recipient_id: message.recipient_id,\n                    recipient_username: message.recipient_username,\n                    encrypted_content: message.encrypted_content,\n                    encrypted_key: message.encrypted_key,\n                    message_type: message.message_type,\n                    status: message.status,\n                    created_at: message.created_at,\n                    delivered_at: message.delivered_at,\n                    read_at: message.read_at,\n                    expiry_type: message.expiry_type,\n                    expires_at: message.expires_at,\n                    file_metadata: message.file_metadata\n                };\n                await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.saveMessage(storedMessage);\n            } catch (error) {\n                console.error(\"❌ Failed to persist message:\", error);\n            }\n        },\n        persistConversation: async (conversation)=>{\n            try {\n                const storedConversation = {\n                    username: conversation.username,\n                    user_id: conversation.user_id,\n                    public_key: conversation.public_key,\n                    identity_key: conversation.identity_key,\n                    last_message_time: conversation.last_message_time,\n                    last_message_preview: conversation.last_message_preview,\n                    unread_count: conversation.unread_count,\n                    is_online: conversation.is_online\n                };\n                await _storage__WEBPACK_IMPORTED_MODULE_3__.localStorageManager.saveConversation(storedConversation);\n            } catch (error) {\n                console.error(\"❌ Failed to persist conversation:\", error);\n            }\n        },\n        loadAllConversationHistory: async ()=>{\n            try {\n                const { conversations } = get();\n                console.log(\"\\uD83D\\uDCDA Loading history for \".concat(conversations.length, \" conversations...\"));\n                for (const conv of conversations){\n                    await get().loadMessages(conv.username);\n                    // Small delay to prevent overwhelming the server\n                    await new Promise((resolve)=>setTimeout(resolve, 100));\n                }\n                console.log(\"✅ All conversation history loaded\");\n            } catch (error) {\n                console.error(\"❌ Failed to load conversation history:\", error);\n            }\n        }\n    }), {\n    name: \"cipherlink-store\",\n    partialize: (state)=>({\n            // Only persist non-sensitive data\n            currentConversation: state.currentConversation\n        })\n}));\n// Setup WebSocket message handlers\nfunction setupWebSocketHandlers(get, set) {\n    // Handle incoming messages\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"message\", (data)=>{\n        var _state_user, _state_user1;\n        console.log(\"\\uD83D\\uDCE8 Received message:\", data);\n        const state = get();\n        const senderUsername = data.sender_username;\n        // Create message object\n        const message = {\n            id: data.message_id,\n            sender_id: data.sender_id,\n            sender_username: senderUsername,\n            recipient_id: ((_state_user = state.user) === null || _state_user === void 0 ? void 0 : _state_user.id) || 0,\n            recipient_username: ((_state_user1 = state.user) === null || _state_user1 === void 0 ? void 0 : _state_user1.username) || \"\",\n            encrypted_content: data.content || data.encrypted_content,\n            encrypted_key: data.encrypted_key,\n            message_type: data.message_type || \"text\",\n            status: \"delivered\",\n            expiry_type: data.expiry_type || \"none\",\n            created_at: data.timestamp\n        };\n        get().addIncomingMessage(message);\n        // Send delivery receipt\n        _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.sendDeliveryReceipt(data.message_id, data.sender_id);\n    });\n    // Handle typing indicators\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"typing\", (data)=>{\n        get().setUserTyping(data.sender_username, data.is_typing);\n        // Auto-clear typing after 3 seconds\n        if (data.is_typing) {\n            setTimeout(()=>{\n                get().setUserTyping(data.sender_username, false);\n            }, 3000);\n        }\n    });\n    // Handle presence updates\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"presence\", (data)=>{\n        get().setUserOnline(data.user_id, data.is_online);\n    });\n    // Handle message sent confirmations\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"message_sent\", (data)=>{\n        console.log(\"✅ Message sent confirmation:\", data);\n    });\n    // Handle read receipts\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"read_receipt\", (data)=>{\n        console.log(\"\\uD83D\\uDC41️ Read receipt:\", data);\n    // Could update message status in UI here\n    });\n    // Handle delivery receipts\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"delivery_receipt\", (data)=>{\n        console.log(\"\\uD83D\\uDCEC Delivery receipt:\", data);\n    // Could update message status in UI here\n    });\n    // Handle connection confirmation\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"connected\", (data)=>{\n        console.log(\"✅ WebSocket connected:\", data);\n    });\n    // Handle errors\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"error\", (data)=>{\n        console.error(\"❌ WebSocket error:\", data);\n    });\n    // Handle remote message deletion\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"delete_message_received\", (data)=>{\n        var _data_data, _data_data1;\n        console.log(\"\\uD83D\\uDDD1️ Remote delete message received:\", data);\n        const messageId = data.message_id || ((_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.message_id);\n        const senderUsername = data.sender_username || ((_data_data1 = data.data) === null || _data_data1 === void 0 ? void 0 : _data_data1.sender_username);\n        if (messageId && senderUsername) {\n            get().handleRemoteDeleteMessage(messageId, senderUsername);\n        }\n    });\n    // Handle remote conversation deletion\n    _websocket__WEBPACK_IMPORTED_MODULE_2__.wsManager.on(\"delete_conversation_received\", (data)=>{\n        var _data_data;\n        console.log(\"\\uD83D\\uDDD1️ Remote delete conversation received:\", data);\n        const senderUsername = data.sender_username || ((_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.sender_username);\n        if (senderUsername) {\n            get().handleRemoteDeleteConversation(senderUsername);\n        }\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FFZ0M7QUFDWTtBQUM4QjtBQVd6RDtBQUNzQjtBQUMwRDtBQUNsRDtBQXVFekMsTUFBTWMsV0FBV2QsK0NBQU1BLEdBQzVCQywyREFBT0EsQ0FDTCxDQUFDYyxLQUFLQyxNQUFTO1FBQ2IsZ0JBQWdCO1FBQ2hCQyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsaUJBQWlCO1FBQ2pCQyxXQUFXO1FBQ1hDLE9BQU87UUFDUEMsWUFBWTtRQUNaQyxXQUFXO1FBQ1hDLGFBQWE7UUFDYkMsb0JBQW9CO1FBQ3BCQyxVQUFVLEVBQUU7UUFDWkMsZUFBZSxFQUFFO1FBQ2pCQyxxQkFBcUI7UUFDckJDLFVBQVUsSUFBSUM7UUFDZEMsYUFBYSxJQUFJQztRQUNqQkMsYUFBYSxJQUFJSDtRQUNqQkksYUFBYSxFQUFFO1FBRWYseUNBQXlDO1FBRXpDQyxPQUFPLE9BQU9DLFVBQWtCQztZQUM5QnRCLElBQUk7Z0JBQUVLLFdBQVc7Z0JBQU1DLE9BQU87WUFBSztZQUNuQyxJQUFJO29CQTRGYWlCLGlCQUNDckIsa0JBQ0FxQjtnQkE3RmhCLE1BQU1DLFdBQVcsTUFBTXJDLHFDQUFHQSxDQUFDaUMsS0FBSyxDQUFDQyxVQUFVQztnQkFDM0MsSUFBSXBCLE9BQU8sTUFBTWYscUNBQUdBLENBQUNzQyxjQUFjO2dCQUVuQyxjQUFjO2dCQUNkQyxhQUFhQyxPQUFPLENBQUMsb0JBQW9CSCxTQUFTSSxZQUFZO2dCQUM5REYsYUFBYUMsT0FBTyxDQUFDLHVCQUF1Qk47Z0JBRTVDLHdCQUF3QjtnQkFDeEIsSUFBSUUsT0FBT2hDLCtDQUFVQSxDQUFDc0MsSUFBSSxDQUFDUjtnQkFDM0IsSUFBSVMsY0FBYyxDQUFDNUIsS0FBSzZCLFVBQVU7Z0JBQ2xDLElBQUlDLGNBQWM7Z0JBRWxCLDZEQUE2RDtnQkFDN0QsSUFBSVQsUUFBUXJCLEtBQUs2QixVQUFVLEVBQUU7b0JBQzNCLE1BQU1FLGVBQWUxQywrQ0FBVUEsQ0FBQzJDLG9CQUFvQixDQUFDYixVQUFVbkIsS0FBSzZCLFVBQVU7b0JBQzlFLElBQUksQ0FBQ0UsY0FBYzt3QkFDakJFLFFBQVFDLElBQUksQ0FBQzt3QkFDYkQsUUFBUUMsSUFBSSxDQUFDO3dCQUNiRCxRQUFRQyxJQUFJLENBQUM7d0JBQ2JKLGNBQWM7b0JBQ2Qsd0NBQXdDO29CQUMxQztnQkFDRjtnQkFFQSxJQUFJLENBQUNULE1BQU07b0JBQ1QsaUNBQWlDO29CQUNqQ1ksUUFBUUUsR0FBRyxDQUFDO29CQUNaLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxXQUFXLEVBQUUsR0FBR2pELDBEQUFpQkEsQ0FBQztvQkFFbERpQyxPQUFPO3dCQUNMaEIsWUFBWWdDLFlBQVlDLG1CQUFtQjt3QkFDM0NoQyxXQUFXOEIsT0FBTzlCLFNBQVM7d0JBQzNCQyxhQUFhNkIsT0FBTzdCLFdBQVc7d0JBQy9CZ0MsY0FBY0gsT0FBT0csWUFBWTt3QkFDakNDLHVCQUF1QkosT0FBT0kscUJBQXFCO3dCQUNuRGhDLG9CQUFvQjZCLFlBQVlJLGVBQWU7d0JBQy9DQyxnQkFBZ0JOLE9BQU9NLGNBQWM7b0JBQ3ZDO29CQUNBckQsK0NBQVVBLENBQUNzRCxJQUFJLENBQUN4QixVQUFVRTtvQkFDMUJPLGNBQWM7b0JBQ2RLLFFBQVFFLEdBQUcsQ0FBQztnQkFDZDtnQkFFQSxtRUFBbUU7Z0JBQ25FLElBQUlkLEtBQUtoQixVQUFVLElBQUlnQixLQUFLZixTQUFTLEVBQUU7b0JBQ3JDLE1BQU1zQyxjQUFjcEQsc0RBQWFBLENBQUM2QixLQUFLaEIsVUFBVSxFQUFFZ0IsS0FBS2YsU0FBUztvQkFDakUyQixRQUFRRSxHQUFHLENBQUMsdUNBQTZCUyxjQUFjLFlBQVk7b0JBRW5FLElBQUksQ0FBQ0EsYUFBYTs0QkFLc0J2Qjt3QkFKdEMsdURBQXVEO3dCQUN2RCxxREFBcUQ7d0JBQ3JEWSxRQUFRQyxJQUFJLENBQUM7d0JBQ2IsTUFBTVcsbUJBQW1CcEQsbUVBQTBCQSxDQUFDNEIsS0FBS2hCLFVBQVU7d0JBQ25FNEIsUUFBUUUsR0FBRyxDQUFDLHFDQUEwQmQsbUJBQUFBLEtBQUtmLFNBQVMsY0FBZGUsdUNBQUFBLGlCQUFnQnlCLFNBQVMsQ0FBQyxHQUFHO3dCQUNuRWIsUUFBUUUsR0FBRyxDQUFDLG1DQUF5QlUsNkJBQUFBLHVDQUFBQSxpQkFBa0JDLFNBQVMsQ0FBQyxHQUFHO3dCQUVwRSw4Q0FBOEM7d0JBQzlDekIsS0FBS2YsU0FBUyxHQUFHdUM7d0JBQ2pCeEQsK0NBQVVBLENBQUNzRCxJQUFJLENBQUN4QixVQUFVRTt3QkFDMUJPLGNBQWMsTUFBTSxtQ0FBbUM7d0JBQ3ZESyxRQUFRRSxHQUFHLENBQUM7b0JBQ2Q7Z0JBQ0Y7Z0JBRUEsK0RBQStEO2dCQUMvRCxJQUFJUCxlQUFlUCxNQUFNO3dCQUVGQTtvQkFEckJZLFFBQVFFLEdBQUcsQ0FBQyw0Q0FBa0M7d0JBQzVDWSxpQkFBaUIsR0FBRTFCLG1CQUFBQSxLQUFLZixTQUFTLGNBQWRlLHVDQUFBQSxpQkFBZ0J5QixTQUFTLENBQUMsR0FBRztvQkFDbEQ7b0JBQ0EsSUFBSTs0QkFXYzlDO3dCQVZoQixNQUFNZixxQ0FBR0EsQ0FBQytELFVBQVUsQ0FBQzs0QkFDbkJuQixZQUFZUixLQUFLZixTQUFTLElBQUk7NEJBQzlCMkMsY0FBYzVCLEtBQUtkLFdBQVcsSUFBSTs0QkFDbEMyQyxlQUFlN0IsS0FBS2tCLFlBQVksSUFBSWxCLEtBQUtmLFNBQVMsSUFBSTs0QkFDdEQ2Qyx5QkFBeUI5QixLQUFLbUIscUJBQXFCLElBQUk7NEJBQ3ZEWSxrQkFBa0IvQixLQUFLcUIsY0FBYyxJQUFJLEVBQUU7d0JBQzdDO3dCQUNBLHlDQUF5Qzt3QkFDekMxQyxPQUFPLE1BQU1mLHFDQUFHQSxDQUFDc0MsY0FBYzt3QkFDL0JVLFFBQVFFLEdBQUcsQ0FBQyxpQ0FBaUM7NEJBQzNDa0IsWUFBWSxHQUFFckQsb0JBQUFBLEtBQUs2QixVQUFVLGNBQWY3Qix3Q0FBQUEsa0JBQWlCOEMsU0FBUyxDQUFDLEdBQUc7d0JBQzlDO29CQUNGLEVBQUUsT0FBT1EsYUFBa0I7NEJBQ2lCQTt3QkFBMUNyQixRQUFRN0IsS0FBSyxDQUFDLDRCQUE0QmtELENBQUFBLHdCQUFBQSxtQ0FBQUEsd0JBQUFBLFlBQWFoQyxRQUFRLGNBQXJCZ0MsNENBQUFBLHNCQUF1QkMsSUFBSSxLQUFJRDtvQkFDM0U7Z0JBQ0Y7Z0JBRUEsMERBQTBEO2dCQUMxRCxNQUFNRSxtQkFBbUJuQyxDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1mLFNBQVMsTUFBS04sS0FBSzZCLFVBQVU7Z0JBQzVESSxRQUFRRSxHQUFHLENBQUMsa0NBQXdCO29CQUNsQ2hCO29CQUNBc0MsV0FBVyxFQUFFcEMsaUJBQUFBLDRCQUFBQSxrQkFBQUEsS0FBTWYsU0FBUyxjQUFmZSxzQ0FBQUEsZ0JBQWlCeUIsU0FBUyxDQUFDLEdBQUc7b0JBQzNDWSxZQUFZLEdBQUUxRCxtQkFBQUEsS0FBSzZCLFVBQVUsY0FBZjdCLHVDQUFBQSxpQkFBaUI4QyxTQUFTLENBQUMsR0FBRztvQkFDNUNhLFlBQVksRUFBRXRDLGlCQUFBQSw0QkFBQUEsbUJBQUFBLEtBQU1oQixVQUFVLGNBQWhCZ0IsdUNBQUFBLGlCQUFrQnlCLFNBQVMsQ0FBQyxHQUFHO29CQUM3Q2Msc0JBQXNCSixtQkFBbUIsVUFBVTtnQkFDckQ7Z0JBRUEsSUFBSSxDQUFDQSxxQkFBb0JuQyxpQkFBQUEsMkJBQUFBLEtBQU1mLFNBQVMsS0FBSU4sS0FBSzZCLFVBQVUsRUFBRTtvQkFDM0RJLFFBQVE3QixLQUFLLENBQUM7b0JBQ2Q2QixRQUFRRSxHQUFHLENBQUM7b0JBQ1osSUFBSTs0QkFTc0RuQzt3QkFSeEQsTUFBTWYscUNBQUdBLENBQUMrRCxVQUFVLENBQUM7NEJBQ25CbkIsWUFBWVIsS0FBS2YsU0FBUyxJQUFJOzRCQUM5QjJDLGNBQWM1QixLQUFLZCxXQUFXLElBQUk7NEJBQ2xDMkMsZUFBZTdCLEtBQUtrQixZQUFZLElBQUlsQixLQUFLZixTQUFTLElBQUk7NEJBQ3RENkMseUJBQXlCOUIsS0FBS21CLHFCQUFxQixJQUFJOzRCQUN2RFksa0JBQWtCL0IsS0FBS3FCLGNBQWMsSUFBSSxFQUFFO3dCQUM3Qzt3QkFDQTFDLE9BQU8sTUFBTWYscUNBQUdBLENBQUNzQyxjQUFjO3dCQUMvQlUsUUFBUUUsR0FBRyxDQUFDLDZDQUE0Q25DLG9CQUFBQSxLQUFLNkIsVUFBVSxjQUFmN0Isd0NBQUFBLGtCQUFpQjhDLFNBQVMsQ0FBQyxHQUFHO29CQUN4RixFQUFFLE9BQU9lLEdBQUc7d0JBQ1Y1QixRQUFRN0IsS0FBSyxDQUFDLDBCQUEwQnlEO29CQUMxQztnQkFDRjtnQkFFQS9ELElBQUk7b0JBQ0ZFO29CQUNBQyxPQUFPcUIsU0FBU0ksWUFBWTtvQkFDNUJ4QixpQkFBaUI7b0JBQ2pCQyxXQUFXO29CQUNYRSxZQUFZZ0IsS0FBS2hCLFVBQVUsSUFBSTtvQkFDL0JDLFdBQVdlLEtBQUtmLFNBQVMsSUFBSTtvQkFDN0JDLGFBQWFjLEtBQUtkLFdBQVcsSUFBSTtnQkFDbkM7Z0JBRUEsb0JBQW9CO2dCQUNwQmIsaURBQVNBLENBQUNvRSxPQUFPLENBQUM5RCxLQUFLK0QsRUFBRSxDQUFDQyxRQUFRLElBQUkxQyxTQUFTSSxZQUFZO2dCQUUzRCx5QkFBeUI7Z0JBQ3pCLElBQUksQ0FBQyxPQUFnQndDLHFCQUFxQixFQUFFO29CQUMxQ0MsdUJBQXVCcEUsS0FBS0Q7b0JBQzNCbUUsT0FBZUMscUJBQXFCLEdBQUc7Z0JBQzFDO1lBRUYsRUFBRSxPQUFPOUQsT0FBWTtvQkFHVkEsc0JBQUFBO2dCQUZUTixJQUFJO29CQUNGSyxXQUFXO29CQUNYQyxPQUFPQSxFQUFBQSxrQkFBQUEsTUFBTWtCLFFBQVEsY0FBZGxCLHVDQUFBQSx1QkFBQUEsZ0JBQWdCbUQsSUFBSSxjQUFwQm5ELDJDQUFBQSxxQkFBc0JnRSxNQUFNLEtBQUk7Z0JBQ3pDO2dCQUNBLE1BQU1oRTtZQUNSO1FBQ0Y7UUFFQWlFLFVBQVUsT0FBT2xELFVBQWtCbUQsT0FBZWxEO1lBQ2hEdEIsSUFBSTtnQkFBRUssV0FBVztnQkFBTUMsT0FBTztZQUFLO1lBQ25DLElBQUk7Z0JBQ0YsTUFBTW1FLFdBQVcsT0FBcUJDLE9BQWRDLEtBQUtDLEdBQUcsSUFBRyxLQUF1QyxPQUFwQ0YsS0FBS0csTUFBTSxHQUFHWCxRQUFRLENBQUMsSUFBSVksS0FBSyxDQUFDO2dCQUN2RSxNQUFNM0YscUNBQUdBLENBQUNvRixRQUFRLENBQUNsRCxVQUFVbUQsT0FBT2xELFVBQVVtRDtnQkFFOUMsZ0NBQWdDO2dCQUNoQyxNQUFNeEUsTUFBTW1CLEtBQUssQ0FBQ0MsVUFBVUM7WUFFOUIsRUFBRSxPQUFPaEIsT0FBWTtvQkFHVkEsc0JBQUFBO2dCQUZUTixJQUFJO29CQUNGSyxXQUFXO29CQUNYQyxPQUFPQSxFQUFBQSxrQkFBQUEsTUFBTWtCLFFBQVEsY0FBZGxCLHVDQUFBQSx1QkFBQUEsZ0JBQWdCbUQsSUFBSSxjQUFwQm5ELDJDQUFBQSxxQkFBc0JnRSxNQUFNLEtBQUk7Z0JBQ3pDO2dCQUNBLE1BQU1oRTtZQUNSO1FBQ0Y7UUFFQXlFLFFBQVE7WUFDTm5GLGlEQUFTQSxDQUFDb0YsVUFBVTtZQUNuQmIsT0FBZUMscUJBQXFCLEdBQUc7WUFDeEMxQyxhQUFhdUQsVUFBVSxDQUFDO1lBQ3hCdkQsYUFBYXVELFVBQVUsQ0FBQztZQUN4QjlGLHFDQUFHQSxDQUFDK0YsUUFBUSxDQUFDO1lBRWJsRixJQUFJO2dCQUNGRSxNQUFNO2dCQUNOQyxPQUFPO2dCQUNQQyxpQkFBaUI7Z0JBQ2pCRyxZQUFZO2dCQUNaQyxXQUFXO2dCQUNYQyxhQUFhO2dCQUNiQyxvQkFBb0I7Z0JBQ3BCQyxVQUFVLEVBQUU7Z0JBQ1pDLGVBQWUsRUFBRTtnQkFDakJDLHFCQUFxQjtnQkFDckJDLFVBQVUsSUFBSUM7Z0JBQ2RDLGFBQWEsSUFBSUM7Z0JBQ2pCQyxhQUFhLElBQUlIO2dCQUNqQkksYUFBYSxFQUFFO1lBQ2pCO1FBQ0Y7UUFFQWdFLHFCQUFxQjtZQUNuQixNQUFNLEVBQUVqRixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHRjtZQUN4QixJQUFJQyxRQUFRQyxPQUFPO2dCQUNqQlAsaURBQVNBLENBQUNvRSxPQUFPLENBQUM5RCxLQUFLK0QsRUFBRSxDQUFDQyxRQUFRLElBQUkvRDtnQkFDdEMsSUFBSSxDQUFDLE9BQWdCaUUscUJBQXFCLEVBQUU7b0JBQzFDQyx1QkFBdUJwRSxLQUFLRDtvQkFDM0JtRSxPQUFlQyxxQkFBcUIsR0FBRztnQkFDMUM7WUFDRjtRQUNGO1FBRUFnQixnQkFBZ0I7WUFDZCxNQUFNakYsUUFBUXVCLGFBQWEyRCxPQUFPLENBQUM7WUFDbkMsTUFBTWhFLFdBQVdLLGFBQWEyRCxPQUFPLENBQUM7WUFFdEMsSUFBSWxGLFNBQVNrQixVQUFVO2dCQUNyQmxDLHFDQUFHQSxDQUFDK0YsUUFBUSxDQUFDL0U7Z0JBQ2IsSUFBSTtvQkFDRixNQUFNRCxPQUFPLE1BQU1mLHFDQUFHQSxDQUFDc0MsY0FBYztvQkFDckMsTUFBTUYsT0FBT2hDLCtDQUFVQSxDQUFDc0MsSUFBSSxDQUFDUjtvQkFFN0JyQixJQUFJO3dCQUNGRTt3QkFDQUM7d0JBQ0FDLGlCQUFpQjt3QkFDakJHLFlBQVlnQixDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1oQixVQUFVLEtBQUk7d0JBQ2hDQyxXQUFXZSxDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1mLFNBQVMsS0FBSTt3QkFDOUJDLGFBQWFjLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTWQsV0FBVyxLQUFJO29CQUNwQztvQkFFQSxvQkFBb0I7b0JBQ3BCYixpREFBU0EsQ0FBQ29FLE9BQU8sQ0FBQzlELEtBQUsrRCxFQUFFLENBQUNDLFFBQVEsSUFBSS9EO29CQUV0Qyx5QkFBeUI7b0JBQ3pCLElBQUksQ0FBQyxPQUFnQmlFLHFCQUFxQixFQUFFO3dCQUMxQ0MsdUJBQXVCcEUsS0FBS0Q7d0JBQzNCbUUsT0FBZUMscUJBQXFCLEdBQUc7b0JBQzFDO29CQUVBLHNDQUFzQztvQkFDdEMsTUFBTW5FLE1BQU1xRixpQkFBaUI7b0JBRTdCLGlDQUFpQztvQkFDakNyRixNQUFNc0YsY0FBYyxHQUFHQyxLQUFLLENBQUNyRCxRQUFRN0IsS0FBSztvQkFFMUM7Z0JBQ0YsRUFBRSxVQUFNO29CQUNOLDJCQUEyQjtvQkFDM0JvQixhQUFhdUQsVUFBVSxDQUFDO29CQUN4QnZELGFBQWF1RCxVQUFVLENBQUM7Z0JBQzFCO1lBQ0Y7UUFDRjtRQUVBLDJDQUEyQztRQUUzQ1EsdUJBQXVCO1lBQ3JCLE1BQU0sRUFBRXZGLElBQUksRUFBRSxHQUFHRDtZQUNqQixJQUFJLENBQUNDLE1BQU07WUFFWCxNQUFNd0YsVUFBVXRHLHdEQUFlQTtZQUMvQixNQUFNdUcsY0FBY3RHLCtEQUFzQkE7WUFFMUMsZUFBZTtZQUNmRSwrQ0FBVUEsQ0FBQ3NELElBQUksQ0FBQzNDLEtBQUttQixRQUFRLEVBQUU7Z0JBQzdCZCxZQUFZbUYsUUFBUW5GLFVBQVU7Z0JBQzlCQyxXQUFXa0YsUUFBUWxGLFNBQVM7Z0JBQzVCQyxhQUFha0YsWUFBWW5GLFNBQVM7WUFDcEM7WUFFQSxtQkFBbUI7WUFDbkIsTUFBTXJCLHFDQUFHQSxDQUFDK0QsVUFBVSxDQUFDO2dCQUNuQm5CLFlBQVkyRCxRQUFRbEYsU0FBUztnQkFDN0IyQyxjQUFjd0MsWUFBWW5GLFNBQVM7Z0JBQ25DNEMsZUFBZXNDLFFBQVFsRixTQUFTO2dCQUNoQzZDLHlCQUF5QnNDLFlBQVluRixTQUFTO2dCQUM5QzhDLGtCQUFrQixFQUFFO1lBQ3RCO1lBRUF0RCxJQUFJO2dCQUNGTyxZQUFZbUYsUUFBUW5GLFVBQVU7Z0JBQzlCQyxXQUFXa0YsUUFBUWxGLFNBQVM7Z0JBQzVCQyxhQUFha0YsWUFBWW5GLFNBQVM7WUFDcEM7UUFDRjtRQUVBb0YsZ0JBQWdCO1lBQ2QsTUFBTSxFQUFFMUYsSUFBSSxFQUFFLEdBQUdEO1lBQ2pCLElBQUksQ0FBQ0MsTUFBTTtZQUVYLE1BQU1xQixPQUFPaEMsK0NBQVVBLENBQUNzQyxJQUFJLENBQUMzQixLQUFLbUIsUUFBUTtZQUMxQyxJQUFJRSxNQUFNO2dCQUNSdkIsSUFBSTtvQkFDRk8sWUFBWWdCLEtBQUtoQixVQUFVO29CQUMzQkMsV0FBV2UsS0FBS2YsU0FBUztvQkFDekJDLGFBQWFjLEtBQUtkLFdBQVc7Z0JBQy9CO1lBQ0Y7UUFDRjtRQUVBLHlDQUF5QztRQUV6Q29GLGNBQWM7WUFDWixJQUFJO2dCQUNGLE1BQU1sRixXQUFXLE1BQU14QixxQ0FBR0EsQ0FBQzJHLFdBQVc7Z0JBQ3RDOUYsSUFBSTtvQkFBRVc7Z0JBQVM7WUFDakIsRUFBRSxPQUFPTCxPQUFPO2dCQUNkNkIsUUFBUTdCLEtBQUssQ0FBQyw0QkFBNEJBO1lBQzVDO1FBQ0Y7UUFFQXlGLG1CQUFtQjtZQUNqQixJQUFJO2dCQUNGLE1BQU1uRixnQkFBZ0IsTUFBTXpCLHFDQUFHQSxDQUFDNkcsZ0JBQWdCO2dCQUNoRGhHLElBQUk7b0JBQUVZO2dCQUFjO1lBQ3RCLEVBQUUsT0FBT04sT0FBTztnQkFDZDZCLFFBQVE3QixLQUFLLENBQUMsaUNBQWlDQTtZQUNqRDtRQUNGO1FBRUEyRixjQUFjLE9BQU81RTtZQUNuQixJQUFJO2dCQUNGLE1BQU1QLFdBQVcsTUFBTTNCLHFDQUFHQSxDQUFDK0csZUFBZSxDQUFDN0U7Z0JBRTNDLDBCQUEwQjtnQkFDMUIsTUFBTSxFQUFFZCxVQUFVLEVBQUVJLFFBQVEsRUFBRVQsSUFBSSxFQUFFLEdBQUdEO2dCQUV2QyxJQUFJTSxZQUFZO29CQUNkLEtBQUssTUFBTTRGLE9BQU9yRixTQUFVO3dCQUMxQixJQUFJcUYsSUFBSUMsaUJBQWlCLElBQUksQ0FBQ0QsSUFBSUUsaUJBQWlCLEVBQUU7NEJBQ25ELElBQUk7Z0NBQ0YsTUFBTUMsZ0JBQWdCQyxLQUFLQyxLQUFLLENBQUNMLElBQUlDLGlCQUFpQjtnQ0FFdEQsc0RBQXNEO2dDQUN0RCwyREFBMkQ7Z0NBQzNELElBQUlLO2dDQUVKLElBQUlOLElBQUlPLGVBQWUsTUFBS3hHLGlCQUFBQSwyQkFBQUEsS0FBTW1CLFFBQVEsR0FBRTt3Q0FFdEJWO29DQURwQixtREFBbUQ7b0NBQ25EOEYscUJBQW9COUYsaUJBQUFBLFNBQVNnRyxJQUFJLENBQy9CQyxDQUFBQSxJQUFLQSxFQUFFQyxnQkFBZ0IsS0FBS1YsSUFBSVcsa0JBQWtCLGVBRGhDbkcscUNBQUFBLGVBRWpCb0IsVUFBVTtnQ0FDZixPQUFPO29DQUNMLG9EQUFvRDtvQ0FDcEQsTUFBTWdGLFVBQVVwRyxTQUFTZ0csSUFBSSxDQUMzQkMsQ0FBQUEsSUFBS0EsRUFBRUMsZ0JBQWdCLEtBQUtWLElBQUlPLGVBQWU7b0NBRWpERCxvQkFBb0JNLG9CQUFBQSw4QkFBQUEsUUFBU2hGLFVBQVU7Z0NBQ3pDO2dDQUVBLHFFQUFxRTtnQ0FDckUsTUFBTWlGLFlBQVl2SCx1REFBY0EsQ0FBQzZHLGVBQWVHLHFCQUFxQixJQUFJbEc7Z0NBQ3pFNEYsSUFBSUUsaUJBQWlCLEdBQUdXOzRCQUMxQixFQUFFLE9BQU9qRCxHQUFHO2dDQUNWNUIsUUFBUUMsSUFBSSxDQUFDLDhCQUE4QitELElBQUlsQyxFQUFFLEVBQUVGOzRCQUNyRDt3QkFDRjtvQkFDRjtnQkFDRjtnQkFFQSxNQUFNa0QsY0FBYyxJQUFJbEcsSUFBSWQsTUFBTWEsUUFBUTtnQkFDMUNtRyxZQUFZakgsR0FBRyxDQUFDcUIsVUFBVVA7Z0JBQzFCZCxJQUFJO29CQUFFYyxVQUFVbUc7Z0JBQVk7WUFDOUIsRUFBRSxPQUFPM0csT0FBTztnQkFDZDZCLFFBQVE3QixLQUFLLENBQUMsNEJBQTRCQTtZQUM1QztRQUNGO1FBRUE0RyxhQUFhLGVBQU9DLG1CQUEyQkM7Z0JBQWlCQywrRUFBc0IsUUFBUUM7WUFDNUZuRixRQUFRRSxHQUFHLENBQUMsb0NBQTBCO2dCQUFFOEU7Z0JBQW1CQyxTQUFTQSxRQUFRcEUsU0FBUyxDQUFDLEdBQUc7Z0JBQUtxRTtZQUFZO1lBRTFHLElBQUksRUFBRTlHLFVBQVUsRUFBRUMsU0FBUyxFQUFFTixJQUFJLEVBQUUsR0FBR0Q7WUFDdEMsSUFBSSxDQUFDTSxjQUFjLENBQUNDLGFBQWEsQ0FBQ04sTUFBTTtnQkFDdENpQyxRQUFRN0IsS0FBSyxDQUFDLDZDQUE2QztvQkFBRWlILGVBQWUsQ0FBQyxDQUFDaEg7b0JBQVlpSCxjQUFjLENBQUMsQ0FBQ2hIO29CQUFXaUgsU0FBUyxDQUFDLENBQUN2SDtnQkFBSztnQkFDckk7WUFDRjtZQUVBLHdEQUF3RDtZQUN4RCxNQUFNNEMsY0FBY3BELHNEQUFhQSxDQUFDYSxZQUFZQztZQUM5QyxJQUFJLENBQUNzQyxhQUFhO2dCQUNoQlgsUUFBUUMsSUFBSSxDQUFDO2dCQUNiNUIsWUFBWWIsbUVBQTBCQSxDQUFDWTtnQkFDdkM0QixRQUFRRSxHQUFHLENBQUMseUNBQStCN0Isc0JBQUFBLGdDQUFBQSxVQUFXd0MsU0FBUyxDQUFDLEdBQUc7Z0JBQ25FLGtDQUFrQztnQkFDbENoRCxJQUFJO29CQUFFUTtnQkFBVTtZQUNsQjtZQUVBLCtEQUErRDtZQUMvRDJCLFFBQVFFLEdBQUcsQ0FBQyxxREFBMkM4RTtZQUN2RCxJQUFJTztZQUNKLElBQUk7Z0JBQ0YsTUFBTUMsVUFBVSxNQUFNeEkscUNBQUdBLENBQUN5SSxZQUFZLENBQUNUO2dCQUN2Q08scUJBQXFCQyxRQUFRNUYsVUFBVTtnQkFDdkNJLFFBQVFFLEdBQUcsQ0FBQyxzREFBNENxRiwrQkFBQUEseUNBQUFBLG1CQUFvQjFFLFNBQVMsQ0FBQyxHQUFHO1lBQzNGLEVBQUUsT0FBTzFDLE9BQU87Z0JBQ2Q2QixRQUFRN0IsS0FBSyxDQUFDLHVDQUF1Q0E7Z0JBQ3JELE1BQU0sSUFBSXVILE1BQU07WUFDbEI7WUFFQSxJQUFJLENBQUNILG9CQUFvQjtnQkFDdkIsTUFBTSxJQUFJRyxNQUFNO1lBQ2xCO1lBRUEsaURBQWlEO1lBQ2pELG1GQUFtRjtZQUNuRjFGLFFBQVFFLEdBQUcsQ0FBQyxpQ0FBdUI7Z0JBQ2pDeUYsZUFBZSxFQUFFSiwrQkFBQUEseUNBQUFBLG1CQUFvQjFFLFNBQVMsQ0FBQyxHQUFHO2dCQUNsRCtFLGFBQWEsRUFBRXhILHVCQUFBQSxpQ0FBQUEsV0FBWXlDLFNBQVMsQ0FBQyxHQUFHO2dCQUN4Q2dGLFlBQVksRUFBRXhILHNCQUFBQSxnQ0FBQUEsVUFBV3dDLFNBQVMsQ0FBQyxHQUFHO1lBQ3hDO1lBQ0EsTUFBTWlGLFlBQVl6SSx1REFBY0EsQ0FBQzRILFNBQVNNLG9CQUFvQm5ILFlBQVlDO1lBQzFFLE1BQU0wSCxtQkFBbUIzQixLQUFLNEIsU0FBUyxDQUFDRjtZQUV4QyxzQ0FBc0M7WUFDdEMsTUFBTUcsY0FBY3RJLDZEQUFpQkE7WUFFckMsdUNBQXVDO1lBQ3ZDLE1BQU11SSxrQkFBa0JwSSxNQUFNYSxRQUFRLENBQUNiLEdBQUcsQ0FBQ2tILHNCQUFzQixFQUFFO1lBQ25FLE1BQU1tQixlQUFlLENBQUMzRCxLQUFLQyxHQUFHO1lBQzlCLE1BQU0yRCxvQkFBNkI7Z0JBQ2pDdEUsSUFBSXFFO2dCQUNKRSxXQUFXdEksS0FBSytELEVBQUU7Z0JBQ2xCeUMsaUJBQWlCeEcsS0FBS21CLFFBQVE7Z0JBQzlCb0gsY0FBYztnQkFDZDNCLG9CQUFvQks7Z0JBQ3BCZixtQkFBbUI4QjtnQkFDbkJRLGNBQWNyQjtnQkFDZHNCLFFBQVE7Z0JBQ1JDLGFBQWE7Z0JBQ2JDLFlBQVksSUFBSWxFLE9BQU9tRSxXQUFXO2dCQUNsQ3pDLG1CQUFtQmU7Z0JBQ25CMkIsY0FBY1g7WUFDaEI7WUFFQSxNQUFNbkIsY0FBYyxJQUFJbEcsSUFBSWQsTUFBTWEsUUFBUTtZQUMxQ21HLFlBQVlqSCxHQUFHLENBQUNtSCxtQkFBbUI7bUJBQUlrQjtnQkFBaUJFO2FBQWtCO1lBQzFFdkksSUFBSTtnQkFBRWMsVUFBVW1HO1lBQVk7WUFFNUIsSUFBSTtnQkFDRjlFLFFBQVFFLEdBQUcsQ0FBQztnQkFDWixNQUFNMkcsY0FBYyxNQUFNN0oscUNBQUdBLENBQUMrSCxXQUFXLENBQ3ZDQyxtQkFDQWUsa0JBQ0FlLFdBQ0EsUUFDQTVCLGFBQ0FDO2dCQUdGbkYsUUFBUUUsR0FBRyxDQUFDLCtCQUErQjJHO2dCQUUzQyw2RUFBNkU7Z0JBQzdFQSxZQUFZM0MsaUJBQWlCLEdBQUdlO2dCQUVoQyxNQUFNOEIsa0JBQWtCLElBQUluSSxJQUFJZCxNQUFNYSxRQUFRO2dCQUM5QyxNQUFNcUksZUFBZUQsZ0JBQWdCakosR0FBRyxDQUFDa0gsc0JBQXNCLEVBQUU7Z0JBQ2pFLE1BQU1pQyxRQUFRRCxhQUFhRSxTQUFTLENBQUNDLENBQUFBLElBQUtBLEVBQUVyRixFQUFFLEtBQUtxRTtnQkFFbkQsSUFBSWMsVUFBVSxDQUFDLEdBQUc7b0JBQ2hCRCxZQUFZLENBQUNDLE1BQU0sR0FBR0o7Z0JBQ3hCLE9BQU87b0JBQ0xHLGFBQWFJLElBQUksQ0FBQ1A7Z0JBQ3BCO2dCQUVBRSxnQkFBZ0JsSixHQUFHLENBQUNtSCxtQkFBbUJnQztnQkFDdkNuSixJQUFJO29CQUFFYyxVQUFVb0k7Z0JBQWdCO2dCQUVoQyx1RUFBdUU7Z0JBQ3ZFLElBQUk7b0JBQ0YsTUFBTWpKLE1BQU11SixjQUFjLENBQUNSO2dCQUM3QixFQUFFLE9BQU9qRixHQUFHO29CQUNWNUIsUUFBUTdCLEtBQUssQ0FBQyxxQ0FBcUN5RDtnQkFDckQ7Z0JBRUEsd0NBQXdDO2dCQUN4QyxNQUFNMEYsaUJBQWlCeEo7Z0JBQ3ZCLE1BQU15SixvQkFBb0JELGVBQWU3SSxhQUFhLENBQUN5SSxTQUFTLENBQUN6QyxDQUFBQSxJQUFLQSxFQUFFdkYsUUFBUSxLQUFLOEY7Z0JBQ3JGLElBQUl1QyxxQkFBcUIsR0FBRztvQkFDMUIsTUFBTTlJLGdCQUFnQjsyQkFBSTZJLGVBQWU3SSxhQUFhO3FCQUFDO29CQUN2RCxNQUFNK0ksT0FBTy9JLGFBQWEsQ0FBQzhJLGtCQUFrQjtvQkFDN0MsTUFBTUUsY0FBYzt3QkFDbEIsR0FBR0QsSUFBSTt3QkFDUEUsbUJBQW1CYixZQUFZSCxVQUFVO3dCQUN6Q2lCLHNCQUFzQnpDLGdCQUFnQixVQUFVLHVCQUFhRDtvQkFDL0Q7b0JBQ0F4RyxhQUFhLENBQUM4SSxrQkFBa0IsR0FBR0U7b0JBQ25DNUosSUFBSTt3QkFBRVk7b0JBQWM7b0JBRXBCLElBQUk7d0JBQ0YsTUFBTVgsTUFBTThKLG1CQUFtQixDQUFDSDtvQkFDbEMsRUFBRSxPQUFPN0YsR0FBRzt3QkFDVjVCLFFBQVE3QixLQUFLLENBQUMsZ0RBQWdEeUQ7b0JBQ2hFO2dCQUNGO1lBRUYsRUFBRSxPQUFPekQsT0FBTztnQkFDZDZCLFFBQVE3QixLQUFLLENBQUMsMkJBQTJCQTtnQkFDekMsaUJBQWlCO2dCQUNqQixNQUFNNEksa0JBQWtCLElBQUluSSxJQUFJZCxNQUFNYSxRQUFRO2dCQUM5QyxNQUFNcUksZUFBZUQsZ0JBQWdCakosR0FBRyxDQUFDa0gsc0JBQXNCLEVBQUU7Z0JBQ2pFLE1BQU1pQyxRQUFRRCxhQUFhRSxTQUFTLENBQUNDLENBQUFBLElBQUtBLEVBQUVyRixFQUFFLEtBQUtxRTtnQkFDbkQsSUFBSWMsVUFBVSxDQUFDLEdBQUc7b0JBQ2hCRCxZQUFZLENBQUNDLE1BQU0sQ0FBQ1QsTUFBTSxHQUFHO29CQUM3Qk8sZ0JBQWdCbEosR0FBRyxDQUFDbUgsbUJBQW1CZ0M7b0JBQ3ZDbkosSUFBSTt3QkFBRWMsVUFBVW9JO29CQUFnQjtnQkFDbEM7Z0JBQ0EsTUFBTTVJO1lBQ1I7UUFDRjtRQUVBMEosd0JBQXdCLENBQUMzSTtZQUN2QnJCLElBQUk7Z0JBQUVhLHFCQUFxQlE7WUFBUztZQUNwQyxJQUFJQSxVQUFVO2dCQUNacEIsTUFBTWdHLFlBQVksQ0FBQzVFO2dCQUVuQix1Q0FBdUM7Z0JBQ3ZDLE1BQU00SSxRQUFRaEs7Z0JBQ2QsTUFBTWlLLGlCQUFpQixJQUFJbkosSUFBSWtKLE1BQU0vSSxXQUFXO2dCQUNoRGdKLGVBQWVDLE1BQU0sQ0FBQzlJO2dCQUN0QnJCLElBQUk7b0JBQUVrQixhQUFhZ0o7Z0JBQWU7WUFDcEM7UUFDRjtRQUVBRSxZQUFZLE9BQU8vSTtZQUNqQixJQUFJO2dCQUNGLE1BQU0wRixVQUFVLE1BQU01SCxxQ0FBR0EsQ0FBQ2lMLFVBQVUsQ0FBQy9JO2dCQUNyQyxNQUFNNEksUUFBUWhLO2dCQUNkRCxJQUFJO29CQUFFVyxVQUFVOzJCQUFJc0osTUFBTXRKLFFBQVE7d0JBQUVvRztxQkFBUTtnQkFBQztnQkFFN0Msd0NBQXdDO2dCQUN4QyxNQUFNc0QsZUFBZUosTUFBTXJKLGFBQWEsQ0FBQytGLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRXZGLFFBQVEsS0FBS0E7Z0JBQ2xFLElBQUksQ0FBQ2dKLGNBQWM7b0JBQ2pCLE1BQU1DLGtCQUFnQzt3QkFDcENDLFNBQVN4RCxRQUFReUQsVUFBVTt3QkFDM0JuSixVQUFVMEYsUUFBUUYsZ0JBQWdCO3dCQUNsQzlFLFlBQVlnRixRQUFRaEYsVUFBVTt3QkFDOUJvQixjQUFjNEQsUUFBUTVELFlBQVk7d0JBQ2xDMEcsbUJBQW1CWjt3QkFDbkJhLHNCQUFzQmI7d0JBQ3RCd0IsY0FBYzt3QkFDZEMsV0FBVztvQkFDYjtvQkFDQTFLLElBQUk7d0JBQUVZLGVBQWU7NEJBQUMwSjsrQkFBb0JMLE1BQU1ySixhQUFhO3lCQUFDO29CQUFDO2dCQUNqRTtZQUNGLEVBQUUsT0FBT04sT0FBTztnQkFDZDZCLFFBQVE3QixLQUFLLENBQUMsMEJBQTBCQTtnQkFDeEMsTUFBTUE7WUFDUjtRQUNGO1FBRUFxSyxhQUFhLE9BQU9DO1lBQ2xCLElBQUk7Z0JBQ0YsT0FBTyxNQUFNekwscUNBQUdBLENBQUN3TCxXQUFXLENBQUNDO1lBQy9CLEVBQUUsT0FBT3RLLE9BQU87Z0JBQ2Q2QixRQUFRN0IsS0FBSyxDQUFDLDJCQUEyQkE7Z0JBQ3pDLE9BQU8sRUFBRTtZQUNYO1FBQ0Y7UUFFQXVLLG9CQUFvQixDQUFDQztZQUNuQixNQUFNYixRQUFRaEs7WUFDZCxNQUFNOEssaUJBQWlCRCxRQUFRcEUsZUFBZTtZQUM5QyxrQ0FBa0M7WUFDbEMsTUFBTTJCLGtCQUFrQnBJLE1BQU1hLFFBQVEsQ0FBQ2IsR0FBRyxDQUFDOEssbUJBQW1CLEVBQUU7WUFDaEUsTUFBTUMsU0FBUzNDLGdCQUFnQjRDLElBQUksQ0FBQzNCLENBQUFBLElBQUtBLEVBQUVyRixFQUFFLEtBQUs2RyxRQUFRN0csRUFBRTtZQUU1RCxJQUFJLENBQUMrRyxRQUFRO2dCQUNYLGtDQUFrQztnQkFDbEMsa0VBQWtFO2dCQUNsRSxNQUFNLEVBQUV6SyxVQUFVLEVBQUVJLFFBQVEsRUFBRSxHQUFHVjtnQkFDakMsSUFBSU0sY0FBY3VLLFFBQVExRSxpQkFBaUIsRUFBRTtvQkFDM0MsSUFBSTt3QkFDRixNQUFNRSxnQkFBZ0JDLEtBQUtDLEtBQUssQ0FBQ3NFLFFBQVExRSxpQkFBaUI7d0JBRTFELDBEQUEwRDt3QkFDMUQsTUFBTVcsVUFBVXBHLFNBQVNnRyxJQUFJLENBQzNCQyxDQUFBQSxJQUFLQSxFQUFFQyxnQkFBZ0IsS0FBS2lFLFFBQVFwRSxlQUFlO3dCQUVyRCxNQUFNRCxvQkFBb0JNLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU2hGLFVBQVUsS0FBSTt3QkFFakQsbUZBQW1GO3dCQUNuRitJLFFBQVF6RSxpQkFBaUIsR0FBRzVHLHVEQUFjQSxDQUN4QzZHLGVBQ0FHLG1CQUNBbEc7d0JBR0YsSUFBSXVLLFFBQVF6RSxpQkFBaUIsRUFBRTs0QkFDN0JsRSxRQUFRRSxHQUFHLENBQUM7d0JBQ2QsT0FBTzs0QkFDTEYsUUFBUUMsSUFBSSxDQUFDLDRDQUE0QzBJLFFBQVE3RyxFQUFFO3dCQUNyRTtvQkFDRixFQUFFLE9BQU9GLEdBQUc7d0JBQ1Y1QixRQUFRN0IsS0FBSyxDQUFDLHFDQUFxQ3lEO29CQUNyRDtnQkFDRjtnQkFFQSxNQUFNa0QsY0FBYyxJQUFJbEcsSUFBSWQsTUFBTWEsUUFBUTtnQkFDMUNtRyxZQUFZakgsR0FBRyxDQUFDK0ssZ0JBQWdCO3VCQUFJMUM7b0JBQWlCeUM7aUJBQVE7Z0JBQzdEOUssSUFBSTtvQkFBRWMsVUFBVW1HO2dCQUFZO2dCQUU1QiwyQkFBMkI7Z0JBQzNCLE1BQU1pRSxZQUFZakIsTUFBTXJKLGFBQWEsQ0FBQ3lJLFNBQVMsQ0FBQ3pDLENBQUFBLElBQUtBLEVBQUV2RixRQUFRLEtBQUswSjtnQkFDcEUsSUFBSUcsYUFBYSxHQUFHO29CQUNsQixNQUFNdEssZ0JBQWdCOzJCQUFJcUosTUFBTXJKLGFBQWE7cUJBQUM7b0JBQzlDLE1BQU1nSixjQUFjO3dCQUNsQixHQUFHaEosYUFBYSxDQUFDc0ssVUFBVTt3QkFDM0JyQixtQkFBbUJpQixRQUFRakMsVUFBVTt3QkFDckNpQixzQkFBc0JnQixRQUFRekUsaUJBQWlCLEdBQzFDeUUsUUFBUXBDLFlBQVksS0FBSyxVQUFVLHVCQUFhb0MsUUFBUXpFLGlCQUFpQixHQUMxRTt3QkFDSm9FLGNBQWMsQ0FBQzdKLGFBQWEsQ0FBQ3NLLFVBQVUsQ0FBQ1QsWUFBWSxJQUFJLEtBQUs7b0JBQy9EO29CQUNBN0osYUFBYSxDQUFDc0ssVUFBVSxHQUFHdEI7b0JBQzNCNUosSUFBSTt3QkFBRVk7b0JBQWM7b0JBRXBCLCtEQUErRDtvQkFDL0RYLE1BQU11SixjQUFjLENBQUNzQixTQUFTdEYsS0FBSyxDQUFDMkYsQ0FBQUEsTUFDbENoSixRQUFRN0IsS0FBSyxDQUFDLHlDQUF5QzZLO29CQUV6RGxMLE1BQU04SixtQkFBbUIsQ0FBQ0gsYUFBYXBFLEtBQUssQ0FBQzJGLENBQUFBLE1BQzNDaEosUUFBUTdCLEtBQUssQ0FBQywwREFBMEQ2SztnQkFFNUUsT0FBTztvQkFDTCxzRkFBc0Y7b0JBQ3RGLE1BQU1iLGtCQUFrQjt3QkFDdEJDLFNBQVNPLFFBQVF0QyxTQUFTO3dCQUMxQm5ILFVBQVUwSjt3QkFDVmhKLFlBQVlrSDt3QkFDWjlGLGNBQWM4Rjt3QkFDZFksbUJBQW1CaUIsUUFBUWpDLFVBQVU7d0JBQ3JDaUIsc0JBQXNCZ0IsUUFBUXpFLGlCQUFpQixHQUMxQ3lFLFFBQVFwQyxZQUFZLEtBQUssVUFBVSx1QkFBYW9DLFFBQVF6RSxpQkFBaUIsR0FDMUU7d0JBQ0pvRSxjQUFjO3dCQUNkQyxXQUFXO29CQUNiO29CQUNBMUssSUFBSTt3QkFBRVksZUFBZTs0QkFBQzBKOytCQUFvQkwsTUFBTXJKLGFBQWE7eUJBQUM7b0JBQUM7b0JBRS9EWCxNQUFNdUosY0FBYyxDQUFDc0IsU0FBU3RGLEtBQUssQ0FBQzJGLENBQUFBLE1BQ2xDaEosUUFBUTdCLEtBQUssQ0FBQyx5Q0FBeUM2SztvQkFFekRsTCxNQUFNOEosbUJBQW1CLENBQUNPLGlCQUFpQjlFLEtBQUssQ0FBQzJGLENBQUFBLE1BQy9DaEosUUFBUTdCLEtBQUssQ0FBQyw4REFBOEQ2SztnQkFFaEY7WUFDRjtRQUNGO1FBRUFDLGlCQUFpQjtZQUNmLElBQUk7Z0JBQ0YsTUFBTUMsVUFBVSxNQUFNbE0scUNBQUdBLENBQUNtTSxjQUFjO2dCQUN4Q3RMLElBQUk7b0JBQUVtQixhQUFha0s7Z0JBQVE7WUFDN0IsRUFBRSxPQUFPL0ssT0FBTztnQkFDZDZCLFFBQVE3QixLQUFLLENBQUMsZ0NBQWdDQTtZQUNoRDtRQUNGO1FBRUEscUNBQXFDO1FBRXJDaUwsZUFBZSxDQUFDQyxRQUFnQkM7WUFDOUIsTUFBTXhCLFFBQVFoSztZQUNkLE1BQU15TCxpQkFBaUIsSUFBSXpLLElBQUlnSixNQUFNakosV0FBVztZQUNoRCxJQUFJeUssVUFBVTtnQkFDWkMsZUFBZUMsR0FBRyxDQUFDSDtZQUNyQixPQUFPO2dCQUNMRSxlQUFldkIsTUFBTSxDQUFDcUI7WUFDeEI7WUFDQXhMLElBQUk7Z0JBQUVnQixhQUFhMEs7WUFBZTtRQUNwQztRQUVBRSxlQUFlLENBQUN2SyxVQUFrQndLO1lBQ2hDLE1BQU01QixRQUFRaEs7WUFDZCxNQUFNaUssaUJBQWlCLElBQUluSixJQUFJa0osTUFBTS9JLFdBQVc7WUFDaEQsSUFBSTJLLFVBQVU7Z0JBQ1ozQixlQUFlbEssR0FBRyxDQUFDcUIsVUFBVTtZQUMvQixPQUFPO2dCQUNMNkksZUFBZUMsTUFBTSxDQUFDOUk7WUFDeEI7WUFDQXJCLElBQUk7Z0JBQUVrQixhQUFhZ0o7WUFBZTtRQUNwQztRQUVBNEIsWUFBWSxJQUFNOUwsSUFBSTtnQkFBRU0sT0FBTztZQUFLO1FBRXBDLDZDQUE2QztRQUU3Q3lMLG9CQUFvQixPQUFPQyxXQUFtQkM7WUFDNUMsdURBQXVEO1lBQ3ZELElBQUk7Z0JBQ0YsMEJBQTBCO2dCQUMxQixNQUFNNUQsa0JBQWtCLElBQUl0SCxJQUFJZCxNQUFNYSxRQUFRO2dCQUM5QyxNQUFNb0wsZUFBZTdELGdCQUFnQnBJLEdBQUcsQ0FBQ2dNLHlCQUF5QixFQUFFO2dCQUNwRSxNQUFNL0Msa0JBQWtCZ0QsYUFBYUMsTUFBTSxDQUFDN0MsQ0FBQUEsSUFBS0EsRUFBRXJGLEVBQUUsS0FBSytIO2dCQUMxRDNELGdCQUFnQnJJLEdBQUcsQ0FBQ2lNLHNCQUFzQi9DO2dCQUMxQ2xKLElBQUk7b0JBQUVjLFVBQVV1SDtnQkFBZ0I7Z0JBRWhDLHdCQUF3QjtnQkFDeEIsTUFBTXhJLHlEQUFtQkEsQ0FBQ3VNLGFBQWEsQ0FBQ0o7Z0JBQ3hDN0osUUFBUUUsR0FBRyxDQUFDLDBDQUFnQzJKO1lBQzlDLEVBQUUsT0FBTzFMLE9BQU87Z0JBQ2Q2QixRQUFRN0IsS0FBSyxDQUFDLHFDQUFxQ0E7WUFDckQ7UUFDRjtRQUVBK0wsMEJBQTBCLE9BQU9MLFdBQW1CQztZQUNsRCx3REFBd0Q7WUFDeEQsSUFBSTtnQkFDRixnQ0FBZ0M7Z0JBQ2hDLE1BQU01RCxrQkFBa0IsSUFBSXRILElBQUlkLE1BQU1hLFFBQVE7Z0JBQzlDLE1BQU1vTCxlQUFlN0QsZ0JBQWdCcEksR0FBRyxDQUFDZ00seUJBQXlCLEVBQUU7Z0JBQ3BFLE1BQU0vQyxrQkFBa0JnRCxhQUFhSSxHQUFHLENBQUNoRCxDQUFBQTtvQkFDdkMsSUFBSUEsRUFBRXJGLEVBQUUsS0FBSytILFdBQVc7d0JBQ3RCLE9BQU87NEJBQ0wsR0FBRzFDLENBQUM7NEJBQ0pqRCxtQkFBbUI7NEJBQ25CRCxtQkFBbUJHLEtBQUs0QixTQUFTLENBQUM7Z0NBQUVvRSxTQUFTOzRCQUFLOzRCQUNsRDdELGNBQWM7d0JBQ2hCO29CQUNGO29CQUNBLE9BQU9ZO2dCQUNUO2dCQUNBakIsZ0JBQWdCckksR0FBRyxDQUFDaU0sc0JBQXNCL0M7Z0JBQzFDbEosSUFBSTtvQkFBRWMsVUFBVXVIO2dCQUFnQjtnQkFFaEMsK0JBQStCO2dCQUMvQixNQUFNeEkseURBQW1CQSxDQUFDMk0sb0JBQW9CLENBQUNSO2dCQUUvQywrQ0FBK0M7Z0JBQy9DcE0saURBQVNBLENBQUM2TSxpQkFBaUIsQ0FBQ1QsV0FBV0M7Z0JBRXZDLCtCQUErQjtnQkFDL0IsSUFBSTtvQkFDRixNQUFNOU0scUNBQUdBLENBQUNpTixhQUFhLENBQUNKO2dCQUMxQixFQUFFLE9BQU9qSSxHQUFHO29CQUNWNUIsUUFBUUMsSUFBSSxDQUFDLHVDQUF1QzJCO2dCQUN0RDtnQkFFQTVCLFFBQVFFLEdBQUcsQ0FBQywrQ0FBcUMySjtZQUNuRCxFQUFFLE9BQU8xTCxPQUFPO2dCQUNkNkIsUUFBUTdCLEtBQUssQ0FBQywwQ0FBMENBO1lBQzFEO1FBQ0Y7UUFFQW9NLFdBQVcsT0FBT3JMO1lBQ2hCLGlFQUFpRTtZQUNqRSxJQUFJO2dCQUNGLE1BQU0sRUFBRW5CLElBQUksRUFBRSxHQUFHRDtnQkFDakIsSUFBSSxDQUFDQyxNQUFNO2dCQUVYLHlCQUF5QjtnQkFDekIsTUFBTW1JLGtCQUFrQixJQUFJdEgsSUFBSWQsTUFBTWEsUUFBUTtnQkFDOUN1SCxnQkFBZ0JySSxHQUFHLENBQUNxQixVQUFVLEVBQUU7Z0JBQ2hDckIsSUFBSTtvQkFBRWMsVUFBVXVIO2dCQUFnQjtnQkFFaEMsdUJBQXVCO2dCQUN2QixNQUFNeEkseURBQW1CQSxDQUFDOE0seUJBQXlCLENBQUN0TCxVQUFVbkIsS0FBS21CLFFBQVE7Z0JBRTNFLDhCQUE4QjtnQkFDOUIsTUFBTVQsZ0JBQWdCO3VCQUFJWCxNQUFNVyxhQUFhO2lCQUFDO2dCQUM5QyxNQUFNc0ssWUFBWXRLLGNBQWN5SSxTQUFTLENBQUN6QyxDQUFBQSxJQUFLQSxFQUFFdkYsUUFBUSxLQUFLQTtnQkFDOUQsSUFBSTZKLGFBQWEsR0FBRztvQkFDbEJ0SyxhQUFhLENBQUNzSyxVQUFVLEdBQUc7d0JBQ3pCLEdBQUd0SyxhQUFhLENBQUNzSyxVQUFVO3dCQUMzQnBCLHNCQUFzQmI7d0JBQ3RCWSxtQkFBbUJaO3dCQUNuQndCLGNBQWM7b0JBQ2hCO29CQUNBekssSUFBSTt3QkFBRVk7b0JBQWM7Z0JBQ3RCO2dCQUVBdUIsUUFBUUUsR0FBRyxDQUFDLHNDQUE0QmhCO1lBQzFDLEVBQUUsT0FBT2YsT0FBTztnQkFDZDZCLFFBQVE3QixLQUFLLENBQUMseUJBQXlCQTtZQUN6QztRQUNGO1FBRUFzTSwrQkFBK0IsT0FBT3ZMO1lBQ3BDLDRDQUE0QztZQUM1QyxJQUFJO2dCQUNGLE1BQU0sRUFBRW5CLElBQUksRUFBRSxHQUFHRDtnQkFDakIsSUFBSSxDQUFDQyxNQUFNO2dCQUVYLDBCQUEwQjtnQkFDMUIsTUFBTW1JLGtCQUFrQixJQUFJdEgsSUFBSWQsTUFBTWEsUUFBUTtnQkFDOUN1SCxnQkFBZ0I4QixNQUFNLENBQUM5STtnQkFDdkJyQixJQUFJO29CQUFFYyxVQUFVdUg7Z0JBQWdCO2dCQUVoQyxnQ0FBZ0M7Z0JBQ2hDLE1BQU16SCxnQkFBZ0JYLE1BQU1XLGFBQWEsQ0FBQ3VMLE1BQU0sQ0FBQ3ZGLENBQUFBLElBQUtBLEVBQUV2RixRQUFRLEtBQUtBO2dCQUNyRXJCLElBQUk7b0JBQUVZO2dCQUFjO2dCQUVwQix1REFBdUQ7Z0JBQ3ZELElBQUlYLE1BQU1ZLG1CQUFtQixLQUFLUSxVQUFVO29CQUMxQ3JCLElBQUk7d0JBQUVhLHFCQUFxQjtvQkFBSztnQkFDbEM7Z0JBRUEsd0JBQXdCO2dCQUN4QixNQUFNaEIseURBQW1CQSxDQUFDZ04sa0JBQWtCLENBQUN4TDtnQkFFN0MsK0NBQStDO2dCQUMvQ3pCLGlEQUFTQSxDQUFDa04sc0JBQXNCLENBQUN6TDtnQkFFakMsK0JBQStCO2dCQUMvQixJQUFJO29CQUNGLE1BQU1sQyxxQ0FBR0EsQ0FBQzBOLGtCQUFrQixDQUFDeEw7Z0JBQy9CLEVBQUUsT0FBTzBDLEdBQUc7b0JBQ1Y1QixRQUFRQyxJQUFJLENBQUMsNENBQTRDMkI7Z0JBQzNEO2dCQUVBNUIsUUFBUUUsR0FBRyxDQUFDLG9EQUEwQ2hCO1lBQ3hELEVBQUUsT0FBT2YsT0FBTztnQkFDZDZCLFFBQVE3QixLQUFLLENBQUMsK0NBQStDQTtZQUMvRDtRQUNGO1FBRUF5TSwyQkFBMkIsQ0FBQ2YsV0FBbUJqQjtZQUM3Qyx5REFBeUQ7WUFDekQsTUFBTTFDLGtCQUFrQixJQUFJdEgsSUFBSWQsTUFBTWEsUUFBUTtZQUM5QyxNQUFNb0wsZUFBZTdELGdCQUFnQnBJLEdBQUcsQ0FBQzhLLG1CQUFtQixFQUFFO1lBQzlELE1BQU03QixrQkFBa0JnRCxhQUFhSSxHQUFHLENBQUNoRCxDQUFBQTtnQkFDdkMsSUFBSUEsRUFBRXJGLEVBQUUsS0FBSytILFdBQVc7b0JBQ3RCLE9BQU87d0JBQ0wsR0FBRzFDLENBQUM7d0JBQ0pqRCxtQkFBbUI7d0JBQ25CRCxtQkFBbUJHLEtBQUs0QixTQUFTLENBQUM7NEJBQUVvRSxTQUFTO3dCQUFLO3dCQUNsRDdELGNBQWM7b0JBQ2hCO2dCQUNGO2dCQUNBLE9BQU9ZO1lBQ1Q7WUFDQWpCLGdCQUFnQnJJLEdBQUcsQ0FBQytLLGdCQUFnQjdCO1lBQ3BDbEosSUFBSTtnQkFBRWMsVUFBVXVIO1lBQWdCO1lBRWhDLG1CQUFtQjtZQUNuQnhJLHlEQUFtQkEsQ0FBQzJNLG9CQUFvQixDQUFDUixXQUFXeEcsS0FBSyxDQUFDckQsUUFBUTdCLEtBQUs7WUFDdkU2QixRQUFRRSxHQUFHLENBQUMsa0RBQXdDMko7UUFDdEQ7UUFFQWdCLGdDQUFnQyxDQUFDakM7WUFDL0IsOERBQThEO1lBQzlELE1BQU0xQyxrQkFBa0IsSUFBSXRILElBQUlkLE1BQU1hLFFBQVE7WUFDOUN1SCxnQkFBZ0I4QixNQUFNLENBQUNZO1lBQ3ZCL0ssSUFBSTtnQkFBRWMsVUFBVXVIO1lBQWdCO1lBRWhDLGdDQUFnQztZQUNoQyxNQUFNekgsZ0JBQWdCWCxNQUFNVyxhQUFhLENBQUN1TCxNQUFNLENBQUN2RixDQUFBQSxJQUFLQSxFQUFFdkYsUUFBUSxLQUFLMEo7WUFDckUvSyxJQUFJO2dCQUFFWTtZQUFjO1lBRXBCLHVEQUF1RDtZQUN2RCxJQUFJWCxNQUFNWSxtQkFBbUIsS0FBS2tLLGdCQUFnQjtnQkFDaEQvSyxJQUFJO29CQUFFYSxxQkFBcUI7Z0JBQUs7WUFDbEM7WUFFQSx3QkFBd0I7WUFDeEJoQix5REFBbUJBLENBQUNnTixrQkFBa0IsQ0FBQzlCLGdCQUFnQnZGLEtBQUssQ0FBQ3JELFFBQVE3QixLQUFLO1lBQzFFNkIsUUFBUUUsR0FBRyxDQUFDLHVEQUE2QzBJO1FBQzNEO1FBRUEsK0NBQStDO1FBRS9DekYsbUJBQW1CO1lBQ2pCLElBQUk7Z0JBQ0ZuRCxRQUFRRSxHQUFHLENBQUM7Z0JBRVoscUJBQXFCO2dCQUNyQixNQUFNNEssc0JBQXNCLE1BQU1wTix5REFBbUJBLENBQUNxTixtQkFBbUI7Z0JBQ3pFLElBQUlELG9CQUFvQkUsTUFBTSxHQUFHLEdBQUc7b0JBQ2xDLE1BQU12TSxnQkFBZ0JxTSxvQkFBb0JYLEdBQUcsQ0FBQzNDLENBQUFBLE9BQVM7NEJBQ3JEWSxTQUFTWixLQUFLWSxPQUFPOzRCQUNyQmxKLFVBQVVzSSxLQUFLdEksUUFBUTs0QkFDdkJVLFlBQVk0SCxLQUFLNUgsVUFBVTs0QkFDM0JvQixjQUFjd0csS0FBS3hHLFlBQVk7NEJBQy9CMEcsbUJBQW1CRixLQUFLRSxpQkFBaUI7NEJBQ3pDQyxzQkFBc0JILEtBQUtHLG9CQUFvQjs0QkFDL0NXLGNBQWNkLEtBQUtjLFlBQVk7NEJBQy9CQyxXQUFXZixLQUFLZSxTQUFTO3dCQUMzQjtvQkFDQTFLLElBQUk7d0JBQUVZO29CQUFjO29CQUNwQnVCLFFBQVFFLEdBQUcsQ0FBQyx1QkFBa0MsT0FBckJ6QixjQUFjdU0sTUFBTSxFQUFDO2dCQUNoRDtnQkFFQSxnQkFBZ0I7Z0JBQ2hCLE1BQU1DLGlCQUFpQixNQUFNdk4seURBQW1CQSxDQUFDd04sY0FBYztnQkFDL0QsSUFBSUQsZUFBZUQsTUFBTSxHQUFHLEdBQUc7b0JBQzdCLE1BQU14TSxXQUFXeU0sZUFBZWQsR0FBRyxDQUFDdkYsQ0FBQUEsVUFBWTs0QkFDOUM5QyxJQUFJOEMsUUFBUTlDLEVBQUU7NEJBQ2RzRyxTQUFTeEQsUUFBUXdELE9BQU87NEJBQ3hCQyxZQUFZekQsUUFBUXlELFVBQVU7NEJBQzlCM0Qsa0JBQWtCRSxRQUFRRixnQkFBZ0I7NEJBQzFDeUcsZUFBZXZHLFFBQVF1RyxhQUFhOzRCQUNwQ3ZMLFlBQVlnRixRQUFRaEYsVUFBVTs0QkFDOUJvQixjQUFjNEQsUUFBUTVELFlBQVk7NEJBQ2xDb0ssVUFBVXhHLFFBQVF3RyxRQUFROzRCQUMxQkMsWUFBWXpHLFFBQVF5RyxVQUFVOzRCQUM5QkMsYUFBYTFHLFFBQVEwRyxXQUFXOzRCQUNoQ0MsVUFBVTNHLFFBQVEyRyxRQUFRO3dCQUM1QjtvQkFDQTFOLElBQUk7d0JBQUVXO29CQUFTO29CQUNmd0IsUUFBUUUsR0FBRyxDQUFDLHVCQUE2QixPQUFoQjFCLFNBQVN3TSxNQUFNLEVBQUM7Z0JBQzNDO2dCQUVBLHNDQUFzQztnQkFDdEMsTUFBTSxFQUFFak4sSUFBSSxFQUFFLEdBQUdEO2dCQUNqQixJQUFJQyxNQUFNO29CQUNSLE1BQU15TixjQUFjLElBQUk1TTtvQkFDeEIsS0FBSyxNQUFNNEksUUFBUXNELG9CQUFxQjt3QkFDdEMsTUFBTVcsaUJBQWlCLE1BQU0vTix5REFBbUJBLENBQUNnTyx1QkFBdUIsQ0FDdEVsRSxLQUFLdEksUUFBUSxFQUNibkIsS0FBS21CLFFBQVEsRUFDYjt3QkFHRixJQUFJdU0sZUFBZVQsTUFBTSxHQUFHLEdBQUc7NEJBQzdCLE1BQU1yTSxXQUFXOE0sZUFBZXRCLEdBQUcsQ0FBQ25HLENBQUFBLE1BQVE7b0NBQzFDbEMsSUFBSWtDLElBQUlsQyxFQUFFO29DQUNWdUUsV0FBV3JDLElBQUlxQyxTQUFTO29DQUN4QjlCLGlCQUFpQlAsSUFBSU8sZUFBZTtvQ0FDcEMrQixjQUFjdEMsSUFBSXNDLFlBQVk7b0NBQzlCM0Isb0JBQW9CWCxJQUFJVyxrQkFBa0I7b0NBQzFDVixtQkFBbUJELElBQUlDLGlCQUFpQjtvQ0FDeEMwSCxlQUFlM0gsSUFBSTJILGFBQWE7b0NBQ2hDcEYsY0FBY3ZDLElBQUl1QyxZQUFZO29DQUM5QkMsUUFBUXhDLElBQUl3QyxNQUFNO29DQUNsQkUsWUFBWTFDLElBQUkwQyxVQUFVO29DQUMxQmtGLGNBQWM1SCxJQUFJNEgsWUFBWTtvQ0FDOUJDLFNBQVM3SCxJQUFJNkgsT0FBTztvQ0FDcEJwRixhQUFhekMsSUFBSXlDLFdBQVc7b0NBQzVCcUYsWUFBWTlILElBQUk4SCxVQUFVO29DQUMxQkMsZUFBZS9ILElBQUkrSCxhQUFhO2dDQUNsQzs0QkFDQVAsWUFBWTNOLEdBQUcsQ0FBQzJKLEtBQUt0SSxRQUFRLEVBQUVQO3dCQUNqQztvQkFDRjtvQkFDQWQsSUFBSTt3QkFBRWMsVUFBVTZNO29CQUFZO29CQUM1QnhMLFFBQVFFLEdBQUcsQ0FBQyxvQ0FBMkMsT0FBakJzTCxZQUFZUSxJQUFJLEVBQUM7Z0JBQ3pEO1lBRUYsRUFBRSxPQUFPN04sT0FBTztnQkFDZDZCLFFBQVE3QixLQUFLLENBQUMsb0NBQW9DQTtZQUNwRDtRQUNGO1FBRUFpRixnQkFBZ0I7WUFDZCxJQUFJO2dCQUNGcEQsUUFBUUUsR0FBRyxDQUFDO2dCQUVaLDhCQUE4QjtnQkFDOUIsTUFBTXBDLE1BQU00RixZQUFZO2dCQUN4QixNQUFNNUYsTUFBTThGLGlCQUFpQjtnQkFFN0Isa0RBQWtEO2dCQUNsRCxNQUFNcUksdUJBQXVCLE1BQU1qUCxxQ0FBR0EsQ0FBQ2tQLCtCQUErQjtnQkFFdEUsd0NBQXdDO2dCQUN4QyxNQUFNLEVBQUVuTyxJQUFJLEVBQUVTLFFBQVEsRUFBRUMsYUFBYSxFQUFFLEdBQUdYO2dCQUMxQyxJQUFJQyxNQUFNO29CQUNSLGtDQUFrQztvQkFDbEMsTUFBTStNLHNCQUE0Q3JNLGNBQWMwTCxHQUFHLENBQUMzQyxDQUFBQSxPQUFTOzRCQUMzRXRJLFVBQVVzSSxLQUFLdEksUUFBUTs0QkFDdkJrSixTQUFTWixLQUFLWSxPQUFPOzRCQUNyQnhJLFlBQVk0SCxLQUFLNUgsVUFBVTs0QkFDM0JvQixjQUFjd0csS0FBS3hHLFlBQVk7NEJBQy9CMEcsbUJBQW1CRixLQUFLRSxpQkFBaUI7NEJBQ3pDQyxzQkFBc0JILEtBQUtHLG9CQUFvQjs0QkFDL0NXLGNBQWNkLEtBQUtjLFlBQVk7NEJBQy9CQyxXQUFXZixLQUFLZSxTQUFTO3dCQUMzQjtvQkFDQSxNQUFNN0sseURBQW1CQSxDQUFDeU8saUJBQWlCLENBQUNyQjtvQkFFNUMsNkJBQTZCO29CQUM3QixNQUFNRyxpQkFBa0N6TSxTQUFTMkwsR0FBRyxDQUFDdkYsQ0FBQUEsVUFBWTs0QkFDL0Q5QyxJQUFJOEMsUUFBUTlDLEVBQUU7NEJBQ2RzRyxTQUFTeEQsUUFBUXdELE9BQU87NEJBQ3hCQyxZQUFZekQsUUFBUXlELFVBQVU7NEJBQzlCM0Qsa0JBQWtCRSxRQUFRRixnQkFBZ0I7NEJBQzFDeUcsZUFBZXZHLFFBQVF1RyxhQUFhOzRCQUNwQ3ZMLFlBQVlnRixRQUFRaEYsVUFBVTs0QkFDOUJvQixjQUFjNEQsUUFBUTVELFlBQVk7NEJBQ2xDb0ssVUFBVXhHLFFBQVF3RyxRQUFROzRCQUMxQkMsWUFBWXpHLFFBQVF5RyxVQUFVOzRCQUM5QkMsYUFBYTFHLFFBQVEwRyxXQUFXOzRCQUNoQ0MsVUFBVTNHLFFBQVEyRyxRQUFRO3dCQUM1QjtvQkFDQSxNQUFNN04seURBQW1CQSxDQUFDME8sWUFBWSxDQUFDbkI7b0JBRXZDLDZCQUE2QjtvQkFDN0IsS0FBSyxNQUFNLENBQUMvTCxVQUFVUCxTQUFTLElBQUkwTixPQUFPQyxPQUFPLENBQUNMLHNCQUF1Qjt3QkFDdkUsTUFBTVIsaUJBQWtDLFNBQXdCdEIsR0FBRyxDQUFDbkcsQ0FBQUEsTUFBUTtnQ0FDMUVsQyxJQUFJa0MsSUFBSWxDLEVBQUU7Z0NBQ1Z1RSxXQUFXckMsSUFBSXFDLFNBQVM7Z0NBQ3hCOUIsaUJBQWlCUCxJQUFJTyxlQUFlO2dDQUNwQytCLGNBQWN0QyxJQUFJc0MsWUFBWTtnQ0FDOUIzQixvQkFBb0JYLElBQUlXLGtCQUFrQjtnQ0FDMUNWLG1CQUFtQkQsSUFBSUMsaUJBQWlCO2dDQUN4QzBILGVBQWUzSCxJQUFJMkgsYUFBYTtnQ0FDaENwRixjQUFjdkMsSUFBSXVDLFlBQVk7Z0NBQzlCQyxRQUFReEMsSUFBSXdDLE1BQU07Z0NBQ2xCRSxZQUFZMUMsSUFBSTBDLFVBQVU7Z0NBQzFCa0YsY0FBYzVILElBQUk0SCxZQUFZO2dDQUM5QkMsU0FBUzdILElBQUk2SCxPQUFPO2dDQUNwQnBGLGFBQWF6QyxJQUFJeUMsV0FBVztnQ0FDNUJxRixZQUFZOUgsSUFBSThILFVBQVU7Z0NBQzFCQyxlQUFlL0gsSUFBSStILGFBQWE7NEJBQ2xDO3dCQUNBLE1BQU1yTyx5REFBbUJBLENBQUM2TyxZQUFZLENBQUNkO29CQUN6QztvQkFFQSx5QkFBeUI7b0JBQ3pCLE1BQU1ELGNBQWMsSUFBSTVNO29CQUN4QixLQUFLLE1BQU0sQ0FBQ00sVUFBVVAsU0FBUyxJQUFJME4sT0FBT0MsT0FBTyxDQUFDTCxzQkFBdUI7d0JBQ3ZFVCxZQUFZM04sR0FBRyxDQUFDcUIsVUFBVVA7b0JBQzVCO29CQUNBZCxJQUFJO3dCQUFFYyxVQUFVNk07b0JBQVk7b0JBRTVCeEwsUUFBUUUsR0FBRyxDQUFDO2dCQUNkO1lBQ0YsRUFBRSxPQUFPL0IsT0FBTztnQkFDZDZCLFFBQVE3QixLQUFLLENBQUMsa0JBQWtCQTtZQUNsQztRQUNGO1FBRUFrSixnQkFBZ0IsT0FBT3NCO1lBQ3JCLElBQUk7Z0JBQ0YsTUFBTTZELGdCQUErQjtvQkFDbkMxSyxJQUFJNkcsUUFBUTdHLEVBQUU7b0JBQ2R1RSxXQUFXc0MsUUFBUXRDLFNBQVM7b0JBQzVCOUIsaUJBQWlCb0UsUUFBUXBFLGVBQWU7b0JBQ3hDK0IsY0FBY3FDLFFBQVFyQyxZQUFZO29CQUNsQzNCLG9CQUFvQmdFLFFBQVFoRSxrQkFBa0I7b0JBQzlDVixtQkFBbUIwRSxRQUFRMUUsaUJBQWlCO29CQUM1QzBILGVBQWVoRCxRQUFRZ0QsYUFBYTtvQkFDcENwRixjQUFjb0MsUUFBUXBDLFlBQVk7b0JBQ2xDQyxRQUFRbUMsUUFBUW5DLE1BQU07b0JBQ3RCRSxZQUFZaUMsUUFBUWpDLFVBQVU7b0JBQzlCa0YsY0FBY2pELFFBQVFpRCxZQUFZO29CQUNsQ0MsU0FBU2xELFFBQVFrRCxPQUFPO29CQUN4QnBGLGFBQWFrQyxRQUFRbEMsV0FBVztvQkFDaENxRixZQUFZbkQsUUFBUW1ELFVBQVU7b0JBQzlCQyxlQUFlcEQsUUFBUW9ELGFBQWE7Z0JBQ3RDO2dCQUNBLE1BQU1yTyx5REFBbUJBLENBQUMrTyxXQUFXLENBQUNEO1lBQ3hDLEVBQUUsT0FBT3JPLE9BQU87Z0JBQ2Q2QixRQUFRN0IsS0FBSyxDQUFDLGdDQUFnQ0E7WUFDaEQ7UUFDRjtRQUVBeUoscUJBQXFCLE9BQU84RTtZQUMxQixJQUFJO2dCQUNGLE1BQU1DLHFCQUF5QztvQkFDN0N6TixVQUFVd04sYUFBYXhOLFFBQVE7b0JBQy9Ca0osU0FBU3NFLGFBQWF0RSxPQUFPO29CQUM3QnhJLFlBQVk4TSxhQUFhOU0sVUFBVTtvQkFDbkNvQixjQUFjMEwsYUFBYTFMLFlBQVk7b0JBQ3ZDMEcsbUJBQW1CZ0YsYUFBYWhGLGlCQUFpQjtvQkFDakRDLHNCQUFzQitFLGFBQWEvRSxvQkFBb0I7b0JBQ3ZEVyxjQUFjb0UsYUFBYXBFLFlBQVk7b0JBQ3ZDQyxXQUFXbUUsYUFBYW5FLFNBQVM7Z0JBQ25DO2dCQUNBLE1BQU03Syx5REFBbUJBLENBQUNrUCxnQkFBZ0IsQ0FBQ0Q7WUFDN0MsRUFBRSxPQUFPeE8sT0FBTztnQkFDZDZCLFFBQVE3QixLQUFLLENBQUMscUNBQXFDQTtZQUNyRDtRQUNGO1FBRUEwTyw0QkFBNEI7WUFDMUIsSUFBSTtnQkFDRixNQUFNLEVBQUVwTyxhQUFhLEVBQUUsR0FBR1g7Z0JBQzFCa0MsUUFBUUUsR0FBRyxDQUFDLG9DQUErQyxPQUFyQnpCLGNBQWN1TSxNQUFNLEVBQUM7Z0JBRTNELEtBQUssTUFBTXhELFFBQVEvSSxjQUFlO29CQUNoQyxNQUFNWCxNQUFNZ0csWUFBWSxDQUFDMEQsS0FBS3RJLFFBQVE7b0JBQ3RDLGlEQUFpRDtvQkFDakQsTUFBTSxJQUFJNE4sUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztnQkFDbkQ7Z0JBRUEvTSxRQUFRRSxHQUFHLENBQUM7WUFDZCxFQUFFLE9BQU8vQixPQUFPO2dCQUNkNkIsUUFBUTdCLEtBQUssQ0FBQywwQ0FBMENBO1lBQzFEO1FBQ0Y7SUFDRixJQUNBO0lBQ0U4TyxNQUFNO0lBQ05DLFlBQVksQ0FBQ3BGLFFBQVc7WUFDdEIsa0NBQWtDO1lBQ2xDcEoscUJBQXFCb0osTUFBTXBKLG1CQUFtQjtRQUNoRDtBQUNGLElBRUY7QUFFRixtQ0FBbUM7QUFDbkMsU0FBU3dELHVCQUF1QnBFLEdBQW1CLEVBQUVELEdBQXVDO0lBQzFGLDJCQUEyQjtJQUMzQkosaURBQVNBLENBQUMwUCxFQUFFLENBQUMsV0FBVyxDQUFDN0w7WUFXUHdHLGFBQ01BO1FBWHRCOUgsUUFBUUUsR0FBRyxDQUFDLGtDQUF3Qm9CO1FBRXBDLE1BQU13RyxRQUFRaEs7UUFDZCxNQUFNOEssaUJBQWlCdEgsS0FBS2lELGVBQWU7UUFFM0Msd0JBQXdCO1FBQ3hCLE1BQU1vRSxVQUFtQjtZQUN2QjdHLElBQUlSLEtBQUs4TCxVQUFVO1lBQ25CL0csV0FBVy9FLEtBQUsrRSxTQUFTO1lBQ3pCOUIsaUJBQWlCcUU7WUFDakJ0QyxjQUFjd0IsRUFBQUEsY0FBQUEsTUFBTS9KLElBQUksY0FBVitKLGtDQUFBQSxZQUFZaEcsRUFBRSxLQUFJO1lBQ2hDNkMsb0JBQW9CbUQsRUFBQUEsZUFBQUEsTUFBTS9KLElBQUksY0FBVitKLG1DQUFBQSxhQUFZNUksUUFBUSxLQUFJO1lBQzVDK0UsbUJBQW1CM0MsS0FBSzJELE9BQU8sSUFBSTNELEtBQUsyQyxpQkFBaUI7WUFDekQwSCxlQUFlckssS0FBS3FLLGFBQWE7WUFDakNwRixjQUFjakYsS0FBS2lGLFlBQVksSUFBSTtZQUNuQ0MsUUFBUTtZQUNSQyxhQUFhbkYsS0FBS21GLFdBQVcsSUFBSTtZQUNqQ0MsWUFBWXBGLEtBQUsrTCxTQUFTO1FBQzVCO1FBRUF2UCxNQUFNNEssa0JBQWtCLENBQUNDO1FBRXpCLHdCQUF3QjtRQUN4QmxMLGlEQUFTQSxDQUFDNlAsbUJBQW1CLENBQUNoTSxLQUFLOEwsVUFBVSxFQUFFOUwsS0FBSytFLFNBQVM7SUFDL0Q7SUFFQSwyQkFBMkI7SUFDM0I1SSxpREFBU0EsQ0FBQzBQLEVBQUUsQ0FBQyxVQUFVLENBQUM3TDtRQUN0QnhELE1BQU0yTCxhQUFhLENBQUNuSSxLQUFLaUQsZUFBZSxFQUFFakQsS0FBS2lNLFNBQVM7UUFFeEQsb0NBQW9DO1FBQ3BDLElBQUlqTSxLQUFLaU0sU0FBUyxFQUFFO1lBQ2xCUCxXQUFXO2dCQUNUbFAsTUFBTTJMLGFBQWEsQ0FBQ25JLEtBQUtpRCxlQUFlLEVBQUU7WUFDNUMsR0FBRztRQUNMO0lBQ0Y7SUFFQSwwQkFBMEI7SUFDMUI5RyxpREFBU0EsQ0FBQzBQLEVBQUUsQ0FBQyxZQUFZLENBQUM3TDtRQUN4QnhELE1BQU1zTCxhQUFhLENBQUM5SCxLQUFLOEcsT0FBTyxFQUFFOUcsS0FBS2lILFNBQVM7SUFDbEQ7SUFFQSxvQ0FBb0M7SUFDcEM5SyxpREFBU0EsQ0FBQzBQLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQzdMO1FBQzVCdEIsUUFBUUUsR0FBRyxDQUFDLGdDQUFnQ29CO0lBQzlDO0lBRUEsdUJBQXVCO0lBQ3ZCN0QsaURBQVNBLENBQUMwUCxFQUFFLENBQUMsZ0JBQWdCLENBQUM3TDtRQUM1QnRCLFFBQVFFLEdBQUcsQ0FBQywrQkFBcUJvQjtJQUNqQyx5Q0FBeUM7SUFDM0M7SUFFQSwyQkFBMkI7SUFDM0I3RCxpREFBU0EsQ0FBQzBQLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQzdMO1FBQ2hDdEIsUUFBUUUsR0FBRyxDQUFDLGtDQUF3Qm9CO0lBQ3BDLHlDQUF5QztJQUMzQztJQUVBLGlDQUFpQztJQUNqQzdELGlEQUFTQSxDQUFDMFAsRUFBRSxDQUFDLGFBQWEsQ0FBQzdMO1FBQ3pCdEIsUUFBUUUsR0FBRyxDQUFDLDBCQUEwQm9CO0lBQ3hDO0lBRUEsZ0JBQWdCO0lBQ2hCN0QsaURBQVNBLENBQUMwUCxFQUFFLENBQUMsU0FBUyxDQUFDN0w7UUFDckJ0QixRQUFRN0IsS0FBSyxDQUFDLHNCQUFzQm1EO0lBQ3RDO0lBRUEsaUNBQWlDO0lBQ2pDN0QsaURBQVNBLENBQUMwUCxFQUFFLENBQUMsMkJBQTJCLENBQUM3TDtZQUVGQSxZQUNVQTtRQUYvQ3RCLFFBQVFFLEdBQUcsQ0FBQyxpREFBdUNvQjtRQUNuRCxNQUFNdUksWUFBWXZJLEtBQUs4TCxVQUFVLE1BQUk5TCxhQUFBQSxLQUFLQSxJQUFJLGNBQVRBLGlDQUFBQSxXQUFXOEwsVUFBVTtRQUMxRCxNQUFNeEUsaUJBQWlCdEgsS0FBS2lELGVBQWUsTUFBSWpELGNBQUFBLEtBQUtBLElBQUksY0FBVEEsa0NBQUFBLFlBQVdpRCxlQUFlO1FBQ3pFLElBQUlzRixhQUFhakIsZ0JBQWdCO1lBQy9COUssTUFBTThNLHlCQUF5QixDQUFDZixXQUFXakI7UUFDN0M7SUFDRjtJQUVBLHNDQUFzQztJQUN0Q25MLGlEQUFTQSxDQUFDMFAsRUFBRSxDQUFDLGdDQUFnQyxDQUFDN0w7WUFFR0E7UUFEL0N0QixRQUFRRSxHQUFHLENBQUMsc0RBQTRDb0I7UUFDeEQsTUFBTXNILGlCQUFpQnRILEtBQUtpRCxlQUFlLE1BQUlqRCxhQUFBQSxLQUFLQSxJQUFJLGNBQVRBLGlDQUFBQSxXQUFXaUQsZUFBZTtRQUN6RSxJQUFJcUUsZ0JBQWdCO1lBQ2xCOUssTUFBTStNLDhCQUE4QixDQUFDakM7UUFDdkM7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvc3RvcmUudHM/YWQzMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ2lwaGVyTGluayBHbG9iYWwgU3RhdGUgU3RvcmVcclxuICogVXNlcyBadXN0YW5kIGZvciBzdGF0ZSBtYW5hZ2VtZW50XHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCc7XHJcbmltcG9ydCB7IHBlcnNpc3QgfSBmcm9tICd6dXN0YW5kL21pZGRsZXdhcmUnO1xyXG5pbXBvcnQgeyBhcGksIFVzZXIsIENvbnRhY3QsIENvbnZlcnNhdGlvbiwgTWVzc2FnZSwgQ2FsbExvZyB9IGZyb20gJy4vYXBpJztcclxuaW1wb3J0IHtcclxuICBnZW5lcmF0ZUtleVBhaXIsXHJcbiAgZ2VuZXJhdGVTaWduaW5nS2V5UGFpcixcclxuICBnZW5lcmF0ZUtleUJ1bmRsZSxcclxuICBLZXlTdG9yYWdlLFxyXG4gIGVuY3J5cHRNZXNzYWdlLFxyXG4gIGRlY3J5cHRNZXNzYWdlLFxyXG4gIEVuY3J5cHRlZE1lc3NhZ2UsXHJcbiAgdmVyaWZ5S2V5UGFpcixcclxuICBkZXJpdmVQdWJsaWNLZXlGcm9tUHJpdmF0ZVxyXG59IGZyb20gJy4vY3J5cHRvJztcclxuaW1wb3J0IHsgd3NNYW5hZ2VyIH0gZnJvbSAnLi93ZWJzb2NrZXQnO1xyXG5pbXBvcnQgeyBsb2NhbFN0b3JhZ2VNYW5hZ2VyLCBTdG9yZWRNZXNzYWdlLCBTdG9yZWRDb252ZXJzYXRpb24sIFN0b3JlZENvbnRhY3QgfSBmcm9tICcuL3N0b3JhZ2UnO1xyXG5pbXBvcnQgeyBidWlsZE1lc3NhZ2VUaGVtZSB9IGZyb20gJy4vdGhlbWVTeW5jJztcclxuXHJcbmludGVyZmFjZSBBdXRoU3RhdGUge1xyXG4gIHVzZXI6IFVzZXIgfCBudWxsO1xyXG4gIHRva2VuOiBzdHJpbmcgfCBudWxsO1xyXG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcclxuICBpc0xvYWRpbmc6IGJvb2xlYW47XHJcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XHJcbn1cclxuXHJcbmludGVyZmFjZSBDcnlwdG9TdGF0ZSB7XHJcbiAgcHJpdmF0ZUtleTogc3RyaW5nIHwgbnVsbDtcclxuICBwdWJsaWNLZXk6IHN0cmluZyB8IG51bGw7XHJcbiAgaWRlbnRpdHlLZXk6IHN0cmluZyB8IG51bGw7XHJcbiAgaWRlbnRpdHlQcml2YXRlS2V5OiBzdHJpbmcgfCBudWxsO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQ2hhdFN0YXRlIHtcclxuICBjb250YWN0czogQ29udGFjdFtdO1xyXG4gIGNvbnZlcnNhdGlvbnM6IENvbnZlcnNhdGlvbltdO1xyXG4gIGN1cnJlbnRDb252ZXJzYXRpb246IHN0cmluZyB8IG51bGw7IC8vIHVzZXJuYW1lXHJcbiAgbWVzc2FnZXM6IE1hcDxzdHJpbmcsIE1lc3NhZ2VbXT47IC8vIHVzZXJuYW1lIC0+IG1lc3NhZ2VzXHJcbiAgb25saW5lVXNlcnM6IFNldDxudW1iZXI+O1xyXG4gIHR5cGluZ1VzZXJzOiBNYXA8c3RyaW5nLCBib29sZWFuPjsgLy8gdXNlcm5hbWUgLT4gaXNUeXBpbmdcclxuICBjYWxsSGlzdG9yeTogQ2FsbExvZ1tdO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQXBwU3RhdGUgZXh0ZW5kcyBBdXRoU3RhdGUsIENyeXB0b1N0YXRlLCBDaGF0U3RhdGUge1xyXG4gIC8vIEF1dGggYWN0aW9uc1xyXG4gIGxvZ2luOiAodXNlcm5hbWU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxuICByZWdpc3RlcjogKHVzZXJuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XHJcbiAgbG9nb3V0OiAoKSA9PiB2b2lkO1xyXG4gIGxvYWRTdG9yZWRBdXRoOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAvLyBDcnlwdG8gYWN0aW9uc1xyXG4gIGdlbmVyYXRlQW5kVXBsb2FkS2V5czogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBsb2FkU3RvcmVkS2V5czogKCkgPT4gdm9pZDtcclxuXHJcbiAgLy8gQ2hhdCBhY3Rpb25zXHJcbiAgbG9hZENvbnRhY3RzOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGxvYWRDb252ZXJzYXRpb25zOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGxvYWRNZXNzYWdlczogKHVzZXJuYW1lOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XHJcbiAgbG9hZEFsbENvbnZlcnNhdGlvbkhpc3Rvcnk6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbiAgc3luY1dpdGhTZXJ2ZXI6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbiAgcGVyc2lzdE1lc3NhZ2U6IChtZXNzYWdlOiBNZXNzYWdlKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIHBlcnNpc3RDb252ZXJzYXRpb246IChjb252ZXJzYXRpb246IENvbnZlcnNhdGlvbikgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBsb2FkUGVyc2lzdGVkRGF0YTogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBzZW5kTWVzc2FnZTogKHJlY2lwaWVudFVzZXJuYW1lOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZywgbWVzc2FnZVR5cGU/OiBzdHJpbmcsIGZpbGVEYXRhPzogYW55KSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIHNldEN1cnJlbnRDb252ZXJzYXRpb246ICh1c2VybmFtZTogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcclxuICBhZGRDb250YWN0OiAodXNlcm5hbWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBzZWFyY2hVc2VyczogKHF1ZXJ5OiBzdHJpbmcpID0+IFByb21pc2U8QXJyYXk8eyBpZDogbnVtYmVyOyB1c2VybmFtZTogc3RyaW5nIH0+PjtcclxuICBhZGRJbmNvbWluZ01lc3NhZ2U6IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB2b2lkO1xyXG4gIGxvYWRDYWxsSGlzdG9yeTogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgLy8gRGVsZXRpb24gYWN0aW9uc1xyXG4gIGRlbGV0ZU1lc3NhZ2VGb3JNZTogKG1lc3NhZ2VJZDogbnVtYmVyLCBjb252ZXJzYXRpb25Vc2VybmFtZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGRlbGV0ZU1lc3NhZ2VGb3JFdmVyeW9uZTogKG1lc3NhZ2VJZDogbnVtYmVyLCBjb252ZXJzYXRpb25Vc2VybmFtZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGNsZWFyQ2hhdDogKHVzZXJuYW1lOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XHJcbiAgZGVsZXRlQ29udmVyc2F0aW9uRm9yRXZlcnlvbmU6ICh1c2VybmFtZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGhhbmRsZVJlbW90ZURlbGV0ZU1lc3NhZ2U6IChtZXNzYWdlSWQ6IG51bWJlciwgc2VuZGVyVXNlcm5hbWU6IHN0cmluZykgPT4gdm9pZDtcclxuICBoYW5kbGVSZW1vdGVEZWxldGVDb252ZXJzYXRpb246IChzZW5kZXJVc2VybmFtZTogc3RyaW5nKSA9PiB2b2lkO1xyXG5cclxuICAvLyBQcmVzZW5jZVxyXG4gIHNldFVzZXJPbmxpbmU6ICh1c2VySWQ6IG51bWJlciwgaXNPbmxpbmU6IGJvb2xlYW4pID0+IHZvaWQ7XHJcbiAgc2V0VXNlclR5cGluZzogKHVzZXJuYW1lOiBzdHJpbmcsIGlzVHlwaW5nOiBib29sZWFuKSA9PiB2b2lkO1xyXG5cclxuICAvLyBDbGVhciBzdGF0ZVxyXG4gIGNsZWFyRXJyb3I6ICgpID0+IHZvaWQ7XHJcbiAgaW5pdGlhbGl6ZVdlYlNvY2tldDogKCkgPT4gdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHVzZVN0b3JlID0gY3JlYXRlPEFwcFN0YXRlPigpKFxyXG4gIHBlcnNpc3QoXHJcbiAgICAoc2V0LCBnZXQpID0+ICh7XHJcbiAgICAgIC8vIEluaXRpYWwgc3RhdGVcclxuICAgICAgdXNlcjogbnVsbCxcclxuICAgICAgdG9rZW46IG51bGwsXHJcbiAgICAgIGlzQXV0aGVudGljYXRlZDogZmFsc2UsXHJcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgICBwcml2YXRlS2V5OiBudWxsLFxyXG4gICAgICBwdWJsaWNLZXk6IG51bGwsXHJcbiAgICAgIGlkZW50aXR5S2V5OiBudWxsLFxyXG4gICAgICBpZGVudGl0eVByaXZhdGVLZXk6IG51bGwsXHJcbiAgICAgIGNvbnRhY3RzOiBbXSxcclxuICAgICAgY29udmVyc2F0aW9uczogW10sXHJcbiAgICAgIGN1cnJlbnRDb252ZXJzYXRpb246IG51bGwsXHJcbiAgICAgIG1lc3NhZ2VzOiBuZXcgTWFwKCksXHJcbiAgICAgIG9ubGluZVVzZXJzOiBuZXcgU2V0KCksXHJcbiAgICAgIHR5cGluZ1VzZXJzOiBuZXcgTWFwKCksXHJcbiAgICAgIGNhbGxIaXN0b3J5OiBbXSxcclxuXHJcbiAgICAgIC8vID09PT09PT09PT09PSBBdXRoIEFjdGlvbnMgPT09PT09PT09PT09XHJcblxyXG4gICAgICBsb2dpbjogYXN5bmMgKHVzZXJuYW1lOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBzZXQoeyBpc0xvYWRpbmc6IHRydWUsIGVycm9yOiBudWxsIH0pO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5sb2dpbih1c2VybmFtZSwgcGFzc3dvcmQpO1xyXG4gICAgICAgICAgbGV0IHVzZXIgPSBhd2FpdCBhcGkuZ2V0Q3VycmVudFVzZXIoKTtcclxuXHJcbiAgICAgICAgICAvLyBTdG9yZSB0b2tlblxyXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NpcGhlcmxpbmtfdG9rZW4nLCByZXNwb25zZS5hY2Nlc3NfdG9rZW4pO1xyXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NpcGhlcmxpbmtfdXNlcm5hbWUnLCB1c2VybmFtZSk7XHJcblxyXG4gICAgICAgICAgLy8gTG9hZCBvciBnZW5lcmF0ZSBrZXlzXHJcbiAgICAgICAgICBsZXQga2V5cyA9IEtleVN0b3JhZ2UubG9hZCh1c2VybmFtZSk7XHJcbiAgICAgICAgICBsZXQgbmVlZHNVcGxvYWQgPSAhdXNlci5wdWJsaWNfa2V5O1xyXG4gICAgICAgICAgbGV0IGtleU1pc21hdGNoID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgLy8gVmVyaWZ5IGtleSBjb25zaXN0ZW5jeSBpZiBib3RoIGxvY2FsIGFuZCBzZXJ2ZXIga2V5cyBleGlzdFxyXG4gICAgICAgICAgaWYgKGtleXMgJiYgdXNlci5wdWJsaWNfa2V5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzQ29uc2lzdGVudCA9IEtleVN0b3JhZ2UudmVyaWZ5S2V5Q29uc2lzdGVuY3kodXNlcm5hbWUsIHVzZXIucHVibGljX2tleSk7XHJcbiAgICAgICAgICAgIGlmICghaXNDb25zaXN0ZW50KSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gS2V5IG1pc21hdGNoIGRldGVjdGVkISBMb2NhbCBrZXkgZGlmZmVycyBmcm9tIHNlcnZlciBrZXkuJyk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGlzIG1heSBoYXBwZW4gaWYgeW91IGxvZ2dlZCBpbiBmcm9tIGEgZGlmZmVyZW50IGRldmljZS4nKTtcclxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ09sZCBtZXNzYWdlcyBlbmNyeXB0ZWQgd2l0aCB0aGUgc2VydmVyIGtleSBtYXkgbm90IGRlY3J5cHQgY29ycmVjdGx5LicpO1xyXG4gICAgICAgICAgICAgIGtleU1pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAvLyBLZWVwIGxvY2FsIGtleXMgYnV0IG1hcmsgdGhlIG1pc21hdGNoXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoIWtleXMpIHtcclxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgbmV3IHByb3BlciBrZXkgYnVuZGxlXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SQIEdlbmVyYXRpbmcgbmV3IGtleSBidW5kbGUuLi4nKTtcclxuICAgICAgICAgICAgY29uc3QgeyBidW5kbGUsIHByaXZhdGVLZXlzIH0gPSBnZW5lcmF0ZUtleUJ1bmRsZSg1KTtcclxuXHJcbiAgICAgICAgICAgIGtleXMgPSB7XHJcbiAgICAgICAgICAgICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleXMuc2lnbmVkUHJla2V5UHJpdmF0ZSwgLy8gVXNlIHNpZ25lZCBwcmVrZXkgcHJpdmF0ZSBmb3IgZW5jcnlwdGlvblxyXG4gICAgICAgICAgICAgIHB1YmxpY0tleTogYnVuZGxlLnB1YmxpY0tleSxcclxuICAgICAgICAgICAgICBpZGVudGl0eUtleTogYnVuZGxlLmlkZW50aXR5S2V5LFxyXG4gICAgICAgICAgICAgIHNpZ25lZFByZWtleTogYnVuZGxlLnNpZ25lZFByZWtleSxcclxuICAgICAgICAgICAgICBzaWduZWRQcmVrZXlTaWduYXR1cmU6IGJ1bmRsZS5zaWduZWRQcmVrZXlTaWduYXR1cmUsXHJcbiAgICAgICAgICAgICAgaWRlbnRpdHlQcml2YXRlS2V5OiBwcml2YXRlS2V5cy5pZGVudGl0eVByaXZhdGUsXHJcbiAgICAgICAgICAgICAgb25lVGltZVByZWtleXM6IGJ1bmRsZS5vbmVUaW1lUHJla2V5cyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgS2V5U3RvcmFnZS5zYXZlKHVzZXJuYW1lLCBrZXlzKTtcclxuICAgICAgICAgICAgbmVlZHNVcGxvYWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIEtleSBidW5kbGUgZ2VuZXJhdGVkJyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ1JJVElDQUw6IFZlcmlmeSB0aGF0IHByaXZhdGVLZXkgYW5kIHB1YmxpY0tleSBmb3JtIGEgdmFsaWQgcGFpclxyXG4gICAgICAgICAgaWYgKGtleXMucHJpdmF0ZUtleSAmJiBrZXlzLnB1YmxpY0tleSkge1xyXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkUGFpciA9IHZlcmlmeUtleVBhaXIoa2V5cy5wcml2YXRlS2V5LCBrZXlzLnB1YmxpY0tleSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SRIEtleSBwYWlyIHZlcmlmaWNhdGlvbjonLCBpc1ZhbGlkUGFpciA/ICfinIUgVkFMSUQnIDogJ+KdjCBJTlZBTElEJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRQYWlyKSB7XHJcbiAgICAgICAgICAgICAgLy8gVGhlIHN0b3JlZCBwdWJsaWMga2V5IGRvZXNuJ3QgbWF0Y2ggdGhlIHByaXZhdGUga2V5IVxyXG4gICAgICAgICAgICAgIC8vIERlcml2ZSB0aGUgY29ycmVjdCBwdWJsaWMga2V5IGZyb20gdGhlIHByaXZhdGUga2V5XHJcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gS2V5IHBhaXIgbWlzbWF0Y2ggZGV0ZWN0ZWQhIERlcml2aW5nIGNvcnJlY3QgcHVibGljIGtleS4uLicpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGNvcnJlY3RQdWJsaWNLZXkgPSBkZXJpdmVQdWJsaWNLZXlGcm9tUHJpdmF0ZShrZXlzLnByaXZhdGVLZXkpO1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SnIE9yaWdpbmFsIHB1YmxpY0tleTonLCBrZXlzLnB1YmxpY0tleT8uc3Vic3RyaW5nKDAsIDMwKSk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflKcgRGVyaXZlZCBwdWJsaWNLZXk6JywgY29ycmVjdFB1YmxpY0tleT8uc3Vic3RyaW5nKDAsIDMwKSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUga2V5cyB3aXRoIHRoZSBjb3JyZWN0IHB1YmxpYyBrZXlcclxuICAgICAgICAgICAgICBrZXlzLnB1YmxpY0tleSA9IGNvcnJlY3RQdWJsaWNLZXk7XHJcbiAgICAgICAgICAgICAgS2V5U3RvcmFnZS5zYXZlKHVzZXJuYW1lLCBrZXlzKTtcclxuICAgICAgICAgICAgICBuZWVkc1VwbG9hZCA9IHRydWU7IC8vIE5lZWQgdG8gdXBsb2FkIHRoZSBjb3JyZWN0ZWQga2V5XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBLZXkgcGFpciBjb3JyZWN0ZWQgYW5kIHNhdmVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBVcGxvYWQga2V5cyBpZiBub3Qgb24gc2VydmVyIE9SIGlmIHdlIGNvcnJlY3RlZCB0aGUga2V5IHBhaXJcclxuICAgICAgICAgIGlmIChuZWVkc1VwbG9hZCAmJiBrZXlzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OkIFVwbG9hZGluZyBrZXlzIHRvIHNlcnZlci4uLicsIHtcclxuICAgICAgICAgICAgICBwdWJsaWNLZXlUb1VwbG9hZDoga2V5cy5wdWJsaWNLZXk/LnN1YnN0cmluZygwLCAzMCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGF3YWl0IGFwaS51cGxvYWRLZXlzKHtcclxuICAgICAgICAgICAgICAgIHB1YmxpY19rZXk6IGtleXMucHVibGljS2V5IHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgaWRlbnRpdHlfa2V5OiBrZXlzLmlkZW50aXR5S2V5IHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgc2lnbmVkX3ByZWtleToga2V5cy5zaWduZWRQcmVrZXkgfHwga2V5cy5wdWJsaWNLZXkgfHwgJycsXHJcbiAgICAgICAgICAgICAgICBzaWduZWRfcHJla2V5X3NpZ25hdHVyZToga2V5cy5zaWduZWRQcmVrZXlTaWduYXR1cmUgfHwgJycsXHJcbiAgICAgICAgICAgICAgICBvbmVfdGltZV9wcmVrZXlzOiBrZXlzLm9uZVRpbWVQcmVrZXlzIHx8IFtdLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIC8vIFJlZnJlc2ggdXNlciB0byBnZXQgdXBkYXRlZCBwdWJsaWNfa2V5XHJcbiAgICAgICAgICAgICAgdXNlciA9IGF3YWl0IGFwaS5nZXRDdXJyZW50VXNlcigpO1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgS2V5cyB1cGxvYWRlZCBzdWNjZXNzZnVsbHkhJywge1xyXG4gICAgICAgICAgICAgICAgc2VydmVyTm93SGFzOiB1c2VyLnB1YmxpY19rZXk/LnN1YnN0cmluZygwLCAzMCksXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKHVwbG9hZEVycm9yOiBhbnkpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIHVwbG9hZCBrZXlzOicsIHVwbG9hZEVycm9yPy5yZXNwb25zZT8uZGF0YSB8fCB1cGxvYWRFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGaW5hbCB2ZXJpZmljYXRpb246IGVuc3VyZSBsb2NhbCBrZXkgbWF0Y2hlcyBzZXJ2ZXIga2V5XHJcbiAgICAgICAgICBjb25zdCBsb2NhbFNlcnZlck1hdGNoID0ga2V5cz8ucHVibGljS2V5ID09PSB1c2VyLnB1YmxpY19rZXk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UkCBGaW5hbCBLZXkgU3RhdHVzOicsIHtcclxuICAgICAgICAgICAgdXNlcm5hbWUsXHJcbiAgICAgICAgICAgIGxvY2FsUHViS2V5OiBrZXlzPy5wdWJsaWNLZXk/LnN1YnN0cmluZygwLCAzMCksXHJcbiAgICAgICAgICAgIHNlcnZlclB1YktleTogdXNlci5wdWJsaWNfa2V5Py5zdWJzdHJpbmcoMCwgMzApLFxyXG4gICAgICAgICAgICBsb2NhbFByaXZLZXk6IGtleXM/LnByaXZhdGVLZXk/LnN1YnN0cmluZygwLCAzMCksXHJcbiAgICAgICAgICAgIExPQ0FMX01BVENIRVNfU0VSVkVSOiBsb2NhbFNlcnZlck1hdGNoID8gJ+KchSBZRVMnIDogJ+KdjCBOTycsXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBpZiAoIWxvY2FsU2VydmVyTWF0Y2ggJiYga2V5cz8ucHVibGljS2V5ICYmIHVzZXIucHVibGljX2tleSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCfwn5qoIENSSVRJQ0FMOiBMb2NhbCBwdWJsaWMga2V5IGRvZXMgbm90IG1hdGNoIHNlcnZlciEgVGhpcyB3aWxsIGNhdXNlIGRlY3J5cHRpb24gZmFpbHVyZXMuJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SnIEF0dGVtcHRpbmcgdG8gZm9yY2UgdXBsb2FkIGNvcnJlY3Qga2V5Li4uJyk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgYXdhaXQgYXBpLnVwbG9hZEtleXMoe1xyXG4gICAgICAgICAgICAgICAgcHVibGljX2tleToga2V5cy5wdWJsaWNLZXkgfHwgJycsXHJcbiAgICAgICAgICAgICAgICBpZGVudGl0eV9rZXk6IGtleXMuaWRlbnRpdHlLZXkgfHwgJycsXHJcbiAgICAgICAgICAgICAgICBzaWduZWRfcHJla2V5OiBrZXlzLnNpZ25lZFByZWtleSB8fCBrZXlzLnB1YmxpY0tleSB8fCAnJyxcclxuICAgICAgICAgICAgICAgIHNpZ25lZF9wcmVrZXlfc2lnbmF0dXJlOiBrZXlzLnNpZ25lZFByZWtleVNpZ25hdHVyZSB8fCAnJyxcclxuICAgICAgICAgICAgICAgIG9uZV90aW1lX3ByZWtleXM6IGtleXMub25lVGltZVByZWtleXMgfHwgW10sXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgdXNlciA9IGF3YWl0IGFwaS5nZXRDdXJyZW50VXNlcigpO1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgRm9yY2UgdXBsb2FkIGNvbXBsZXRlLCBzZXJ2ZXIgbm93IGhhczonLCB1c2VyLnB1YmxpY19rZXk/LnN1YnN0cmluZygwLCAzMCkpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZvcmNlIHVwbG9hZCBmYWlsZWQ6JywgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzZXQoe1xyXG4gICAgICAgICAgICB1c2VyLFxyXG4gICAgICAgICAgICB0b2tlbjogcmVzcG9uc2UuYWNjZXNzX3Rva2VuLFxyXG4gICAgICAgICAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IGtleXMucHJpdmF0ZUtleSB8fCBudWxsLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IGtleXMucHVibGljS2V5IHx8IG51bGwsXHJcbiAgICAgICAgICAgIGlkZW50aXR5S2V5OiBrZXlzLmlkZW50aXR5S2V5IHx8IG51bGwsXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAvLyBDb25uZWN0IFdlYlNvY2tldFxyXG4gICAgICAgICAgd3NNYW5hZ2VyLmNvbm5lY3QodXNlci5pZC50b1N0cmluZygpLCByZXNwb25zZS5hY2Nlc3NfdG9rZW4pO1xyXG5cclxuICAgICAgICAgIC8vIFNldHVwIG1lc3NhZ2UgaGFuZGxlcnNcclxuICAgICAgICAgIGlmICghKHdpbmRvdyBhcyBhbnkpLl93c0hhbmRsZXJzUmVnaXN0ZXJlZCkge1xyXG4gICAgICAgICAgICBzZXR1cFdlYlNvY2tldEhhbmRsZXJzKGdldCwgc2V0KTtcclxuICAgICAgICAgICAgKHdpbmRvdyBhcyBhbnkpLl93c0hhbmRsZXJzUmVnaXN0ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgICAgIHNldCh7XHJcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgIGVycm9yOiBlcnJvci5yZXNwb25zZT8uZGF0YT8uZGV0YWlsIHx8ICdMb2dpbiBmYWlsZWQnLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICByZWdpc3RlcjogYXN5bmMgKHVzZXJuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBzZXQoeyBpc0xvYWRpbmc6IHRydWUsIGVycm9yOiBudWxsIH0pO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBkZXZpY2VJZCA9IGB3ZWItJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpfWA7XHJcbiAgICAgICAgICBhd2FpdCBhcGkucmVnaXN0ZXIodXNlcm5hbWUsIGVtYWlsLCBwYXNzd29yZCwgZGV2aWNlSWQpO1xyXG5cclxuICAgICAgICAgIC8vIEF1dG8tbG9naW4gYWZ0ZXIgcmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICBhd2FpdCBnZXQoKS5sb2dpbih1c2VybmFtZSwgcGFzc3dvcmQpO1xyXG5cclxuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgICBzZXQoe1xyXG4gICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxyXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IucmVzcG9uc2U/LmRhdGE/LmRldGFpbCB8fCAnUmVnaXN0cmF0aW9uIGZhaWxlZCcsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIGxvZ291dDogKCkgPT4ge1xyXG4gICAgICAgIHdzTWFuYWdlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgKHdpbmRvdyBhcyBhbnkpLl93c0hhbmRsZXJzUmVnaXN0ZXJlZCA9IGZhbHNlO1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdjaXBoZXJsaW5rX3Rva2VuJyk7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2NpcGhlcmxpbmtfdXNlcm5hbWUnKTtcclxuICAgICAgICBhcGkuc2V0VG9rZW4obnVsbCk7XHJcblxyXG4gICAgICAgIHNldCh7XHJcbiAgICAgICAgICB1c2VyOiBudWxsLFxyXG4gICAgICAgICAgdG9rZW46IG51bGwsXHJcbiAgICAgICAgICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgcHJpdmF0ZUtleTogbnVsbCxcclxuICAgICAgICAgIHB1YmxpY0tleTogbnVsbCxcclxuICAgICAgICAgIGlkZW50aXR5S2V5OiBudWxsLFxyXG4gICAgICAgICAgaWRlbnRpdHlQcml2YXRlS2V5OiBudWxsLFxyXG4gICAgICAgICAgY29udGFjdHM6IFtdLFxyXG4gICAgICAgICAgY29udmVyc2F0aW9uczogW10sXHJcbiAgICAgICAgICBjdXJyZW50Q29udmVyc2F0aW9uOiBudWxsLFxyXG4gICAgICAgICAgbWVzc2FnZXM6IG5ldyBNYXAoKSxcclxuICAgICAgICAgIG9ubGluZVVzZXJzOiBuZXcgU2V0KCksXHJcbiAgICAgICAgICB0eXBpbmdVc2VyczogbmV3IE1hcCgpLFxyXG4gICAgICAgICAgY2FsbEhpc3Rvcnk6IFtdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgaW5pdGlhbGl6ZVdlYlNvY2tldDogKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlciwgdG9rZW4gfSA9IGdldCgpO1xyXG4gICAgICAgIGlmICh1c2VyICYmIHRva2VuKSB7XHJcbiAgICAgICAgICB3c01hbmFnZXIuY29ubmVjdCh1c2VyLmlkLnRvU3RyaW5nKCksIHRva2VuKTtcclxuICAgICAgICAgIGlmICghKHdpbmRvdyBhcyBhbnkpLl93c0hhbmRsZXJzUmVnaXN0ZXJlZCkge1xyXG4gICAgICAgICAgICBzZXR1cFdlYlNvY2tldEhhbmRsZXJzKGdldCwgc2V0KTtcclxuICAgICAgICAgICAgKHdpbmRvdyBhcyBhbnkpLl93c0hhbmRsZXJzUmVnaXN0ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgbG9hZFN0b3JlZEF1dGg6IGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjaXBoZXJsaW5rX3Rva2VuJyk7XHJcbiAgICAgICAgY29uc3QgdXNlcm5hbWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY2lwaGVybGlua191c2VybmFtZScpO1xyXG5cclxuICAgICAgICBpZiAodG9rZW4gJiYgdXNlcm5hbWUpIHtcclxuICAgICAgICAgIGFwaS5zZXRUb2tlbih0b2tlbik7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgYXBpLmdldEN1cnJlbnRVc2VyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBLZXlTdG9yYWdlLmxvYWQodXNlcm5hbWUpO1xyXG5cclxuICAgICAgICAgICAgc2V0KHtcclxuICAgICAgICAgICAgICB1c2VyLFxyXG4gICAgICAgICAgICAgIHRva2VuLFxyXG4gICAgICAgICAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICBwcml2YXRlS2V5OiBrZXlzPy5wcml2YXRlS2V5IHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgcHVibGljS2V5OiBrZXlzPy5wdWJsaWNLZXkgfHwgbnVsbCxcclxuICAgICAgICAgICAgICBpZGVudGl0eUtleToga2V5cz8uaWRlbnRpdHlLZXkgfHwgbnVsbCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb25uZWN0IFdlYlNvY2tldFxyXG4gICAgICAgICAgICB3c01hbmFnZXIuY29ubmVjdCh1c2VyLmlkLnRvU3RyaW5nKCksIHRva2VuKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldHVwIG1lc3NhZ2UgaGFuZGxlcnNcclxuICAgICAgICAgICAgaWYgKCEod2luZG93IGFzIGFueSkuX3dzSGFuZGxlcnNSZWdpc3RlcmVkKSB7XHJcbiAgICAgICAgICAgICAgc2V0dXBXZWJTb2NrZXRIYW5kbGVycyhnZXQsIHNldCk7XHJcbiAgICAgICAgICAgICAgKHdpbmRvdyBhcyBhbnkpLl93c0hhbmRsZXJzUmVnaXN0ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExvYWQgcGVyc2lzdGVudCBkYXRhIGZyb20gSW5kZXhlZERCXHJcbiAgICAgICAgICAgIGF3YWl0IGdldCgpLmxvYWRQZXJzaXN0ZWREYXRhKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTeW5jIHdpdGggc2VydmVyIGluIGJhY2tncm91bmRcclxuICAgICAgICAgICAgZ2V0KCkuc3luY1dpdGhTZXJ2ZXIoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgICAvLyBUb2tlbiBleHBpcmVkIG9yIGludmFsaWRcclxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2NpcGhlcmxpbmtfdG9rZW4nKTtcclxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2NpcGhlcmxpbmtfdXNlcm5hbWUnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyA9PT09PT09PT09PT0gQ3J5cHRvIEFjdGlvbnMgPT09PT09PT09PT09XHJcblxyXG4gICAgICBnZW5lcmF0ZUFuZFVwbG9hZEtleXM6IGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZXIgfSA9IGdldCgpO1xyXG4gICAgICAgIGlmICghdXNlcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBrZXlQYWlyID0gZ2VuZXJhdGVLZXlQYWlyKCk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmluZ1BhaXIgPSBnZW5lcmF0ZVNpZ25pbmdLZXlQYWlyKCk7XHJcblxyXG4gICAgICAgIC8vIFNhdmUgbG9jYWxseVxyXG4gICAgICAgIEtleVN0b3JhZ2Uuc2F2ZSh1c2VyLnVzZXJuYW1lLCB7XHJcbiAgICAgICAgICBwcml2YXRlS2V5OiBrZXlQYWlyLnByaXZhdGVLZXksXHJcbiAgICAgICAgICBwdWJsaWNLZXk6IGtleVBhaXIucHVibGljS2V5LFxyXG4gICAgICAgICAgaWRlbnRpdHlLZXk6IHNpZ25pbmdQYWlyLnB1YmxpY0tleSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gVXBsb2FkIHRvIHNlcnZlclxyXG4gICAgICAgIGF3YWl0IGFwaS51cGxvYWRLZXlzKHtcclxuICAgICAgICAgIHB1YmxpY19rZXk6IGtleVBhaXIucHVibGljS2V5LFxyXG4gICAgICAgICAgaWRlbnRpdHlfa2V5OiBzaWduaW5nUGFpci5wdWJsaWNLZXksXHJcbiAgICAgICAgICBzaWduZWRfcHJla2V5OiBrZXlQYWlyLnB1YmxpY0tleSxcclxuICAgICAgICAgIHNpZ25lZF9wcmVrZXlfc2lnbmF0dXJlOiBzaWduaW5nUGFpci5wdWJsaWNLZXksXHJcbiAgICAgICAgICBvbmVfdGltZV9wcmVrZXlzOiBbXSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2V0KHtcclxuICAgICAgICAgIHByaXZhdGVLZXk6IGtleVBhaXIucHJpdmF0ZUtleSxcclxuICAgICAgICAgIHB1YmxpY0tleToga2V5UGFpci5wdWJsaWNLZXksXHJcbiAgICAgICAgICBpZGVudGl0eUtleTogc2lnbmluZ1BhaXIucHVibGljS2V5LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgbG9hZFN0b3JlZEtleXM6ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZXIgfSA9IGdldCgpO1xyXG4gICAgICAgIGlmICghdXNlcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBrZXlzID0gS2V5U3RvcmFnZS5sb2FkKHVzZXIudXNlcm5hbWUpO1xyXG4gICAgICAgIGlmIChrZXlzKSB7XHJcbiAgICAgICAgICBzZXQoe1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBrZXlzLnByaXZhdGVLZXksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleToga2V5cy5wdWJsaWNLZXksXHJcbiAgICAgICAgICAgIGlkZW50aXR5S2V5OiBrZXlzLmlkZW50aXR5S2V5LFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gPT09PT09PT09PT09IENoYXQgQWN0aW9ucyA9PT09PT09PT09PT1cclxuXHJcbiAgICAgIGxvYWRDb250YWN0czogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBjb250YWN0cyA9IGF3YWl0IGFwaS5nZXRDb250YWN0cygpO1xyXG4gICAgICAgICAgc2V0KHsgY29udGFjdHMgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNvbnRhY3RzOicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBsb2FkQ29udmVyc2F0aW9uczogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBjb252ZXJzYXRpb25zID0gYXdhaXQgYXBpLmdldENvbnZlcnNhdGlvbnMoKTtcclxuICAgICAgICAgIHNldCh7IGNvbnZlcnNhdGlvbnMgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNvbnZlcnNhdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIGxvYWRNZXNzYWdlczogYXN5bmMgKHVzZXJuYW1lOiBzdHJpbmcpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBhd2FpdCBhcGkuZ2V0Q29udmVyc2F0aW9uKHVzZXJuYW1lKTtcclxuXHJcbiAgICAgICAgICAvLyBUcnkgdG8gZGVjcnlwdCBtZXNzYWdlc1xyXG4gICAgICAgICAgY29uc3QgeyBwcml2YXRlS2V5LCBjb250YWN0cywgdXNlciB9ID0gZ2V0KCk7XHJcblxyXG4gICAgICAgICAgaWYgKHByaXZhdGVLZXkpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBtc2cgb2YgbWVzc2FnZXMpIHtcclxuICAgICAgICAgICAgICBpZiAobXNnLmVuY3J5cHRlZF9jb250ZW50ICYmICFtc2cuX2RlY3J5cHRlZENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSBKU09OLnBhcnNlKG1zZy5lbmNyeXB0ZWRfY29udGVudCkgYXMgRW5jcnlwdGVkTWVzc2FnZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIHYyIHByb3RvY29sOiBzZW5kZXJQdWJsaWNLZXkgaXMgZW1iZWRkZWQgaW4gbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAvLyB2MSBwcm90b2NvbDogdXNlIGNvbnRhY3QncyBjYWNoZWQgcHVibGljIGtleSBhcyBmYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICBsZXQgZmFsbGJhY2tQdWJsaWNLZXk6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmIChtc2cuc2VuZGVyX3VzZXJuYW1lID09PSB1c2VyPy51c2VybmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlbnQgYnkgbWUgLT4gZmFsbGJhY2sgaXMgcmVjaXBpZW50J3MgcHVibGljIGtleVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrUHVibGljS2V5ID0gY29udGFjdHMuZmluZChcclxuICAgICAgICAgICAgICAgICAgICAgIGMgPT4gYy5jb250YWN0X3VzZXJuYW1lID09PSBtc2cucmVjaXBpZW50X3VzZXJuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgKT8ucHVibGljX2tleTtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZWNlaXZlZCBieSBtZSAtPiBmYWxsYmFjayBpcyBzZW5kZXIncyBwdWJsaWMga2V5XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGFjdCA9IGNvbnRhY3RzLmZpbmQoXHJcbiAgICAgICAgICAgICAgICAgICAgICBjID0+IGMuY29udGFjdF91c2VybmFtZSA9PT0gbXNnLnNlbmRlcl91c2VybmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tQdWJsaWNLZXkgPSBjb250YWN0Py5wdWJsaWNfa2V5O1xyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBkZWNyeXB0TWVzc2FnZSBub3cgaGFuZGxlcyB2MiAoZW1iZWRkZWQga2V5KSBhbmQgdjEgKGZhbGxiYWNrIGtleSlcclxuICAgICAgICAgICAgICAgICAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdE1lc3NhZ2UoZW5jcnlwdGVkRGF0YSwgZmFsbGJhY2tQdWJsaWNLZXkgfHwgJycsIHByaXZhdGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgICBtc2cuX2RlY3J5cHRlZENvbnRlbnQgPSBkZWNyeXB0ZWQ7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGRlY3J5cHQgbWVzc2FnZTonLCBtc2cuaWQsIGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnN0IG5ld01lc3NhZ2VzID0gbmV3IE1hcChnZXQoKS5tZXNzYWdlcyk7XHJcbiAgICAgICAgICBuZXdNZXNzYWdlcy5zZXQodXNlcm5hbWUsIG1lc3NhZ2VzKTtcclxuICAgICAgICAgIHNldCh7IG1lc3NhZ2VzOiBuZXdNZXNzYWdlcyB9KTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgbWVzc2FnZXM6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIHNlbmRNZXNzYWdlOiBhc3luYyAocmVjaXBpZW50VXNlcm5hbWU6IHN0cmluZywgY29udGVudDogc3RyaW5nLCBtZXNzYWdlVHlwZTogc3RyaW5nID0gJ3RleHQnLCBmaWxlRGF0YT86IGFueSkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OkIHNlbmRNZXNzYWdlIGNhbGxlZDonLCB7IHJlY2lwaWVudFVzZXJuYW1lLCBjb250ZW50OiBjb250ZW50LnN1YnN0cmluZygwLCA1MCksIG1lc3NhZ2VUeXBlIH0pO1xyXG5cclxuICAgICAgICBsZXQgeyBwcml2YXRlS2V5LCBwdWJsaWNLZXksIHVzZXIgfSA9IGdldCgpO1xyXG4gICAgICAgIGlmICghcHJpdmF0ZUtleSB8fCAhcHVibGljS2V5IHx8ICF1c2VyKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3Qgc2VuZCBtZXNzYWdlOiBtaXNzaW5nIGtleXMgb3IgdXNlcicsIHsgaGFzUHJpdmF0ZUtleTogISFwcml2YXRlS2V5LCBoYXNQdWJsaWNLZXk6ICEhcHVibGljS2V5LCBoYXNVc2VyOiAhIXVzZXIgfSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDUklUSUNBTDogVmVyaWZ5IG91ciBrZXkgcGFpciBpcyB2YWxpZCBiZWZvcmUgc2VuZGluZ1xyXG4gICAgICAgIGNvbnN0IGlzVmFsaWRQYWlyID0gdmVyaWZ5S2V5UGFpcihwcml2YXRlS2V5LCBwdWJsaWNLZXkpO1xyXG4gICAgICAgIGlmICghaXNWYWxpZFBhaXIpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIEludmFsaWQga2V5IHBhaXIgZGV0ZWN0ZWQgaW4gc2VuZE1lc3NhZ2UhIERlcml2aW5nIGNvcnJlY3QgcHVibGljIGtleS4uLicpO1xyXG4gICAgICAgICAgcHVibGljS2V5ID0gZGVyaXZlUHVibGljS2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleSk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UpyBVc2luZyBkZXJpdmVkIHB1YmxpY0tleTonLCBwdWJsaWNLZXk/LnN1YnN0cmluZygwLCAzMCkpO1xyXG4gICAgICAgICAgLy8gVXBkYXRlIHN0b3JlIHdpdGggY29ycmVjdGVkIGtleVxyXG4gICAgICAgICAgc2V0KHsgcHVibGljS2V5IH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWx3YXlzIGZldGNoIHRoZSBsYXRlc3QgcmVjaXBpZW50IHB1YmxpYyBrZXkgZnJvbSB0aGUgc2VydmVyXHJcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk6QgRmV0Y2hpbmcgcHVibGljIGtleSBmcm9tIHNlcnZlciBmb3I6JywgcmVjaXBpZW50VXNlcm5hbWUpO1xyXG4gICAgICAgIGxldCByZWNpcGllbnRQdWJsaWNLZXk6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3Qga2V5RGF0YSA9IGF3YWl0IGFwaS5nZXRQdWJsaWNLZXkocmVjaXBpZW50VXNlcm5hbWUpO1xyXG4gICAgICAgICAgcmVjaXBpZW50UHVibGljS2V5ID0ga2V5RGF0YS5wdWJsaWNfa2V5O1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfk6QgR290IHJlY2lwaWVudCBwdWJsaWMga2V5IGZyb20gc2VydmVyOicsIHJlY2lwaWVudFB1YmxpY0tleT8uc3Vic3RyaW5nKDAsIDMwKSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgcmVjaXBpZW50IHB1YmxpYyBrZXk6JywgZXJyb3IpO1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IHJlY2lwaWVudCBlbmNyeXB0aW9uIGtleScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFyZWNpcGllbnRQdWJsaWNLZXkpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVjaXBpZW50IGhhcyBub3Qgc2V0IHVwIGVuY3J5cHRpb24nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVuY3J5cHQgbWVzc2FnZSB1c2luZyBzdGF0aWMga2V5IHBhaXIgKFgyNTUxOSlcclxuICAgICAgICAvLyB2MiBwcm90b2NvbDogaW5jbHVkZXMgc2VuZGVyJ3MgcHVibGljIGtleSBpbiB0aGUgcGF5bG9hZCBmb3IgcmVsaWFibGUgZGVjcnlwdGlvblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OkIEVuY3J5cHRpbmcgd2l0aDonLCB7XHJcbiAgICAgICAgICByZWNpcGllbnRQdWJLZXk6IHJlY2lwaWVudFB1YmxpY0tleT8uc3Vic3RyaW5nKDAsIDMwKSxcclxuICAgICAgICAgIHNlbmRlclByaXZLZXk6IHByaXZhdGVLZXk/LnN1YnN0cmluZygwLCAzMCksXHJcbiAgICAgICAgICBzZW5kZXJQdWJLZXk6IHB1YmxpY0tleT8uc3Vic3RyaW5nKDAsIDMwKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0TWVzc2FnZShjb250ZW50LCByZWNpcGllbnRQdWJsaWNLZXksIHByaXZhdGVLZXksIHB1YmxpY0tleSk7XHJcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkQ29udGVudCA9IEpTT04uc3RyaW5naWZ5KGVuY3J5cHRlZCk7XHJcblxyXG4gICAgICAgIC8vIEJ1aWxkIHNlbmRlcidzIHRoZW1lIGZvciB0aGVtZSBzeW5jXHJcbiAgICAgICAgY29uc3Qgc2VuZGVyVGhlbWUgPSBidWlsZE1lc3NhZ2VUaGVtZSgpO1xyXG5cclxuICAgICAgICAvLyBBZGQgdG8gbG9jYWwgbWVzc2FnZXMgb3B0aW1pc3RpY2FsbHlcclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzc2FnZXMgPSBnZXQoKS5tZXNzYWdlcy5nZXQocmVjaXBpZW50VXNlcm5hbWUpIHx8IFtdO1xyXG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNJZCA9IC1EYXRlLm5vdygpO1xyXG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNNZXNzYWdlOiBNZXNzYWdlID0ge1xyXG4gICAgICAgICAgaWQ6IG9wdGltaXN0aWNJZCxcclxuICAgICAgICAgIHNlbmRlcl9pZDogdXNlci5pZCxcclxuICAgICAgICAgIHNlbmRlcl91c2VybmFtZTogdXNlci51c2VybmFtZSxcclxuICAgICAgICAgIHJlY2lwaWVudF9pZDogMCwgLy8gVW5rbm93biBJRCBmb3Igbm93XHJcbiAgICAgICAgICByZWNpcGllbnRfdXNlcm5hbWU6IHJlY2lwaWVudFVzZXJuYW1lLFxyXG4gICAgICAgICAgZW5jcnlwdGVkX2NvbnRlbnQ6IGVuY3J5cHRlZENvbnRlbnQsXHJcbiAgICAgICAgICBtZXNzYWdlX3R5cGU6IG1lc3NhZ2VUeXBlLFxyXG4gICAgICAgICAgc3RhdHVzOiAnc2VuZGluZycsXHJcbiAgICAgICAgICBleHBpcnlfdHlwZTogJ25vbmUnLFxyXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgX2RlY3J5cHRlZENvbnRlbnQ6IGNvbnRlbnQsIC8vIFdlIGtub3cgd2hhdCB3ZSBzZW50XHJcbiAgICAgICAgICBzZW5kZXJfdGhlbWU6IHNlbmRlclRoZW1lLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IG5ld01lc3NhZ2VzID0gbmV3IE1hcChnZXQoKS5tZXNzYWdlcyk7XHJcbiAgICAgICAgbmV3TWVzc2FnZXMuc2V0KHJlY2lwaWVudFVzZXJuYW1lLCBbLi4uY3VycmVudE1lc3NhZ2VzLCBvcHRpbWlzdGljTWVzc2FnZV0pO1xyXG4gICAgICAgIHNldCh7IG1lc3NhZ2VzOiBuZXdNZXNzYWdlcyB9KTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OkIFNlbmRpbmcgdG8gQVBJLi4uJyk7XHJcbiAgICAgICAgICBjb25zdCBzZW50TWVzc2FnZSA9IGF3YWl0IGFwaS5zZW5kTWVzc2FnZShcclxuICAgICAgICAgICAgcmVjaXBpZW50VXNlcm5hbWUsXHJcbiAgICAgICAgICAgIGVuY3J5cHRlZENvbnRlbnQsXHJcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgLy8gZW5jcnlwdGVkS2V5XHJcbiAgICAgICAgICAgICdub25lJyxcclxuICAgICAgICAgICAgbWVzc2FnZVR5cGUsXHJcbiAgICAgICAgICAgIGZpbGVEYXRhXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgTWVzc2FnZSBzZW50IHN1Y2Nlc3NmdWxseScsIHNlbnRNZXNzYWdlKTtcclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgb3B0aW1pc3RpYyBtZXNzYWdlIHdpdGggcmVhbCBvbmUgd2hpbGUgcHJlc2VydmluZyBkZWNyeXB0ZWQgY29udGVudFxyXG4gICAgICAgICAgc2VudE1lc3NhZ2UuX2RlY3J5cHRlZENvbnRlbnQgPSBjb250ZW50O1xyXG5cclxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRNZXNzYWdlcyA9IG5ldyBNYXAoZ2V0KCkubWVzc2FnZXMpO1xyXG4gICAgICAgICAgY29uc3QgdXNlck1lc3NhZ2VzID0gdXBkYXRlZE1lc3NhZ2VzLmdldChyZWNpcGllbnRVc2VybmFtZSkgfHwgW107XHJcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHVzZXJNZXNzYWdlcy5maW5kSW5kZXgobSA9PiBtLmlkID09PSBvcHRpbWlzdGljSWQpO1xyXG5cclxuICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdXNlck1lc3NhZ2VzW2luZGV4XSA9IHNlbnRNZXNzYWdlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdXNlck1lc3NhZ2VzLnB1c2goc2VudE1lc3NhZ2UpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHVwZGF0ZWRNZXNzYWdlcy5zZXQocmVjaXBpZW50VXNlcm5hbWUsIHVzZXJNZXNzYWdlcyk7XHJcbiAgICAgICAgICBzZXQoeyBtZXNzYWdlczogdXBkYXRlZE1lc3NhZ2VzIH0pO1xyXG5cclxuICAgICAgICAgIC8vIFBlcnNpc3QgbWVzc2FnZSBhbmQgdXBkYXRlL3BlcnNpc3QgY29udmVyc2F0aW9uIHNuYXBzaG90IGZvciBoaXN0b3J5XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBnZXQoKS5wZXJzaXN0TWVzc2FnZShzZW50TWVzc2FnZSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gcGVyc2lzdCBzZW50IG1lc3NhZ2U6JywgZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIGNvbnZlcnNhdGlvbiBwcmV2aWV3ICYgcGVyc2lzdFxyXG4gICAgICAgICAgY29uc3Qgc3RhdGVBZnRlclNlbmQgPSBnZXQoKTtcclxuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ29udkluZGV4ID0gc3RhdGVBZnRlclNlbmQuY29udmVyc2F0aW9ucy5maW5kSW5kZXgoYyA9PiBjLnVzZXJuYW1lID09PSByZWNpcGllbnRVc2VybmFtZSk7XHJcbiAgICAgICAgICBpZiAoZXhpc3RpbmdDb252SW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBjb252ZXJzYXRpb25zID0gWy4uLnN0YXRlQWZ0ZXJTZW5kLmNvbnZlcnNhdGlvbnNdO1xyXG4gICAgICAgICAgICBjb25zdCBjb252ID0gY29udmVyc2F0aW9uc1tleGlzdGluZ0NvbnZJbmRleF07XHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRDb252ID0ge1xyXG4gICAgICAgICAgICAgIC4uLmNvbnYsXHJcbiAgICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3RpbWU6IHNlbnRNZXNzYWdlLmNyZWF0ZWRfYXQsXHJcbiAgICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3ByZXZpZXc6IG1lc3NhZ2VUeXBlID09PSAnaW1hZ2UnID8gJ/Cfk7cgSW1hZ2UnIDogY29udGVudCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29udmVyc2F0aW9uc1tleGlzdGluZ0NvbnZJbmRleF0gPSB1cGRhdGVkQ29udjtcclxuICAgICAgICAgICAgc2V0KHsgY29udmVyc2F0aW9ucyB9KTtcclxuXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgYXdhaXQgZ2V0KCkucGVyc2lzdENvbnZlcnNhdGlvbih1cGRhdGVkQ29udik7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIHBlcnNpc3QgY29udmVyc2F0aW9uIGFmdGVyIHNlbmQ6JywgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzZW5kIG1lc3NhZ2U6JywgZXJyb3IpO1xyXG4gICAgICAgICAgLy8gTWFyayBhcyBmYWlsZWRcclxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRNZXNzYWdlcyA9IG5ldyBNYXAoZ2V0KCkubWVzc2FnZXMpO1xyXG4gICAgICAgICAgY29uc3QgdXNlck1lc3NhZ2VzID0gdXBkYXRlZE1lc3NhZ2VzLmdldChyZWNpcGllbnRVc2VybmFtZSkgfHwgW107XHJcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHVzZXJNZXNzYWdlcy5maW5kSW5kZXgobSA9PiBtLmlkID09PSBvcHRpbWlzdGljSWQpO1xyXG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICB1c2VyTWVzc2FnZXNbaW5kZXhdLnN0YXR1cyA9ICdmYWlsZWQnO1xyXG4gICAgICAgICAgICB1cGRhdGVkTWVzc2FnZXMuc2V0KHJlY2lwaWVudFVzZXJuYW1lLCB1c2VyTWVzc2FnZXMpO1xyXG4gICAgICAgICAgICBzZXQoeyBtZXNzYWdlczogdXBkYXRlZE1lc3NhZ2VzIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgc2V0Q3VycmVudENvbnZlcnNhdGlvbjogKHVzZXJuYW1lOiBzdHJpbmcgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgc2V0KHsgY3VycmVudENvbnZlcnNhdGlvbjogdXNlcm5hbWUgfSk7XHJcbiAgICAgICAgaWYgKHVzZXJuYW1lKSB7XHJcbiAgICAgICAgICBnZXQoKS5sb2FkTWVzc2FnZXModXNlcm5hbWUpO1xyXG5cclxuICAgICAgICAgIC8vIENsZWFyIHR5cGluZyBpbmRpY2F0b3IgZm9yIHRoaXMgdXNlclxyXG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcclxuICAgICAgICAgIGNvbnN0IG5ld1R5cGluZ1VzZXJzID0gbmV3IE1hcChzdGF0ZS50eXBpbmdVc2Vycyk7XHJcbiAgICAgICAgICBuZXdUeXBpbmdVc2Vycy5kZWxldGUodXNlcm5hbWUpO1xyXG4gICAgICAgICAgc2V0KHsgdHlwaW5nVXNlcnM6IG5ld1R5cGluZ1VzZXJzIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIGFkZENvbnRhY3Q6IGFzeW5jICh1c2VybmFtZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IGNvbnRhY3QgPSBhd2FpdCBhcGkuYWRkQ29udGFjdCh1c2VybmFtZSk7XHJcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xyXG4gICAgICAgICAgc2V0KHsgY29udGFjdHM6IFsuLi5zdGF0ZS5jb250YWN0cywgY29udGFjdF0gfSk7XHJcblxyXG4gICAgICAgICAgLy8gQWxzbyBhZGQgdG8gY29udmVyc2F0aW9ucyBpbW1lZGlhdGVseVxyXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdDb252ID0gc3RhdGUuY29udmVyc2F0aW9ucy5maW5kKGMgPT4gYy51c2VybmFtZSA9PT0gdXNlcm5hbWUpO1xyXG4gICAgICAgICAgaWYgKCFleGlzdGluZ0NvbnYpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q29udmVyc2F0aW9uOiBDb252ZXJzYXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgdXNlcl9pZDogY29udGFjdC5jb250YWN0X2lkLFxyXG4gICAgICAgICAgICAgIHVzZXJuYW1lOiBjb250YWN0LmNvbnRhY3RfdXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgcHVibGljX2tleTogY29udGFjdC5wdWJsaWNfa2V5LFxyXG4gICAgICAgICAgICAgIGlkZW50aXR5X2tleTogY29udGFjdC5pZGVudGl0eV9rZXksXHJcbiAgICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3RpbWU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICBsYXN0X21lc3NhZ2VfcHJldmlldzogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIHVucmVhZF9jb3VudDogMCxcclxuICAgICAgICAgICAgICBpc19vbmxpbmU6IGZhbHNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHNldCh7IGNvbnZlcnNhdGlvbnM6IFtuZXdDb252ZXJzYXRpb24sIC4uLnN0YXRlLmNvbnZlcnNhdGlvbnNdIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gYWRkIGNvbnRhY3Q6JywgZXJyb3IpO1xyXG4gICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgc2VhcmNoVXNlcnM6IGFzeW5jIChxdWVyeTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHJldHVybiBhd2FpdCBhcGkuc2VhcmNoVXNlcnMocXVlcnkpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2VhcmNoIHVzZXJzOicsIGVycm9yKTtcclxuICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBhZGRJbmNvbWluZ01lc3NhZ2U6IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcclxuICAgICAgICBjb25zdCBzZW5kZXJVc2VybmFtZSA9IG1lc3NhZ2Uuc2VuZGVyX3VzZXJuYW1lO1xyXG4gICAgICAgIC8vIENoZWNrIGlmIG1lc3NhZ2UgYWxyZWFkeSBleGlzdHNcclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzc2FnZXMgPSBnZXQoKS5tZXNzYWdlcy5nZXQoc2VuZGVyVXNlcm5hbWUpIHx8IFtdO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IGN1cnJlbnRNZXNzYWdlcy5zb21lKG0gPT4gbS5pZCA9PT0gbWVzc2FnZS5pZCk7XHJcblxyXG4gICAgICAgIGlmICghZXhpc3RzKSB7XHJcbiAgICAgICAgICAvLyBEZWNyeXB0IGltbWVkaWF0ZWx5IGlmIHBvc3NpYmxlXHJcbiAgICAgICAgICAvLyB2MiBwcm90b2NvbDogc2VuZGVyUHVibGljS2V5IGlzIGVtYmVkZGVkIGluIHRoZSBtZXNzYWdlIHBheWxvYWRcclxuICAgICAgICAgIGNvbnN0IHsgcHJpdmF0ZUtleSwgY29udGFjdHMgfSA9IGdldCgpO1xyXG4gICAgICAgICAgaWYgKHByaXZhdGVLZXkgJiYgbWVzc2FnZS5lbmNyeXB0ZWRfY29udGVudCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSBKU09OLnBhcnNlKG1lc3NhZ2UuZW5jcnlwdGVkX2NvbnRlbnQpIGFzIEVuY3J5cHRlZE1lc3NhZ2U7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCBmYWxsYmFjayBwdWJsaWMga2V5IGZyb20gY29udGFjdHMgKGZvciB2MSBtZXNzYWdlcylcclxuICAgICAgICAgICAgICBjb25zdCBjb250YWN0ID0gY29udGFjdHMuZmluZChcclxuICAgICAgICAgICAgICAgIGMgPT4gYy5jb250YWN0X3VzZXJuYW1lID09PSBtZXNzYWdlLnNlbmRlcl91c2VybmFtZVxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgY29uc3QgZmFsbGJhY2tQdWJsaWNLZXkgPSBjb250YWN0Py5wdWJsaWNfa2V5IHx8ICcnO1xyXG5cclxuICAgICAgICAgICAgICAvLyBkZWNyeXB0TWVzc2FnZSBoYW5kbGVzIHYyICh1c2VzIGVtYmVkZGVkIHNlbmRlclB1YmxpY0tleSkgYW5kIHYxICh1c2VzIGZhbGxiYWNrKVxyXG4gICAgICAgICAgICAgIG1lc3NhZ2UuX2RlY3J5cHRlZENvbnRlbnQgPSBkZWNyeXB0TWVzc2FnZShcclxuICAgICAgICAgICAgICAgIGVuY3J5cHRlZERhdGEsXHJcbiAgICAgICAgICAgICAgICBmYWxsYmFja1B1YmxpY0tleSxcclxuICAgICAgICAgICAgICAgIHByaXZhdGVLZXlcclxuICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICBpZiAobWVzc2FnZS5fZGVjcnlwdGVkQ29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBTdWNjZXNzZnVsbHkgZGVjcnlwdGVkIGluY29taW5nIG1lc3NhZ2UnKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gRGVjcnlwdGlvbiByZXR1cm5lZCBudWxsIGZvciBtZXNzYWdlOicsIG1lc3NhZ2UuaWQpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBEZWNyeXB0aW9uIGZhaWxlZCBmb3IgaW5jb21pbmc6JywgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb25zdCBuZXdNZXNzYWdlcyA9IG5ldyBNYXAoZ2V0KCkubWVzc2FnZXMpO1xyXG4gICAgICAgICAgbmV3TWVzc2FnZXMuc2V0KHNlbmRlclVzZXJuYW1lLCBbLi4uY3VycmVudE1lc3NhZ2VzLCBtZXNzYWdlXSk7XHJcbiAgICAgICAgICBzZXQoeyBtZXNzYWdlczogbmV3TWVzc2FnZXMgfSk7XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIGNvbnZlcnNhdGlvbiBsaXN0XHJcbiAgICAgICAgICBjb25zdCBjb252SW5kZXggPSBzdGF0ZS5jb252ZXJzYXRpb25zLmZpbmRJbmRleChjID0+IGMudXNlcm5hbWUgPT09IHNlbmRlclVzZXJuYW1lKTtcclxuICAgICAgICAgIGlmIChjb252SW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBjb252ZXJzYXRpb25zID0gWy4uLnN0YXRlLmNvbnZlcnNhdGlvbnNdO1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkQ29udiA9IHtcclxuICAgICAgICAgICAgICAuLi5jb252ZXJzYXRpb25zW2NvbnZJbmRleF0sXHJcbiAgICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3RpbWU6IG1lc3NhZ2UuY3JlYXRlZF9hdCxcclxuICAgICAgICAgICAgICBsYXN0X21lc3NhZ2VfcHJldmlldzogbWVzc2FnZS5fZGVjcnlwdGVkQ29udGVudFxyXG4gICAgICAgICAgICAgICAgPyAobWVzc2FnZS5tZXNzYWdlX3R5cGUgPT09ICdpbWFnZScgPyAn8J+TtyBJbWFnZScgOiBtZXNzYWdlLl9kZWNyeXB0ZWRDb250ZW50KVxyXG4gICAgICAgICAgICAgICAgOiAnW0VuY3J5cHRlZCBNZXNzYWdlXScsXHJcbiAgICAgICAgICAgICAgdW5yZWFkX2NvdW50OiAoY29udmVyc2F0aW9uc1tjb252SW5kZXhdLnVucmVhZF9jb3VudCB8fCAwKSArIDFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29udmVyc2F0aW9uc1tjb252SW5kZXhdID0gdXBkYXRlZENvbnY7XHJcbiAgICAgICAgICAgIHNldCh7IGNvbnZlcnNhdGlvbnMgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBQZXJzaXN0IGxhdGVzdCBjb252ZXJzYXRpb24gc25hcHNob3QgYW5kIG1lc3NhZ2UgZm9yIGhpc3RvcnlcclxuICAgICAgICAgICAgZ2V0KCkucGVyc2lzdE1lc3NhZ2UobWVzc2FnZSkuY2F0Y2goZXJyID0+XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBwZXJzaXN0IGluY29taW5nIG1lc3NhZ2U6JywgZXJyKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBnZXQoKS5wZXJzaXN0Q29udmVyc2F0aW9uKHVwZGF0ZWRDb252KS5jYXRjaChlcnIgPT5cclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIHBlcnNpc3QgY29udmVyc2F0aW9uIGZvciBpbmNvbWluZyBtZXNzYWdlOicsIGVycilcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE1lc3NhZ2UgZnJvbSB1c2VyIHdpdGhvdXQgYW4gZXhpc3RpbmcgY29udmVyc2F0aW9uIGVudHJ5IOKAkyBjcmVhdGUgYSBsaWdodHdlaWdodCBvbmVcclxuICAgICAgICAgICAgY29uc3QgbmV3Q29udmVyc2F0aW9uID0ge1xyXG4gICAgICAgICAgICAgIHVzZXJfaWQ6IG1lc3NhZ2Uuc2VuZGVyX2lkLFxyXG4gICAgICAgICAgICAgIHVzZXJuYW1lOiBzZW5kZXJVc2VybmFtZSxcclxuICAgICAgICAgICAgICBwdWJsaWNfa2V5OiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgaWRlbnRpdHlfa2V5OiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3RpbWU6IG1lc3NhZ2UuY3JlYXRlZF9hdCxcclxuICAgICAgICAgICAgICBsYXN0X21lc3NhZ2VfcHJldmlldzogbWVzc2FnZS5fZGVjcnlwdGVkQ29udGVudFxyXG4gICAgICAgICAgICAgICAgPyAobWVzc2FnZS5tZXNzYWdlX3R5cGUgPT09ICdpbWFnZScgPyAn8J+TtyBJbWFnZScgOiBtZXNzYWdlLl9kZWNyeXB0ZWRDb250ZW50KVxyXG4gICAgICAgICAgICAgICAgOiAnW0VuY3J5cHRlZCBNZXNzYWdlXScsXHJcbiAgICAgICAgICAgICAgdW5yZWFkX2NvdW50OiAxLFxyXG4gICAgICAgICAgICAgIGlzX29ubGluZTogZmFsc2UsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHNldCh7IGNvbnZlcnNhdGlvbnM6IFtuZXdDb252ZXJzYXRpb24sIC4uLnN0YXRlLmNvbnZlcnNhdGlvbnNdIH0pO1xyXG5cclxuICAgICAgICAgICAgZ2V0KCkucGVyc2lzdE1lc3NhZ2UobWVzc2FnZSkuY2F0Y2goZXJyID0+XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBwZXJzaXN0IGluY29taW5nIG1lc3NhZ2U6JywgZXJyKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBnZXQoKS5wZXJzaXN0Q29udmVyc2F0aW9uKG5ld0NvbnZlcnNhdGlvbikuY2F0Y2goZXJyID0+XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBwZXJzaXN0IG5ldyBjb252ZXJzYXRpb24gZm9yIGluY29taW5nIG1lc3NhZ2U6JywgZXJyKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIGxvYWRDYWxsSGlzdG9yeTogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBoaXN0b3J5ID0gYXdhaXQgYXBpLmdldENhbGxIaXN0b3J5KCk7XHJcbiAgICAgICAgICBzZXQoeyBjYWxsSGlzdG9yeTogaGlzdG9yeSB9KTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgY2FsbCBoaXN0b3J5OicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyA9PT09PT09PT09PT0gUHJlc2VuY2UgPT09PT09PT09PT09XHJcblxyXG4gICAgICBzZXRVc2VyT25saW5lOiAodXNlcklkOiBudW1iZXIsIGlzT25saW5lOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcclxuICAgICAgICBjb25zdCBuZXdPbmxpbmVVc2VycyA9IG5ldyBTZXQoc3RhdGUub25saW5lVXNlcnMpO1xyXG4gICAgICAgIGlmIChpc09ubGluZSkge1xyXG4gICAgICAgICAgbmV3T25saW5lVXNlcnMuYWRkKHVzZXJJZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5ld09ubGluZVVzZXJzLmRlbGV0ZSh1c2VySWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQoeyBvbmxpbmVVc2VyczogbmV3T25saW5lVXNlcnMgfSk7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBzZXRVc2VyVHlwaW5nOiAodXNlcm5hbWU6IHN0cmluZywgaXNUeXBpbmc6IGJvb2xlYW4pID0+IHtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xyXG4gICAgICAgIGNvbnN0IG5ld1R5cGluZ1VzZXJzID0gbmV3IE1hcChzdGF0ZS50eXBpbmdVc2Vycyk7XHJcbiAgICAgICAgaWYgKGlzVHlwaW5nKSB7XHJcbiAgICAgICAgICBuZXdUeXBpbmdVc2Vycy5zZXQodXNlcm5hbWUsIHRydWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdUeXBpbmdVc2Vycy5kZWxldGUodXNlcm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQoeyB0eXBpbmdVc2VyczogbmV3VHlwaW5nVXNlcnMgfSk7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBjbGVhckVycm9yOiAoKSA9PiBzZXQoeyBlcnJvcjogbnVsbCB9KSxcclxuXHJcbiAgICAgIC8vID09PT09PT09PT09PSBEZWxldGlvbiBBY3Rpb25zID09PT09PT09PT09PVxyXG5cclxuICAgICAgZGVsZXRlTWVzc2FnZUZvck1lOiBhc3luYyAobWVzc2FnZUlkOiBudW1iZXIsIGNvbnZlcnNhdGlvblVzZXJuYW1lOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAvLyBEZWxldGUgbG9jYWxseSBvbmx5IC0gZG9lcyBub3QgYWZmZWN0IHRoZSBvdGhlciB1c2VyXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGxvY2FsIHN0YXRlXHJcbiAgICAgICAgICBjb25zdCBjdXJyZW50TWVzc2FnZXMgPSBuZXcgTWFwKGdldCgpLm1lc3NhZ2VzKTtcclxuICAgICAgICAgIGNvbnN0IGNvbnZNZXNzYWdlcyA9IGN1cnJlbnRNZXNzYWdlcy5nZXQoY29udmVyc2F0aW9uVXNlcm5hbWUpIHx8IFtdO1xyXG4gICAgICAgICAgY29uc3QgdXBkYXRlZE1lc3NhZ2VzID0gY29udk1lc3NhZ2VzLmZpbHRlcihtID0+IG0uaWQgIT09IG1lc3NhZ2VJZCk7XHJcbiAgICAgICAgICBjdXJyZW50TWVzc2FnZXMuc2V0KGNvbnZlcnNhdGlvblVzZXJuYW1lLCB1cGRhdGVkTWVzc2FnZXMpO1xyXG4gICAgICAgICAgc2V0KHsgbWVzc2FnZXM6IGN1cnJlbnRNZXNzYWdlcyB9KTtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBJbmRleGVkREJcclxuICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmFnZU1hbmFnZXIuZGVsZXRlTWVzc2FnZShtZXNzYWdlSWQpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfl5HvuI8gTWVzc2FnZSBkZWxldGVkIGxvY2FsbHk6JywgbWVzc2FnZUlkKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBtZXNzYWdlIGxvY2FsbHk6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIGRlbGV0ZU1lc3NhZ2VGb3JFdmVyeW9uZTogYXN5bmMgKG1lc3NhZ2VJZDogbnVtYmVyLCBjb252ZXJzYXRpb25Vc2VybmFtZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgLy8gRGVsZXRlIGZvciBldmVyeW9uZSAtIHNlbmRzIGRlbGV0ZSBldmVudCB0byByZWNpcGllbnRcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gRmlyc3QgbWFyayBsb2NhbGx5IGFzIGRlbGV0ZWRcclxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRNZXNzYWdlcyA9IG5ldyBNYXAoZ2V0KCkubWVzc2FnZXMpO1xyXG4gICAgICAgICAgY29uc3QgY29udk1lc3NhZ2VzID0gY3VycmVudE1lc3NhZ2VzLmdldChjb252ZXJzYXRpb25Vc2VybmFtZSkgfHwgW107XHJcbiAgICAgICAgICBjb25zdCB1cGRhdGVkTWVzc2FnZXMgPSBjb252TWVzc2FnZXMubWFwKG0gPT4ge1xyXG4gICAgICAgICAgICBpZiAobS5pZCA9PT0gbWVzc2FnZUlkKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIC4uLm0sXHJcbiAgICAgICAgICAgICAgICBfZGVjcnlwdGVkQ29udGVudDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGVuY3J5cHRlZF9jb250ZW50OiBKU09OLnN0cmluZ2lmeSh7IGRlbGV0ZWQ6IHRydWUgfSksXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlX3R5cGU6ICdkZWxldGVkJyxcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBjdXJyZW50TWVzc2FnZXMuc2V0KGNvbnZlcnNhdGlvblVzZXJuYW1lLCB1cGRhdGVkTWVzc2FnZXMpO1xyXG4gICAgICAgICAgc2V0KHsgbWVzc2FnZXM6IGN1cnJlbnRNZXNzYWdlcyB9KTtcclxuXHJcbiAgICAgICAgICAvLyBNYXJrIGFzIGRlbGV0ZWQgaW4gSW5kZXhlZERCXHJcbiAgICAgICAgICBhd2FpdCBsb2NhbFN0b3JhZ2VNYW5hZ2VyLm1hcmtNZXNzYWdlQXNEZWxldGVkKG1lc3NhZ2VJZCk7XHJcblxyXG4gICAgICAgICAgLy8gU2VuZCBkZWxldGUgZXZlbnQgdG8gcmVjaXBpZW50IHZpYSBXZWJTb2NrZXRcclxuICAgICAgICAgIHdzTWFuYWdlci5zZW5kRGVsZXRlTWVzc2FnZShtZXNzYWdlSWQsIGNvbnZlcnNhdGlvblVzZXJuYW1lKTtcclxuXHJcbiAgICAgICAgICAvLyBBbHNvIHRyeSB0byBkZWxldGUgb24gc2VydmVyXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBhcGkuZGVsZXRlTWVzc2FnZShtZXNzYWdlSWQpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBkZWxldGUgbWVzc2FnZSBvbiBzZXJ2ZXI6JywgZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfl5HvuI8gTWVzc2FnZSBkZWxldGVkIGZvciBldmVyeW9uZTonLCBtZXNzYWdlSWQpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIG1lc3NhZ2UgZm9yIGV2ZXJ5b25lOicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBjbGVhckNoYXQ6IGFzeW5jICh1c2VybmFtZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgLy8gQ2xlYXIgbG9jYWwgY2hhdCBoaXN0b3J5IG9ubHkgLSBkb2VzIG5vdCBhZmZlY3QgdGhlIG90aGVyIHVzZXJcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgeyB1c2VyIH0gPSBnZXQoKTtcclxuICAgICAgICAgIGlmICghdXNlcikgcmV0dXJuO1xyXG5cclxuICAgICAgICAgIC8vIENsZWFyIGZyb20gbG9jYWwgc3RhdGVcclxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRNZXNzYWdlcyA9IG5ldyBNYXAoZ2V0KCkubWVzc2FnZXMpO1xyXG4gICAgICAgICAgY3VycmVudE1lc3NhZ2VzLnNldCh1c2VybmFtZSwgW10pO1xyXG4gICAgICAgICAgc2V0KHsgbWVzc2FnZXM6IGN1cnJlbnRNZXNzYWdlcyB9KTtcclxuXHJcbiAgICAgICAgICAvLyBDbGVhciBmcm9tIEluZGV4ZWREQlxyXG4gICAgICAgICAgYXdhaXQgbG9jYWxTdG9yYWdlTWFuYWdlci5jbGVhckNvbnZlcnNhdGlvbk1lc3NhZ2VzKHVzZXJuYW1lLCB1c2VyLnVzZXJuYW1lKTtcclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgY29udmVyc2F0aW9uIHByZXZpZXdcclxuICAgICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbnMgPSBbLi4uZ2V0KCkuY29udmVyc2F0aW9uc107XHJcbiAgICAgICAgICBjb25zdCBjb252SW5kZXggPSBjb252ZXJzYXRpb25zLmZpbmRJbmRleChjID0+IGMudXNlcm5hbWUgPT09IHVzZXJuYW1lKTtcclxuICAgICAgICAgIGlmIChjb252SW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICBjb252ZXJzYXRpb25zW2NvbnZJbmRleF0gPSB7XHJcbiAgICAgICAgICAgICAgLi4uY29udmVyc2F0aW9uc1tjb252SW5kZXhdLFxyXG4gICAgICAgICAgICAgIGxhc3RfbWVzc2FnZV9wcmV2aWV3OiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3RpbWU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICB1bnJlYWRfY291bnQ6IDAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHNldCh7IGNvbnZlcnNhdGlvbnMgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfp7kgQ2hhdCBjbGVhcmVkIGxvY2FsbHk6JywgdXNlcm5hbWUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2xlYXIgY2hhdDonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgZGVsZXRlQ29udmVyc2F0aW9uRm9yRXZlcnlvbmU6IGFzeW5jICh1c2VybmFtZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgLy8gRGVsZXRlIGVudGlyZSBjb252ZXJzYXRpb24gZm9yIGJvdGggc2lkZXNcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgeyB1c2VyIH0gPSBnZXQoKTtcclxuICAgICAgICAgIGlmICghdXNlcikgcmV0dXJuO1xyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGxvY2FsIHN0YXRlXHJcbiAgICAgICAgICBjb25zdCBjdXJyZW50TWVzc2FnZXMgPSBuZXcgTWFwKGdldCgpLm1lc3NhZ2VzKTtcclxuICAgICAgICAgIGN1cnJlbnRNZXNzYWdlcy5kZWxldGUodXNlcm5hbWUpO1xyXG4gICAgICAgICAgc2V0KHsgbWVzc2FnZXM6IGN1cnJlbnRNZXNzYWdlcyB9KTtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgY29udmVyc2F0aW9uIGZyb20gbGlzdFxyXG4gICAgICAgICAgY29uc3QgY29udmVyc2F0aW9ucyA9IGdldCgpLmNvbnZlcnNhdGlvbnMuZmlsdGVyKGMgPT4gYy51c2VybmFtZSAhPT0gdXNlcm5hbWUpO1xyXG4gICAgICAgICAgc2V0KHsgY29udmVyc2F0aW9ucyB9KTtcclxuXHJcbiAgICAgICAgICAvLyBDbGVhciBjdXJyZW50IGNvbnZlcnNhdGlvbiBpZiBpdCB3YXMgdGhlIGRlbGV0ZWQgb25lXHJcbiAgICAgICAgICBpZiAoZ2V0KCkuY3VycmVudENvbnZlcnNhdGlvbiA9PT0gdXNlcm5hbWUpIHtcclxuICAgICAgICAgICAgc2V0KHsgY3VycmVudENvbnZlcnNhdGlvbjogbnVsbCB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBEZWxldGUgZnJvbSBJbmRleGVkREJcclxuICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmFnZU1hbmFnZXIuZGVsZXRlQ29udmVyc2F0aW9uKHVzZXJuYW1lKTtcclxuXHJcbiAgICAgICAgICAvLyBTZW5kIGRlbGV0ZSBldmVudCB0byByZWNpcGllbnQgdmlhIFdlYlNvY2tldFxyXG4gICAgICAgICAgd3NNYW5hZ2VyLnNlbmREZWxldGVDb252ZXJzYXRpb24odXNlcm5hbWUpO1xyXG5cclxuICAgICAgICAgIC8vIEFsc28gdHJ5IHRvIGRlbGV0ZSBvbiBzZXJ2ZXJcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGFwaS5kZWxldGVDb252ZXJzYXRpb24odXNlcm5hbWUpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBkZWxldGUgY29udmVyc2F0aW9uIG9uIHNlcnZlcjonLCBlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+Xke+4jyBDb252ZXJzYXRpb24gZGVsZXRlZCBmb3IgZXZlcnlvbmU6JywgdXNlcm5hbWUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIGNvbnZlcnNhdGlvbiBmb3IgZXZlcnlvbmU6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIGhhbmRsZVJlbW90ZURlbGV0ZU1lc3NhZ2U6IChtZXNzYWdlSWQ6IG51bWJlciwgc2VuZGVyVXNlcm5hbWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIC8vIEhhbmRsZSBpbmNvbWluZyBkZWxldGUgbWVzc2FnZSBldmVudCBmcm9tIGFub3RoZXIgdXNlclxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRNZXNzYWdlcyA9IG5ldyBNYXAoZ2V0KCkubWVzc2FnZXMpO1xyXG4gICAgICAgIGNvbnN0IGNvbnZNZXNzYWdlcyA9IGN1cnJlbnRNZXNzYWdlcy5nZXQoc2VuZGVyVXNlcm5hbWUpIHx8IFtdO1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRNZXNzYWdlcyA9IGNvbnZNZXNzYWdlcy5tYXAobSA9PiB7XHJcbiAgICAgICAgICBpZiAobS5pZCA9PT0gbWVzc2FnZUlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgLi4ubSxcclxuICAgICAgICAgICAgICBfZGVjcnlwdGVkQ29udGVudDogbnVsbCxcclxuICAgICAgICAgICAgICBlbmNyeXB0ZWRfY29udGVudDogSlNPTi5zdHJpbmdpZnkoeyBkZWxldGVkOiB0cnVlIH0pLFxyXG4gICAgICAgICAgICAgIG1lc3NhZ2VfdHlwZTogJ2RlbGV0ZWQnLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY3VycmVudE1lc3NhZ2VzLnNldChzZW5kZXJVc2VybmFtZSwgdXBkYXRlZE1lc3NhZ2VzKTtcclxuICAgICAgICBzZXQoeyBtZXNzYWdlczogY3VycmVudE1lc3NhZ2VzIH0pO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgSW5kZXhlZERCXHJcbiAgICAgICAgbG9jYWxTdG9yYWdlTWFuYWdlci5tYXJrTWVzc2FnZUFzRGVsZXRlZChtZXNzYWdlSWQpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OoIFJlbW90ZSBtZXNzYWdlIGRlbGV0aW9uIHJlY2VpdmVkOicsIG1lc3NhZ2VJZCk7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBoYW5kbGVSZW1vdGVEZWxldGVDb252ZXJzYXRpb246IChzZW5kZXJVc2VybmFtZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgLy8gSGFuZGxlIGluY29taW5nIGRlbGV0ZSBjb252ZXJzYXRpb24gZXZlbnQgZnJvbSBhbm90aGVyIHVzZXJcclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzc2FnZXMgPSBuZXcgTWFwKGdldCgpLm1lc3NhZ2VzKTtcclxuICAgICAgICBjdXJyZW50TWVzc2FnZXMuZGVsZXRlKHNlbmRlclVzZXJuYW1lKTtcclxuICAgICAgICBzZXQoeyBtZXNzYWdlczogY3VycmVudE1lc3NhZ2VzIH0pO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgY29udmVyc2F0aW9uIGZyb20gbGlzdFxyXG4gICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbnMgPSBnZXQoKS5jb252ZXJzYXRpb25zLmZpbHRlcihjID0+IGMudXNlcm5hbWUgIT09IHNlbmRlclVzZXJuYW1lKTtcclxuICAgICAgICBzZXQoeyBjb252ZXJzYXRpb25zIH0pO1xyXG5cclxuICAgICAgICAvLyBDbGVhciBjdXJyZW50IGNvbnZlcnNhdGlvbiBpZiBpdCB3YXMgdGhlIGRlbGV0ZWQgb25lXHJcbiAgICAgICAgaWYgKGdldCgpLmN1cnJlbnRDb252ZXJzYXRpb24gPT09IHNlbmRlclVzZXJuYW1lKSB7XHJcbiAgICAgICAgICBzZXQoeyBjdXJyZW50Q29udmVyc2F0aW9uOiBudWxsIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVsZXRlIGZyb20gSW5kZXhlZERCXHJcbiAgICAgICAgbG9jYWxTdG9yYWdlTWFuYWdlci5kZWxldGVDb252ZXJzYXRpb24oc2VuZGVyVXNlcm5hbWUpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OoIFJlbW90ZSBjb252ZXJzYXRpb24gZGVsZXRpb24gcmVjZWl2ZWQ6Jywgc2VuZGVyVXNlcm5hbWUpO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gPT09PT09PT09PT09IFBlcnNpc3RlbnQgU3RvcmFnZSA9PT09PT09PT09PT1cclxuXHJcbiAgICAgIGxvYWRQZXJzaXN0ZWREYXRhOiBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OCIExvYWRpbmcgcGVyc2lzdGVkIGRhdGEgZnJvbSBJbmRleGVkREIuLi4nKTtcclxuXHJcbiAgICAgICAgICAvLyBMb2FkIGNvbnZlcnNhdGlvbnNcclxuICAgICAgICAgIGNvbnN0IHN0b3JlZENvbnZlcnNhdGlvbnMgPSBhd2FpdCBsb2NhbFN0b3JhZ2VNYW5hZ2VyLmdldEFsbENvbnZlcnNhdGlvbnMoKTtcclxuICAgICAgICAgIGlmIChzdG9yZWRDb252ZXJzYXRpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgY29udmVyc2F0aW9ucyA9IHN0b3JlZENvbnZlcnNhdGlvbnMubWFwKGNvbnYgPT4gKHtcclxuICAgICAgICAgICAgICB1c2VyX2lkOiBjb252LnVzZXJfaWQsXHJcbiAgICAgICAgICAgICAgdXNlcm5hbWU6IGNvbnYudXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgcHVibGljX2tleTogY29udi5wdWJsaWNfa2V5LFxyXG4gICAgICAgICAgICAgIGlkZW50aXR5X2tleTogY29udi5pZGVudGl0eV9rZXksXHJcbiAgICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3RpbWU6IGNvbnYubGFzdF9tZXNzYWdlX3RpbWUsXHJcbiAgICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3ByZXZpZXc6IGNvbnYubGFzdF9tZXNzYWdlX3ByZXZpZXcsXHJcbiAgICAgICAgICAgICAgdW5yZWFkX2NvdW50OiBjb252LnVucmVhZF9jb3VudCxcclxuICAgICAgICAgICAgICBpc19vbmxpbmU6IGNvbnYuaXNfb25saW5lXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgc2V0KHsgY29udmVyc2F0aW9ucyB9KTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk4IgTG9hZGVkICR7Y29udmVyc2F0aW9ucy5sZW5ndGh9IGNvbnZlcnNhdGlvbnMgZnJvbSBzdG9yYWdlYCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTG9hZCBjb250YWN0c1xyXG4gICAgICAgICAgY29uc3Qgc3RvcmVkQ29udGFjdHMgPSBhd2FpdCBsb2NhbFN0b3JhZ2VNYW5hZ2VyLmdldEFsbENvbnRhY3RzKCk7XHJcbiAgICAgICAgICBpZiAoc3RvcmVkQ29udGFjdHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBjb250YWN0cyA9IHN0b3JlZENvbnRhY3RzLm1hcChjb250YWN0ID0+ICh7XHJcbiAgICAgICAgICAgICAgaWQ6IGNvbnRhY3QuaWQsXHJcbiAgICAgICAgICAgICAgdXNlcl9pZDogY29udGFjdC51c2VyX2lkLFxyXG4gICAgICAgICAgICAgIGNvbnRhY3RfaWQ6IGNvbnRhY3QuY29udGFjdF9pZCxcclxuICAgICAgICAgICAgICBjb250YWN0X3VzZXJuYW1lOiBjb250YWN0LmNvbnRhY3RfdXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgY29udGFjdF9lbWFpbDogY29udGFjdC5jb250YWN0X2VtYWlsLFxyXG4gICAgICAgICAgICAgIHB1YmxpY19rZXk6IGNvbnRhY3QucHVibGljX2tleSxcclxuICAgICAgICAgICAgICBpZGVudGl0eV9rZXk6IGNvbnRhY3QuaWRlbnRpdHlfa2V5LFxyXG4gICAgICAgICAgICAgIG5pY2tuYW1lOiBjb250YWN0Lm5pY2tuYW1lLFxyXG4gICAgICAgICAgICAgIGlzX2Jsb2NrZWQ6IGNvbnRhY3QuaXNfYmxvY2tlZCxcclxuICAgICAgICAgICAgICBpc192ZXJpZmllZDogY29udGFjdC5pc192ZXJpZmllZCxcclxuICAgICAgICAgICAgICBhZGRlZF9hdDogY29udGFjdC5hZGRlZF9hdFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHNldCh7IGNvbnRhY3RzIH0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TgiBMb2FkZWQgJHtjb250YWN0cy5sZW5ndGh9IGNvbnRhY3RzIGZyb20gc3RvcmFnZWApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIExvYWQgbWVzc2FnZXMgZm9yIGFsbCBjb252ZXJzYXRpb25zXHJcbiAgICAgICAgICBjb25zdCB7IHVzZXIgfSA9IGdldCgpO1xyXG4gICAgICAgICAgaWYgKHVzZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZXNNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29udiBvZiBzdG9yZWRDb252ZXJzYXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgY29uc3Qgc3RvcmVkTWVzc2FnZXMgPSBhd2FpdCBsb2NhbFN0b3JhZ2VNYW5hZ2VyLmdldENvbnZlcnNhdGlvbk1lc3NhZ2VzKFxyXG4gICAgICAgICAgICAgICAgY29udi51c2VybmFtZSxcclxuICAgICAgICAgICAgICAgIHVzZXIudXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgICA1MFxyXG4gICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChzdG9yZWRNZXNzYWdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IHN0b3JlZE1lc3NhZ2VzLm1hcChtc2cgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgaWQ6IG1zZy5pZCxcclxuICAgICAgICAgICAgICAgICAgc2VuZGVyX2lkOiBtc2cuc2VuZGVyX2lkLFxyXG4gICAgICAgICAgICAgICAgICBzZW5kZXJfdXNlcm5hbWU6IG1zZy5zZW5kZXJfdXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgIHJlY2lwaWVudF9pZDogbXNnLnJlY2lwaWVudF9pZCxcclxuICAgICAgICAgICAgICAgICAgcmVjaXBpZW50X3VzZXJuYW1lOiBtc2cucmVjaXBpZW50X3VzZXJuYW1lLFxyXG4gICAgICAgICAgICAgICAgICBlbmNyeXB0ZWRfY29udGVudDogbXNnLmVuY3J5cHRlZF9jb250ZW50LFxyXG4gICAgICAgICAgICAgICAgICBlbmNyeXB0ZWRfa2V5OiBtc2cuZW5jcnlwdGVkX2tleSxcclxuICAgICAgICAgICAgICAgICAgbWVzc2FnZV90eXBlOiBtc2cubWVzc2FnZV90eXBlLFxyXG4gICAgICAgICAgICAgICAgICBzdGF0dXM6IG1zZy5zdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG1zZy5jcmVhdGVkX2F0LFxyXG4gICAgICAgICAgICAgICAgICBkZWxpdmVyZWRfYXQ6IG1zZy5kZWxpdmVyZWRfYXQsXHJcbiAgICAgICAgICAgICAgICAgIHJlYWRfYXQ6IG1zZy5yZWFkX2F0LFxyXG4gICAgICAgICAgICAgICAgICBleHBpcnlfdHlwZTogbXNnLmV4cGlyeV90eXBlLFxyXG4gICAgICAgICAgICAgICAgICBleHBpcmVzX2F0OiBtc2cuZXhwaXJlc19hdCxcclxuICAgICAgICAgICAgICAgICAgZmlsZV9tZXRhZGF0YTogbXNnLmZpbGVfbWV0YWRhdGFcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzTWFwLnNldChjb252LnVzZXJuYW1lLCBtZXNzYWdlcyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldCh7IG1lc3NhZ2VzOiBtZXNzYWdlc01hcCB9KTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk4IgTG9hZGVkIG1lc3NhZ2VzIGZvciAke21lc3NhZ2VzTWFwLnNpemV9IGNvbnZlcnNhdGlvbnNgKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gbG9hZCBwZXJzaXN0ZWQgZGF0YTonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgc3luY1dpdGhTZXJ2ZXI6IGFzeW5jICgpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ/CflIQgU3luY2luZyB3aXRoIHNlcnZlci4uLicpO1xyXG5cclxuICAgICAgICAgIC8vIExvYWQgZnJlc2ggZGF0YSBmcm9tIHNlcnZlclxyXG4gICAgICAgICAgYXdhaXQgZ2V0KCkubG9hZENvbnRhY3RzKCk7XHJcbiAgICAgICAgICBhd2FpdCBnZXQoKS5sb2FkQ29udmVyc2F0aW9ucygpO1xyXG5cclxuICAgICAgICAgIC8vIEdldCBhbGwgY29udmVyc2F0aW9ucyB3aXRoIG1lc3NhZ2VzIGZyb20gc2VydmVyXHJcbiAgICAgICAgICBjb25zdCBhbGxDb252ZXJzYXRpb25zRGF0YSA9IGF3YWl0IGFwaS5nZXRBbGxDb252ZXJzYXRpb25zV2l0aE1lc3NhZ2VzKCk7XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIGxvY2FsIHN0b3JhZ2Ugd2l0aCBzZXJ2ZXIgZGF0YVxyXG4gICAgICAgICAgY29uc3QgeyB1c2VyLCBjb250YWN0cywgY29udmVyc2F0aW9ucyB9ID0gZ2V0KCk7XHJcbiAgICAgICAgICBpZiAodXNlcikge1xyXG4gICAgICAgICAgICAvLyBTYXZlIGNvbnZlcnNhdGlvbnMgdG8gSW5kZXhlZERCXHJcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZENvbnZlcnNhdGlvbnM6IFN0b3JlZENvbnZlcnNhdGlvbltdID0gY29udmVyc2F0aW9ucy5tYXAoY29udiA9PiAoe1xyXG4gICAgICAgICAgICAgIHVzZXJuYW1lOiBjb252LnVzZXJuYW1lLFxyXG4gICAgICAgICAgICAgIHVzZXJfaWQ6IGNvbnYudXNlcl9pZCxcclxuICAgICAgICAgICAgICBwdWJsaWNfa2V5OiBjb252LnB1YmxpY19rZXksXHJcbiAgICAgICAgICAgICAgaWRlbnRpdHlfa2V5OiBjb252LmlkZW50aXR5X2tleSxcclxuICAgICAgICAgICAgICBsYXN0X21lc3NhZ2VfdGltZTogY29udi5sYXN0X21lc3NhZ2VfdGltZSxcclxuICAgICAgICAgICAgICBsYXN0X21lc3NhZ2VfcHJldmlldzogY29udi5sYXN0X21lc3NhZ2VfcHJldmlldyxcclxuICAgICAgICAgICAgICB1bnJlYWRfY291bnQ6IGNvbnYudW5yZWFkX2NvdW50LFxyXG4gICAgICAgICAgICAgIGlzX29ubGluZTogY29udi5pc19vbmxpbmVcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBhd2FpdCBsb2NhbFN0b3JhZ2VNYW5hZ2VyLnNhdmVDb252ZXJzYXRpb25zKHN0b3JlZENvbnZlcnNhdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2F2ZSBjb250YWN0cyB0byBJbmRleGVkREJcclxuICAgICAgICAgICAgY29uc3Qgc3RvcmVkQ29udGFjdHM6IFN0b3JlZENvbnRhY3RbXSA9IGNvbnRhY3RzLm1hcChjb250YWN0ID0+ICh7XHJcbiAgICAgICAgICAgICAgaWQ6IGNvbnRhY3QuaWQsXHJcbiAgICAgICAgICAgICAgdXNlcl9pZDogY29udGFjdC51c2VyX2lkLFxyXG4gICAgICAgICAgICAgIGNvbnRhY3RfaWQ6IGNvbnRhY3QuY29udGFjdF9pZCxcclxuICAgICAgICAgICAgICBjb250YWN0X3VzZXJuYW1lOiBjb250YWN0LmNvbnRhY3RfdXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgY29udGFjdF9lbWFpbDogY29udGFjdC5jb250YWN0X2VtYWlsLFxyXG4gICAgICAgICAgICAgIHB1YmxpY19rZXk6IGNvbnRhY3QucHVibGljX2tleSxcclxuICAgICAgICAgICAgICBpZGVudGl0eV9rZXk6IGNvbnRhY3QuaWRlbnRpdHlfa2V5LFxyXG4gICAgICAgICAgICAgIG5pY2tuYW1lOiBjb250YWN0Lm5pY2tuYW1lLFxyXG4gICAgICAgICAgICAgIGlzX2Jsb2NrZWQ6IGNvbnRhY3QuaXNfYmxvY2tlZCxcclxuICAgICAgICAgICAgICBpc192ZXJpZmllZDogY29udGFjdC5pc192ZXJpZmllZCxcclxuICAgICAgICAgICAgICBhZGRlZF9hdDogY29udGFjdC5hZGRlZF9hdFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmFnZU1hbmFnZXIuc2F2ZUNvbnRhY3RzKHN0b3JlZENvbnRhY3RzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNhdmUgbWVzc2FnZXMgdG8gSW5kZXhlZERCXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3VzZXJuYW1lLCBtZXNzYWdlc10gb2YgT2JqZWN0LmVudHJpZXMoYWxsQ29udmVyc2F0aW9uc0RhdGEpKSB7XHJcbiAgICAgICAgICAgICAgY29uc3Qgc3RvcmVkTWVzc2FnZXM6IFN0b3JlZE1lc3NhZ2VbXSA9IChtZXNzYWdlcyBhcyBNZXNzYWdlW10pLm1hcChtc2cgPT4gKHtcclxuICAgICAgICAgICAgICAgIGlkOiBtc2cuaWQsXHJcbiAgICAgICAgICAgICAgICBzZW5kZXJfaWQ6IG1zZy5zZW5kZXJfaWQsXHJcbiAgICAgICAgICAgICAgICBzZW5kZXJfdXNlcm5hbWU6IG1zZy5zZW5kZXJfdXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgICByZWNpcGllbnRfaWQ6IG1zZy5yZWNpcGllbnRfaWQsXHJcbiAgICAgICAgICAgICAgICByZWNpcGllbnRfdXNlcm5hbWU6IG1zZy5yZWNpcGllbnRfdXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgICBlbmNyeXB0ZWRfY29udGVudDogbXNnLmVuY3J5cHRlZF9jb250ZW50LFxyXG4gICAgICAgICAgICAgICAgZW5jcnlwdGVkX2tleTogbXNnLmVuY3J5cHRlZF9rZXksXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlX3R5cGU6IG1zZy5tZXNzYWdlX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6IG1zZy5zdGF0dXMsXHJcbiAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBtc2cuY3JlYXRlZF9hdCxcclxuICAgICAgICAgICAgICAgIGRlbGl2ZXJlZF9hdDogbXNnLmRlbGl2ZXJlZF9hdCxcclxuICAgICAgICAgICAgICAgIHJlYWRfYXQ6IG1zZy5yZWFkX2F0LFxyXG4gICAgICAgICAgICAgICAgZXhwaXJ5X3R5cGU6IG1zZy5leHBpcnlfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGlyZXNfYXQ6IG1zZy5leHBpcmVzX2F0LFxyXG4gICAgICAgICAgICAgICAgZmlsZV9tZXRhZGF0YTogbXNnLmZpbGVfbWV0YWRhdGFcclxuICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgYXdhaXQgbG9jYWxTdG9yYWdlTWFuYWdlci5zYXZlTWVzc2FnZXMoc3RvcmVkTWVzc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgaW4tbWVtb3J5IHN0YXRlXHJcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFt1c2VybmFtZSwgbWVzc2FnZXNdIG9mIE9iamVjdC5lbnRyaWVzKGFsbENvbnZlcnNhdGlvbnNEYXRhKSkge1xyXG4gICAgICAgICAgICAgIG1lc3NhZ2VzTWFwLnNldCh1c2VybmFtZSwgbWVzc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldCh7IG1lc3NhZ2VzOiBtZXNzYWdlc01hcCB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgU3luYyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBTeW5jIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgcGVyc2lzdE1lc3NhZ2U6IGFzeW5jIChtZXNzYWdlOiBNZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHN0b3JlZE1lc3NhZ2U6IFN0b3JlZE1lc3NhZ2UgPSB7XHJcbiAgICAgICAgICAgIGlkOiBtZXNzYWdlLmlkLFxyXG4gICAgICAgICAgICBzZW5kZXJfaWQ6IG1lc3NhZ2Uuc2VuZGVyX2lkLFxyXG4gICAgICAgICAgICBzZW5kZXJfdXNlcm5hbWU6IG1lc3NhZ2Uuc2VuZGVyX3VzZXJuYW1lLFxyXG4gICAgICAgICAgICByZWNpcGllbnRfaWQ6IG1lc3NhZ2UucmVjaXBpZW50X2lkLFxyXG4gICAgICAgICAgICByZWNpcGllbnRfdXNlcm5hbWU6IG1lc3NhZ2UucmVjaXBpZW50X3VzZXJuYW1lLFxyXG4gICAgICAgICAgICBlbmNyeXB0ZWRfY29udGVudDogbWVzc2FnZS5lbmNyeXB0ZWRfY29udGVudCxcclxuICAgICAgICAgICAgZW5jcnlwdGVkX2tleTogbWVzc2FnZS5lbmNyeXB0ZWRfa2V5LFxyXG4gICAgICAgICAgICBtZXNzYWdlX3R5cGU6IG1lc3NhZ2UubWVzc2FnZV90eXBlLFxyXG4gICAgICAgICAgICBzdGF0dXM6IG1lc3NhZ2Uuc3RhdHVzLFxyXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBtZXNzYWdlLmNyZWF0ZWRfYXQsXHJcbiAgICAgICAgICAgIGRlbGl2ZXJlZF9hdDogbWVzc2FnZS5kZWxpdmVyZWRfYXQsXHJcbiAgICAgICAgICAgIHJlYWRfYXQ6IG1lc3NhZ2UucmVhZF9hdCxcclxuICAgICAgICAgICAgZXhwaXJ5X3R5cGU6IG1lc3NhZ2UuZXhwaXJ5X3R5cGUsXHJcbiAgICAgICAgICAgIGV4cGlyZXNfYXQ6IG1lc3NhZ2UuZXhwaXJlc19hdCxcclxuICAgICAgICAgICAgZmlsZV9tZXRhZGF0YTogbWVzc2FnZS5maWxlX21ldGFkYXRhXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgYXdhaXQgbG9jYWxTdG9yYWdlTWFuYWdlci5zYXZlTWVzc2FnZShzdG9yZWRNZXNzYWdlKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBwZXJzaXN0IG1lc3NhZ2U6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIHBlcnNpc3RDb252ZXJzYXRpb246IGFzeW5jIChjb252ZXJzYXRpb246IENvbnZlcnNhdGlvbikgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBzdG9yZWRDb252ZXJzYXRpb246IFN0b3JlZENvbnZlcnNhdGlvbiA9IHtcclxuICAgICAgICAgICAgdXNlcm5hbWU6IGNvbnZlcnNhdGlvbi51c2VybmFtZSxcclxuICAgICAgICAgICAgdXNlcl9pZDogY29udmVyc2F0aW9uLnVzZXJfaWQsXHJcbiAgICAgICAgICAgIHB1YmxpY19rZXk6IGNvbnZlcnNhdGlvbi5wdWJsaWNfa2V5LFxyXG4gICAgICAgICAgICBpZGVudGl0eV9rZXk6IGNvbnZlcnNhdGlvbi5pZGVudGl0eV9rZXksXHJcbiAgICAgICAgICAgIGxhc3RfbWVzc2FnZV90aW1lOiBjb252ZXJzYXRpb24ubGFzdF9tZXNzYWdlX3RpbWUsXHJcbiAgICAgICAgICAgIGxhc3RfbWVzc2FnZV9wcmV2aWV3OiBjb252ZXJzYXRpb24ubGFzdF9tZXNzYWdlX3ByZXZpZXcsXHJcbiAgICAgICAgICAgIHVucmVhZF9jb3VudDogY29udmVyc2F0aW9uLnVucmVhZF9jb3VudCxcclxuICAgICAgICAgICAgaXNfb25saW5lOiBjb252ZXJzYXRpb24uaXNfb25saW5lXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgYXdhaXQgbG9jYWxTdG9yYWdlTWFuYWdlci5zYXZlQ29udmVyc2F0aW9uKHN0b3JlZENvbnZlcnNhdGlvbik7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gcGVyc2lzdCBjb252ZXJzYXRpb246JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIGxvYWRBbGxDb252ZXJzYXRpb25IaXN0b3J5OiBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHsgY29udmVyc2F0aW9ucyB9ID0gZ2V0KCk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TmiBMb2FkaW5nIGhpc3RvcnkgZm9yICR7Y29udmVyc2F0aW9ucy5sZW5ndGh9IGNvbnZlcnNhdGlvbnMuLi5gKTtcclxuXHJcbiAgICAgICAgICBmb3IgKGNvbnN0IGNvbnYgb2YgY29udmVyc2F0aW9ucykge1xyXG4gICAgICAgICAgICBhd2FpdCBnZXQoKS5sb2FkTWVzc2FnZXMoY29udi51c2VybmFtZSk7XHJcbiAgICAgICAgICAgIC8vIFNtYWxsIGRlbGF5IHRvIHByZXZlbnQgb3ZlcndoZWxtaW5nIHRoZSBzZXJ2ZXJcclxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgQWxsIGNvbnZlcnNhdGlvbiBoaXN0b3J5IGxvYWRlZCcpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIGxvYWQgY29udmVyc2F0aW9uIGhpc3Rvcnk6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgIH0pLFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAnY2lwaGVybGluay1zdG9yZScsXHJcbiAgICAgIHBhcnRpYWxpemU6IChzdGF0ZSkgPT4gKHtcclxuICAgICAgICAvLyBPbmx5IHBlcnNpc3Qgbm9uLXNlbnNpdGl2ZSBkYXRhXHJcbiAgICAgICAgY3VycmVudENvbnZlcnNhdGlvbjogc3RhdGUuY3VycmVudENvbnZlcnNhdGlvbixcclxuICAgICAgfSksXHJcbiAgICB9XHJcbiAgKVxyXG4pO1xyXG5cclxuLy8gU2V0dXAgV2ViU29ja2V0IG1lc3NhZ2UgaGFuZGxlcnNcclxuZnVuY3Rpb24gc2V0dXBXZWJTb2NrZXRIYW5kbGVycyhnZXQ6ICgpID0+IEFwcFN0YXRlLCBzZXQ6IChzdGF0ZTogUGFydGlhbDxBcHBTdGF0ZT4pID0+IHZvaWQpIHtcclxuICAvLyBIYW5kbGUgaW5jb21pbmcgbWVzc2FnZXNcclxuICB3c01hbmFnZXIub24oJ21lc3NhZ2UnLCAoZGF0YSkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ/Cfk6ggUmVjZWl2ZWQgbWVzc2FnZTonLCBkYXRhKTtcclxuXHJcbiAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xyXG4gICAgY29uc3Qgc2VuZGVyVXNlcm5hbWUgPSBkYXRhLnNlbmRlcl91c2VybmFtZTtcclxuXHJcbiAgICAvLyBDcmVhdGUgbWVzc2FnZSBvYmplY3RcclxuICAgIGNvbnN0IG1lc3NhZ2U6IE1lc3NhZ2UgPSB7XHJcbiAgICAgIGlkOiBkYXRhLm1lc3NhZ2VfaWQsXHJcbiAgICAgIHNlbmRlcl9pZDogZGF0YS5zZW5kZXJfaWQsXHJcbiAgICAgIHNlbmRlcl91c2VybmFtZTogc2VuZGVyVXNlcm5hbWUsXHJcbiAgICAgIHJlY2lwaWVudF9pZDogc3RhdGUudXNlcj8uaWQgfHwgMCxcclxuICAgICAgcmVjaXBpZW50X3VzZXJuYW1lOiBzdGF0ZS51c2VyPy51c2VybmFtZSB8fCAnJyxcclxuICAgICAgZW5jcnlwdGVkX2NvbnRlbnQ6IGRhdGEuY29udGVudCB8fCBkYXRhLmVuY3J5cHRlZF9jb250ZW50LFxyXG4gICAgICBlbmNyeXB0ZWRfa2V5OiBkYXRhLmVuY3J5cHRlZF9rZXksXHJcbiAgICAgIG1lc3NhZ2VfdHlwZTogZGF0YS5tZXNzYWdlX3R5cGUgfHwgJ3RleHQnLFxyXG4gICAgICBzdGF0dXM6ICdkZWxpdmVyZWQnLFxyXG4gICAgICBleHBpcnlfdHlwZTogZGF0YS5leHBpcnlfdHlwZSB8fCAnbm9uZScsXHJcbiAgICAgIGNyZWF0ZWRfYXQ6IGRhdGEudGltZXN0YW1wLFxyXG4gICAgfTtcclxuXHJcbiAgICBnZXQoKS5hZGRJbmNvbWluZ01lc3NhZ2UobWVzc2FnZSk7XHJcblxyXG4gICAgLy8gU2VuZCBkZWxpdmVyeSByZWNlaXB0XHJcbiAgICB3c01hbmFnZXIuc2VuZERlbGl2ZXJ5UmVjZWlwdChkYXRhLm1lc3NhZ2VfaWQsIGRhdGEuc2VuZGVyX2lkKTtcclxuICB9KTtcclxuXHJcbiAgLy8gSGFuZGxlIHR5cGluZyBpbmRpY2F0b3JzXHJcbiAgd3NNYW5hZ2VyLm9uKCd0eXBpbmcnLCAoZGF0YSkgPT4ge1xyXG4gICAgZ2V0KCkuc2V0VXNlclR5cGluZyhkYXRhLnNlbmRlcl91c2VybmFtZSwgZGF0YS5pc190eXBpbmcpO1xyXG5cclxuICAgIC8vIEF1dG8tY2xlYXIgdHlwaW5nIGFmdGVyIDMgc2Vjb25kc1xyXG4gICAgaWYgKGRhdGEuaXNfdHlwaW5nKSB7XHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGdldCgpLnNldFVzZXJUeXBpbmcoZGF0YS5zZW5kZXJfdXNlcm5hbWUsIGZhbHNlKTtcclxuICAgICAgfSwgMzAwMCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEhhbmRsZSBwcmVzZW5jZSB1cGRhdGVzXHJcbiAgd3NNYW5hZ2VyLm9uKCdwcmVzZW5jZScsIChkYXRhKSA9PiB7XHJcbiAgICBnZXQoKS5zZXRVc2VyT25saW5lKGRhdGEudXNlcl9pZCwgZGF0YS5pc19vbmxpbmUpO1xyXG4gIH0pO1xyXG5cclxuICAvLyBIYW5kbGUgbWVzc2FnZSBzZW50IGNvbmZpcm1hdGlvbnNcclxuICB3c01hbmFnZXIub24oJ21lc3NhZ2Vfc2VudCcsIChkYXRhKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygn4pyFIE1lc3NhZ2Ugc2VudCBjb25maXJtYXRpb246JywgZGF0YSk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIEhhbmRsZSByZWFkIHJlY2VpcHRzXHJcbiAgd3NNYW5hZ2VyLm9uKCdyZWFkX3JlY2VpcHQnLCAoZGF0YSkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ/CfkYHvuI8gUmVhZCByZWNlaXB0OicsIGRhdGEpO1xyXG4gICAgLy8gQ291bGQgdXBkYXRlIG1lc3NhZ2Ugc3RhdHVzIGluIFVJIGhlcmVcclxuICB9KTtcclxuXHJcbiAgLy8gSGFuZGxlIGRlbGl2ZXJ5IHJlY2VpcHRzXHJcbiAgd3NNYW5hZ2VyLm9uKCdkZWxpdmVyeV9yZWNlaXB0JywgKGRhdGEpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKCfwn5OsIERlbGl2ZXJ5IHJlY2VpcHQ6JywgZGF0YSk7XHJcbiAgICAvLyBDb3VsZCB1cGRhdGUgbWVzc2FnZSBzdGF0dXMgaW4gVUkgaGVyZVxyXG4gIH0pO1xyXG5cclxuICAvLyBIYW5kbGUgY29ubmVjdGlvbiBjb25maXJtYXRpb25cclxuICB3c01hbmFnZXIub24oJ2Nvbm5lY3RlZCcsIChkYXRhKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygn4pyFIFdlYlNvY2tldCBjb25uZWN0ZWQ6JywgZGF0YSk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIEhhbmRsZSBlcnJvcnNcclxuICB3c01hbmFnZXIub24oJ2Vycm9yJywgKGRhdGEpID0+IHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBXZWJTb2NrZXQgZXJyb3I6JywgZGF0YSk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIEhhbmRsZSByZW1vdGUgbWVzc2FnZSBkZWxldGlvblxyXG4gIHdzTWFuYWdlci5vbignZGVsZXRlX21lc3NhZ2VfcmVjZWl2ZWQnLCAoZGF0YSkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ/Cfl5HvuI8gUmVtb3RlIGRlbGV0ZSBtZXNzYWdlIHJlY2VpdmVkOicsIGRhdGEpO1xyXG4gICAgY29uc3QgbWVzc2FnZUlkID0gZGF0YS5tZXNzYWdlX2lkIHx8IGRhdGEuZGF0YT8ubWVzc2FnZV9pZDtcclxuICAgIGNvbnN0IHNlbmRlclVzZXJuYW1lID0gZGF0YS5zZW5kZXJfdXNlcm5hbWUgfHwgZGF0YS5kYXRhPy5zZW5kZXJfdXNlcm5hbWU7XHJcbiAgICBpZiAobWVzc2FnZUlkICYmIHNlbmRlclVzZXJuYW1lKSB7XHJcbiAgICAgIGdldCgpLmhhbmRsZVJlbW90ZURlbGV0ZU1lc3NhZ2UobWVzc2FnZUlkLCBzZW5kZXJVc2VybmFtZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEhhbmRsZSByZW1vdGUgY29udmVyc2F0aW9uIGRlbGV0aW9uXHJcbiAgd3NNYW5hZ2VyLm9uKCdkZWxldGVfY29udmVyc2F0aW9uX3JlY2VpdmVkJywgKGRhdGEpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKCfwn5eR77iPIFJlbW90ZSBkZWxldGUgY29udmVyc2F0aW9uIHJlY2VpdmVkOicsIGRhdGEpO1xyXG4gICAgY29uc3Qgc2VuZGVyVXNlcm5hbWUgPSBkYXRhLnNlbmRlcl91c2VybmFtZSB8fCBkYXRhLmRhdGE/LnNlbmRlcl91c2VybmFtZTtcclxuICAgIGlmIChzZW5kZXJVc2VybmFtZSkge1xyXG4gICAgICBnZXQoKS5oYW5kbGVSZW1vdGVEZWxldGVDb252ZXJzYXRpb24oc2VuZGVyVXNlcm5hbWUpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vLyBFeHRlbmQgTWVzc2FnZSB0eXBlIHRvIGluY2x1ZGUgZGVjcnlwdGVkIGNvbnRlbnQgZm9yIGxvY2FsIGRpc3BsYXlcclxuZGVjbGFyZSBtb2R1bGUgJy4vYXBpJyB7XHJcbiAgaW50ZXJmYWNlIE1lc3NhZ2Uge1xyXG4gICAgX2RlY3J5cHRlZENvbnRlbnQ/OiBzdHJpbmcgfCBudWxsO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiY3JlYXRlIiwicGVyc2lzdCIsImFwaSIsImdlbmVyYXRlS2V5UGFpciIsImdlbmVyYXRlU2lnbmluZ0tleVBhaXIiLCJnZW5lcmF0ZUtleUJ1bmRsZSIsIktleVN0b3JhZ2UiLCJlbmNyeXB0TWVzc2FnZSIsImRlY3J5cHRNZXNzYWdlIiwidmVyaWZ5S2V5UGFpciIsImRlcml2ZVB1YmxpY0tleUZyb21Qcml2YXRlIiwid3NNYW5hZ2VyIiwibG9jYWxTdG9yYWdlTWFuYWdlciIsImJ1aWxkTWVzc2FnZVRoZW1lIiwidXNlU3RvcmUiLCJzZXQiLCJnZXQiLCJ1c2VyIiwidG9rZW4iLCJpc0F1dGhlbnRpY2F0ZWQiLCJpc0xvYWRpbmciLCJlcnJvciIsInByaXZhdGVLZXkiLCJwdWJsaWNLZXkiLCJpZGVudGl0eUtleSIsImlkZW50aXR5UHJpdmF0ZUtleSIsImNvbnRhY3RzIiwiY29udmVyc2F0aW9ucyIsImN1cnJlbnRDb252ZXJzYXRpb24iLCJtZXNzYWdlcyIsIk1hcCIsIm9ubGluZVVzZXJzIiwiU2V0IiwidHlwaW5nVXNlcnMiLCJjYWxsSGlzdG9yeSIsImxvZ2luIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImtleXMiLCJyZXNwb25zZSIsImdldEN1cnJlbnRVc2VyIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsImFjY2Vzc190b2tlbiIsImxvYWQiLCJuZWVkc1VwbG9hZCIsInB1YmxpY19rZXkiLCJrZXlNaXNtYXRjaCIsImlzQ29uc2lzdGVudCIsInZlcmlmeUtleUNvbnNpc3RlbmN5IiwiY29uc29sZSIsIndhcm4iLCJsb2ciLCJidW5kbGUiLCJwcml2YXRlS2V5cyIsInNpZ25lZFByZWtleVByaXZhdGUiLCJzaWduZWRQcmVrZXkiLCJzaWduZWRQcmVrZXlTaWduYXR1cmUiLCJpZGVudGl0eVByaXZhdGUiLCJvbmVUaW1lUHJla2V5cyIsInNhdmUiLCJpc1ZhbGlkUGFpciIsImNvcnJlY3RQdWJsaWNLZXkiLCJzdWJzdHJpbmciLCJwdWJsaWNLZXlUb1VwbG9hZCIsInVwbG9hZEtleXMiLCJpZGVudGl0eV9rZXkiLCJzaWduZWRfcHJla2V5Iiwic2lnbmVkX3ByZWtleV9zaWduYXR1cmUiLCJvbmVfdGltZV9wcmVrZXlzIiwic2VydmVyTm93SGFzIiwidXBsb2FkRXJyb3IiLCJkYXRhIiwibG9jYWxTZXJ2ZXJNYXRjaCIsImxvY2FsUHViS2V5Iiwic2VydmVyUHViS2V5IiwibG9jYWxQcml2S2V5IiwiTE9DQUxfTUFUQ0hFU19TRVJWRVIiLCJlIiwiY29ubmVjdCIsImlkIiwidG9TdHJpbmciLCJ3aW5kb3ciLCJfd3NIYW5kbGVyc1JlZ2lzdGVyZWQiLCJzZXR1cFdlYlNvY2tldEhhbmRsZXJzIiwiZGV0YWlsIiwicmVnaXN0ZXIiLCJlbWFpbCIsImRldmljZUlkIiwiTWF0aCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJzbGljZSIsImxvZ291dCIsImRpc2Nvbm5lY3QiLCJyZW1vdmVJdGVtIiwic2V0VG9rZW4iLCJpbml0aWFsaXplV2ViU29ja2V0IiwibG9hZFN0b3JlZEF1dGgiLCJnZXRJdGVtIiwibG9hZFBlcnNpc3RlZERhdGEiLCJzeW5jV2l0aFNlcnZlciIsImNhdGNoIiwiZ2VuZXJhdGVBbmRVcGxvYWRLZXlzIiwia2V5UGFpciIsInNpZ25pbmdQYWlyIiwibG9hZFN0b3JlZEtleXMiLCJsb2FkQ29udGFjdHMiLCJnZXRDb250YWN0cyIsImxvYWRDb252ZXJzYXRpb25zIiwiZ2V0Q29udmVyc2F0aW9ucyIsImxvYWRNZXNzYWdlcyIsImdldENvbnZlcnNhdGlvbiIsIm1zZyIsImVuY3J5cHRlZF9jb250ZW50IiwiX2RlY3J5cHRlZENvbnRlbnQiLCJlbmNyeXB0ZWREYXRhIiwiSlNPTiIsInBhcnNlIiwiZmFsbGJhY2tQdWJsaWNLZXkiLCJzZW5kZXJfdXNlcm5hbWUiLCJmaW5kIiwiYyIsImNvbnRhY3RfdXNlcm5hbWUiLCJyZWNpcGllbnRfdXNlcm5hbWUiLCJjb250YWN0IiwiZGVjcnlwdGVkIiwibmV3TWVzc2FnZXMiLCJzZW5kTWVzc2FnZSIsInJlY2lwaWVudFVzZXJuYW1lIiwiY29udGVudCIsIm1lc3NhZ2VUeXBlIiwiZmlsZURhdGEiLCJoYXNQcml2YXRlS2V5IiwiaGFzUHVibGljS2V5IiwiaGFzVXNlciIsInJlY2lwaWVudFB1YmxpY0tleSIsImtleURhdGEiLCJnZXRQdWJsaWNLZXkiLCJFcnJvciIsInJlY2lwaWVudFB1YktleSIsInNlbmRlclByaXZLZXkiLCJzZW5kZXJQdWJLZXkiLCJlbmNyeXB0ZWQiLCJlbmNyeXB0ZWRDb250ZW50Iiwic3RyaW5naWZ5Iiwic2VuZGVyVGhlbWUiLCJjdXJyZW50TWVzc2FnZXMiLCJvcHRpbWlzdGljSWQiLCJvcHRpbWlzdGljTWVzc2FnZSIsInNlbmRlcl9pZCIsInJlY2lwaWVudF9pZCIsIm1lc3NhZ2VfdHlwZSIsInN0YXR1cyIsImV4cGlyeV90eXBlIiwiY3JlYXRlZF9hdCIsInRvSVNPU3RyaW5nIiwic2VuZGVyX3RoZW1lIiwic2VudE1lc3NhZ2UiLCJ1bmRlZmluZWQiLCJ1cGRhdGVkTWVzc2FnZXMiLCJ1c2VyTWVzc2FnZXMiLCJpbmRleCIsImZpbmRJbmRleCIsIm0iLCJwdXNoIiwicGVyc2lzdE1lc3NhZ2UiLCJzdGF0ZUFmdGVyU2VuZCIsImV4aXN0aW5nQ29udkluZGV4IiwiY29udiIsInVwZGF0ZWRDb252IiwibGFzdF9tZXNzYWdlX3RpbWUiLCJsYXN0X21lc3NhZ2VfcHJldmlldyIsInBlcnNpc3RDb252ZXJzYXRpb24iLCJzZXRDdXJyZW50Q29udmVyc2F0aW9uIiwic3RhdGUiLCJuZXdUeXBpbmdVc2VycyIsImRlbGV0ZSIsImFkZENvbnRhY3QiLCJleGlzdGluZ0NvbnYiLCJuZXdDb252ZXJzYXRpb24iLCJ1c2VyX2lkIiwiY29udGFjdF9pZCIsInVucmVhZF9jb3VudCIsImlzX29ubGluZSIsInNlYXJjaFVzZXJzIiwicXVlcnkiLCJhZGRJbmNvbWluZ01lc3NhZ2UiLCJtZXNzYWdlIiwic2VuZGVyVXNlcm5hbWUiLCJleGlzdHMiLCJzb21lIiwiY29udkluZGV4IiwiZXJyIiwibG9hZENhbGxIaXN0b3J5IiwiaGlzdG9yeSIsImdldENhbGxIaXN0b3J5Iiwic2V0VXNlck9ubGluZSIsInVzZXJJZCIsImlzT25saW5lIiwibmV3T25saW5lVXNlcnMiLCJhZGQiLCJzZXRVc2VyVHlwaW5nIiwiaXNUeXBpbmciLCJjbGVhckVycm9yIiwiZGVsZXRlTWVzc2FnZUZvck1lIiwibWVzc2FnZUlkIiwiY29udmVyc2F0aW9uVXNlcm5hbWUiLCJjb252TWVzc2FnZXMiLCJmaWx0ZXIiLCJkZWxldGVNZXNzYWdlIiwiZGVsZXRlTWVzc2FnZUZvckV2ZXJ5b25lIiwibWFwIiwiZGVsZXRlZCIsIm1hcmtNZXNzYWdlQXNEZWxldGVkIiwic2VuZERlbGV0ZU1lc3NhZ2UiLCJjbGVhckNoYXQiLCJjbGVhckNvbnZlcnNhdGlvbk1lc3NhZ2VzIiwiZGVsZXRlQ29udmVyc2F0aW9uRm9yRXZlcnlvbmUiLCJkZWxldGVDb252ZXJzYXRpb24iLCJzZW5kRGVsZXRlQ29udmVyc2F0aW9uIiwiaGFuZGxlUmVtb3RlRGVsZXRlTWVzc2FnZSIsImhhbmRsZVJlbW90ZURlbGV0ZUNvbnZlcnNhdGlvbiIsInN0b3JlZENvbnZlcnNhdGlvbnMiLCJnZXRBbGxDb252ZXJzYXRpb25zIiwibGVuZ3RoIiwic3RvcmVkQ29udGFjdHMiLCJnZXRBbGxDb250YWN0cyIsImNvbnRhY3RfZW1haWwiLCJuaWNrbmFtZSIsImlzX2Jsb2NrZWQiLCJpc192ZXJpZmllZCIsImFkZGVkX2F0IiwibWVzc2FnZXNNYXAiLCJzdG9yZWRNZXNzYWdlcyIsImdldENvbnZlcnNhdGlvbk1lc3NhZ2VzIiwiZW5jcnlwdGVkX2tleSIsImRlbGl2ZXJlZF9hdCIsInJlYWRfYXQiLCJleHBpcmVzX2F0IiwiZmlsZV9tZXRhZGF0YSIsInNpemUiLCJhbGxDb252ZXJzYXRpb25zRGF0YSIsImdldEFsbENvbnZlcnNhdGlvbnNXaXRoTWVzc2FnZXMiLCJzYXZlQ29udmVyc2F0aW9ucyIsInNhdmVDb250YWN0cyIsIk9iamVjdCIsImVudHJpZXMiLCJzYXZlTWVzc2FnZXMiLCJzdG9yZWRNZXNzYWdlIiwic2F2ZU1lc3NhZ2UiLCJjb252ZXJzYXRpb24iLCJzdG9yZWRDb252ZXJzYXRpb24iLCJzYXZlQ29udmVyc2F0aW9uIiwibG9hZEFsbENvbnZlcnNhdGlvbkhpc3RvcnkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJuYW1lIiwicGFydGlhbGl6ZSIsIm9uIiwibWVzc2FnZV9pZCIsInRpbWVzdGFtcCIsInNlbmREZWxpdmVyeVJlY2VpcHQiLCJpc190eXBpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/store.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/themeSync.ts":
/*!******************************!*\
  !*** ./src/lib/themeSync.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bubbleStyles: function() { return /* binding */ bubbleStyles; },\n/* harmony export */   buildMessageTheme: function() { return /* binding */ buildMessageTheme; },\n/* harmony export */   defaultMessageTheme: function() { return /* binding */ defaultMessageTheme; },\n/* harmony export */   fontStyles: function() { return /* binding */ fontStyles; },\n/* harmony export */   getBubbleClasses: function() { return /* binding */ getBubbleClasses; },\n/* harmony export */   getBubbleStyle: function() { return /* binding */ getBubbleStyle; },\n/* harmony export */   getNeonRingStyle: function() { return /* binding */ getNeonRingStyle; },\n/* harmony export */   loadBubbleStyle: function() { return /* binding */ loadBubbleStyle; },\n/* harmony export */   loadFontStyle: function() { return /* binding */ loadFontStyle; },\n/* harmony export */   parseMessageTheme: function() { return /* binding */ parseMessageTheme; },\n/* harmony export */   saveBubbleStyle: function() { return /* binding */ saveBubbleStyle; },\n/* harmony export */   saveFontStyle: function() { return /* binding */ saveFontStyle; }\n/* harmony export */ });\n/* harmony import */ var _useAppearance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useAppearance */ \"(app-pages-browser)/./src/lib/useAppearance.ts\");\n/* __next_internal_client_entry_do_not_use__ bubbleStyles,fontStyles,defaultMessageTheme,buildMessageTheme,getBubbleClasses,getBubbleStyle,getNeonRingStyle,loadBubbleStyle,saveBubbleStyle,loadFontStyle,saveFontStyle,parseMessageTheme auto */ /**\r\n * Theme Sync Module\r\n * Enables sender's theme style to travel with messages\r\n * Unencrypted UI metadata that doesn't affect crypto integrity\r\n */ \n// Bubble style configurations\nconst bubbleStyles = {\n    rounded: {\n        className: \"rounded-2xl shadow-sm\"\n    },\n    glass: {\n        className: \"rounded-2xl backdrop-blur-md bg-opacity-80 shadow-lg border border-white/10\"\n    },\n    neon: {\n        className: \"rounded-2xl shadow-lg\",\n        overlayClassName: \"ring-2 ring-opacity-50\"\n    }\n};\n// Font configurations\nconst fontStyles = {\n    inter: \"font-sans\",\n    mono: \"font-mono\"\n};\n// Default fallback theme\nconst defaultMessageTheme = {\n    bubbleColor: \"#3B82F6\",\n    textColor: \"#ffffff\",\n    style: \"rounded\",\n    font: \"inter\",\n    accentGradient: \"linear-gradient(135deg, #3B82F6, #1D4ED8)\",\n    accentPrimary: \"#3B82F6\",\n    accentSecondary: \"#1D4ED8\"\n};\n// Build theme from current appearance settings\nfunction buildMessageTheme(accent, customStyle, customFont) {\n    const colors = _useAppearance__WEBPACK_IMPORTED_MODULE_0__.accentColors[accent];\n    return {\n        bubbleColor: colors.primary,\n        textColor: \"#ffffff\",\n        style: customStyle || \"rounded\",\n        font: customFont || \"inter\",\n        accentGradient: \"linear-gradient(135deg, \".concat(colors.primary, \", \").concat(colors.secondary, \")\"),\n        accentPrimary: colors.primary,\n        accentSecondary: colors.secondary\n    };\n}\n// Get bubble style classes based on theme\nfunction getBubbleClasses(theme) {\n    const styleConfig = bubbleStyles[theme.style] || bubbleStyles.rounded;\n    const fontClass = fontStyles[theme.font] || fontStyles.inter;\n    return \"\".concat(styleConfig.className, \" \").concat(fontClass);\n}\n// Get inline style for bubble background\nfunction getBubbleStyle(theme) {\n    if (theme.accentGradient) {\n        return {\n            background: theme.accentGradient\n        };\n    }\n    return {\n        backgroundColor: theme.bubbleColor\n    };\n}\n// Get neon ring style if applicable\nfunction getNeonRingStyle(theme) {\n    if (theme.style === \"neon\") {\n        return {\n            boxShadow: \"0 0 15px \".concat(theme.bubbleColor, \"40, 0 0 30px \").concat(theme.bubbleColor, \"20\")\n        };\n    }\n    return undefined;\n}\n// Storage key for custom bubble style preference\nconst BUBBLE_STYLE_KEY = \"cipherlink_bubble_style\";\nconst FONT_STYLE_KEY = \"cipherlink_font_style\";\n// Load saved bubble style preference\nfunction loadBubbleStyle() {\n    if (false) {}\n    try {\n        const saved = localStorage.getItem(BUBBLE_STYLE_KEY);\n        if (saved && [\n            \"rounded\",\n            \"glass\",\n            \"neon\"\n        ].includes(saved)) {\n            return saved;\n        }\n    } catch (e) {\n        console.error(\"Failed to load bubble style:\", e);\n    }\n    return \"rounded\";\n}\n// Save bubble style preference\nfunction saveBubbleStyle(style) {\n    if (false) {}\n    try {\n        localStorage.setItem(BUBBLE_STYLE_KEY, style);\n    } catch (e) {\n        console.error(\"Failed to save bubble style:\", e);\n    }\n}\n// Load saved font style preference\nfunction loadFontStyle() {\n    if (false) {}\n    try {\n        const saved = localStorage.getItem(FONT_STYLE_KEY);\n        if (saved && [\n            \"inter\",\n            \"mono\"\n        ].includes(saved)) {\n            return saved;\n        }\n    } catch (e) {\n        console.error(\"Failed to load font style:\", e);\n    }\n    return \"inter\";\n}\n// Save font style preference\nfunction saveFontStyle(font) {\n    if (false) {}\n    try {\n        localStorage.setItem(FONT_STYLE_KEY, font);\n    } catch (e) {\n        console.error(\"Failed to save font style:\", e);\n    }\n}\n// Parse theme from message if present\nfunction parseMessageTheme(messageData) {\n    try {\n        if (messageData === null || messageData === void 0 ? void 0 : messageData.theme) {\n            const theme = messageData.theme;\n            // Validate theme object\n            if (theme.bubbleColor && theme.textColor && theme.style && theme.font) {\n                return {\n                    bubbleColor: theme.bubbleColor,\n                    textColor: theme.textColor,\n                    style: [\n                        \"rounded\",\n                        \"glass\",\n                        \"neon\"\n                    ].includes(theme.style) ? theme.style : \"rounded\",\n                    font: [\n                        \"inter\",\n                        \"mono\"\n                    ].includes(theme.font) ? theme.font : \"inter\",\n                    accentGradient: theme.accentGradient,\n                    accentPrimary: theme.accentPrimary,\n                    accentSecondary: theme.accentSecondary\n                };\n            }\n        }\n    } catch (e) {\n        console.warn(\"Failed to parse message theme:\", e);\n    }\n    return null;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdGhlbWVTeW5jLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7a1BBRUE7Ozs7Q0FJQyxHQUUyRDtBQW9CNUQsOEJBQThCO0FBQ3ZCLE1BQU1DLGVBR1I7SUFDREMsU0FBUztRQUNMQyxXQUFXO0lBQ2Y7SUFDQUMsT0FBTztRQUNIRCxXQUFXO0lBQ2Y7SUFDQUUsTUFBTTtRQUNGRixXQUFXO1FBQ1hHLGtCQUFrQjtJQUN0QjtBQUNKLEVBQUU7QUFFRixzQkFBc0I7QUFDZixNQUFNQyxhQUErQztJQUN4REMsT0FBTztJQUNQQyxNQUFNO0FBQ1YsRUFBRTtBQUVGLHlCQUF5QjtBQUNsQixNQUFNQyxzQkFBb0M7SUFDN0NDLGFBQWE7SUFDYkMsV0FBVztJQUNYQyxPQUFPO0lBQ1BDLE1BQU07SUFDTkMsZ0JBQWdCO0lBQ2hCQyxlQUFlO0lBQ2ZDLGlCQUFpQjtBQUNyQixFQUFFO0FBRUYsK0NBQStDO0FBQ3hDLFNBQVNDLGtCQUFrQkMsTUFBbUIsRUFBRUMsV0FBMEMsRUFBRUMsVUFBNkI7SUFDNUgsTUFBTUMsU0FBU3RCLHdEQUFZLENBQUNtQixPQUFPO0lBQ25DLE9BQU87UUFDSFIsYUFBYVcsT0FBT0MsT0FBTztRQUMzQlgsV0FBVztRQUNYQyxPQUFPTyxlQUFlO1FBQ3RCTixNQUFNTyxjQUFjO1FBQ3BCTixnQkFBZ0IsMkJBQThDTyxPQUFuQkEsT0FBT0MsT0FBTyxFQUFDLE1BQXFCLE9BQWpCRCxPQUFPRSxTQUFTLEVBQUM7UUFDL0VSLGVBQWVNLE9BQU9DLE9BQU87UUFDN0JOLGlCQUFpQkssT0FBT0UsU0FBUztJQUNyQztBQUNKO0FBRUEsMENBQTBDO0FBQ25DLFNBQVNDLGlCQUFpQkMsS0FBbUI7SUFDaEQsTUFBTUMsY0FBYzFCLFlBQVksQ0FBQ3lCLE1BQU1iLEtBQUssQ0FBQyxJQUFJWixhQUFhQyxPQUFPO0lBQ3JFLE1BQU0wQixZQUFZckIsVUFBVSxDQUFDbUIsTUFBTVosSUFBSSxDQUFD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LGlCQUFpQlMsTUFBTVQsZUFBZTtnQkFDMUM7WUFDSjtRQUNKO0lBQ0osRUFBRSxPQUFPeUIsR0FBRztRQUNSQyxRQUFRUSxJQUFJLENBQUMsa0NBQWtDVDtJQUNuRDtJQUNBLE9BQU87QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3RoZW1lU3luYy50cz84ZWVhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuXHJcbi8qKlxyXG4gKiBUaGVtZSBTeW5jIE1vZHVsZVxyXG4gKiBFbmFibGVzIHNlbmRlcidzIHRoZW1lIHN0eWxlIHRvIHRyYXZlbCB3aXRoIG1lc3NhZ2VzXHJcbiAqIFVuZW5jcnlwdGVkIFVJIG1ldGFkYXRhIHRoYXQgZG9lc24ndCBhZmZlY3QgY3J5cHRvIGludGVncml0eVxyXG4gKi9cclxuXHJcbmltcG9ydCB7IEFjY2VudENvbG9yLCBhY2NlbnRDb2xvcnMgfSBmcm9tICcuL3VzZUFwcGVhcmFuY2UnO1xyXG5cclxuLy8gVGhlbWUgbWV0YWRhdGEgdGhhdCB0cmF2ZWxzIHdpdGggZWFjaCBtZXNzYWdlXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZVRoZW1lIHtcclxuICAgIGJ1YmJsZUNvbG9yOiBzdHJpbmc7XHJcbiAgICB0ZXh0Q29sb3I6IHN0cmluZztcclxuICAgIHN0eWxlOiAncm91bmRlZCcgfCAnZ2xhc3MnIHwgJ25lb24nO1xyXG4gICAgZm9udDogJ2ludGVyJyB8ICdtb25vJztcclxuICAgIGFjY2VudEdyYWRpZW50Pzogc3RyaW5nO1xyXG4gICAgYWNjZW50UHJpbWFyeT86IHN0cmluZztcclxuICAgIGFjY2VudFNlY29uZGFyeT86IHN0cmluZztcclxufVxyXG5cclxuLy8gRXh0ZW5kZWQgbWVzc2FnZSB3aXRoIHRoZW1lXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGhlbWVkTWVzc2FnZSB7XHJcbiAgICBjaXBoZXJ0ZXh0OiBzdHJpbmc7XHJcbiAgICB0aGVtZTogTWVzc2FnZVRoZW1lO1xyXG4gICAgW2tleTogc3RyaW5nXTogYW55O1xyXG59XHJcblxyXG4vLyBCdWJibGUgc3R5bGUgY29uZmlndXJhdGlvbnNcclxuZXhwb3J0IGNvbnN0IGJ1YmJsZVN0eWxlczogUmVjb3JkPCdyb3VuZGVkJyB8ICdnbGFzcycgfCAnbmVvbicsIHtcclxuICAgIGNsYXNzTmFtZTogc3RyaW5nO1xyXG4gICAgb3ZlcmxheUNsYXNzTmFtZT86IHN0cmluZztcclxufT4gPSB7XHJcbiAgICByb3VuZGVkOiB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiAncm91bmRlZC0yeGwgc2hhZG93LXNtJyxcclxuICAgIH0sXHJcbiAgICBnbGFzczoge1xyXG4gICAgICAgIGNsYXNzTmFtZTogJ3JvdW5kZWQtMnhsIGJhY2tkcm9wLWJsdXItbWQgYmctb3BhY2l0eS04MCBzaGFkb3ctbGcgYm9yZGVyIGJvcmRlci13aGl0ZS8xMCcsXHJcbiAgICB9LFxyXG4gICAgbmVvbjoge1xyXG4gICAgICAgIGNsYXNzTmFtZTogJ3JvdW5kZWQtMnhsIHNoYWRvdy1sZycsXHJcbiAgICAgICAgb3ZlcmxheUNsYXNzTmFtZTogJ3JpbmctMiByaW5nLW9wYWNpdHktNTAnLFxyXG4gICAgfSxcclxufTtcclxuXHJcbi8vIEZvbnQgY29uZmlndXJhdGlvbnNcclxuZXhwb3J0IGNvbnN0IGZvbnRTdHlsZXM6IFJlY29yZDwnaW50ZXInIHwgJ21vbm8nLCBzdHJpbmc+ID0ge1xyXG4gICAgaW50ZXI6ICdmb250LXNhbnMnLFxyXG4gICAgbW9ubzogJ2ZvbnQtbW9ubycsXHJcbn07XHJcblxyXG4vLyBEZWZhdWx0IGZhbGxiYWNrIHRoZW1lXHJcbmV4cG9ydCBjb25zdCBkZWZhdWx0TWVzc2FnZVRoZW1lOiBNZXNzYWdlVGhlbWUgPSB7XHJcbiAgICBidWJibGVDb2xvcjogJyMzQjgyRjYnLFxyXG4gICAgdGV4dENvbG9yOiAnI2ZmZmZmZicsXHJcbiAgICBzdHlsZTogJ3JvdW5kZWQnLFxyXG4gICAgZm9udDogJ2ludGVyJyxcclxuICAgIGFjY2VudEdyYWRpZW50OiAnbGluZWFyLWdyYWRpZW50KDEzNWRlZywgIzNCODJGNiwgIzFENEVEOCknLFxyXG4gICAgYWNjZW50UHJpbWFyeTogJyMzQjgyRjYnLFxyXG4gICAgYWNjZW50U2Vjb25kYXJ5OiAnIzFENEVEOCcsXHJcbn07XHJcblxyXG4vLyBCdWlsZCB0aGVtZSBmcm9tIGN1cnJlbnQgYXBwZWFyYW5jZSBzZXR0aW5nc1xyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRNZXNzYWdlVGhlbWUoYWNjZW50OiBBY2NlbnRDb2xvciwgY3VzdG9tU3R5bGU/OiAncm91bmRlZCcgfCAnZ2xhc3MnIHwgJ25lb24nLCBjdXN0b21Gb250PzogJ2ludGVyJyB8ICdtb25vJyk6IE1lc3NhZ2VUaGVtZSB7XHJcbiAgICBjb25zdCBjb2xvcnMgPSBhY2NlbnRDb2xvcnNbYWNjZW50XTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYnViYmxlQ29sb3I6IGNvbG9ycy5wcmltYXJ5LFxyXG4gICAgICAgIHRleHRDb2xvcjogJyNmZmZmZmYnLFxyXG4gICAgICAgIHN0eWxlOiBjdXN0b21TdHlsZSB8fCAncm91bmRlZCcsXHJcbiAgICAgICAgZm9udDogY3VzdG9tRm9udCB8fCAnaW50ZXInLFxyXG4gICAgICAgIGFjY2VudEdyYWRpZW50OiBgbGluZWFyLWdyYWRpZW50KDEzNWRlZywgJHtjb2xvcnMucHJpbWFyeX0sICR7Y29sb3JzLnNlY29uZGFyeX0pYCxcclxuICAgICAgICBhY2NlbnRQcmltYXJ5OiBjb2xvcnMucHJpbWFyeSxcclxuICAgICAgICBhY2NlbnRTZWNvbmRhcnk6IGNvbG9ycy5zZWNvbmRhcnksXHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyBHZXQgYnViYmxlIHN0eWxlIGNsYXNzZXMgYmFzZWQgb24gdGhlbWVcclxuZXhwb3J0IGZ1bmN0aW9uIGdldEJ1YmJsZUNsYXNzZXModGhlbWU6IE1lc3NhZ2VUaGVtZSk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBzdHlsZUNvbmZpZyA9IGJ1YmJsZVN0eWxlc1t0aGVtZS5zdHlsZV0gfHwgYnViYmxlU3R5bGVzLnJvdW5kZWQ7XHJcbiAgICBjb25zdCBmb250Q2xhc3MgPSBmb250U3R5bGVzW3RoZW1lLmZvbnRdIHx8IGZvbnRTdHlsZXMuaW50ZXI7XHJcbiAgICByZXR1cm4gYCR7c3R5bGVDb25maWcuY2xhc3NOYW1lfSAke2ZvbnRDbGFzc31gO1xyXG59XHJcblxyXG4vLyBHZXQgaW5saW5lIHN0eWxlIGZvciBidWJibGUgYmFja2dyb3VuZFxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnViYmxlU3R5bGUodGhlbWU6IE1lc3NhZ2VUaGVtZSk6IFJlYWN0LkNTU1Byb3BlcnRpZXMge1xyXG4gICAgaWYgKHRoZW1lLmFjY2VudEdyYWRpZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHsgYmFja2dyb3VuZDogdGhlbWUuYWNjZW50R3JhZGllbnQgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGJhY2tncm91bmRDb2xvcjogdGhlbWUuYnViYmxlQ29sb3IgfTtcclxufVxyXG5cclxuLy8gR2V0IG5lb24gcmluZyBzdHlsZSBpZiBhcHBsaWNhYmxlXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXROZW9uUmluZ1N0eWxlKHRoZW1lOiBNZXNzYWdlVGhlbWUpOiBSZWFjdC5DU1NQcm9wZXJ0aWVzIHwgdW5kZWZpbmVkIHtcclxuICAgIGlmICh0aGVtZS5zdHlsZSA9PT0gJ25lb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYm94U2hhZG93OiBgMCAwIDE1cHggJHt0aGVtZS5idWJibGVDb2xvcn00MCwgMCAwIDMwcHggJHt0aGVtZS5idWJibGVDb2xvcn0yMGAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbi8vIFN0b3JhZ2Uga2V5IGZvciBjdXN0b20gYnViYmxlIHN0eWxlIHByZWZlcmVuY2VcclxuY29uc3QgQlVCQkxFX1NUWUxFX0tFWSA9ICdjaXBoZXJsaW5rX2J1YmJsZV9zdHlsZSc7XHJcbmNvbnN0IEZPTlRfU1RZTEVfS0VZID0gJ2NpcGhlcmxpbmtfZm9udF9zdHlsZSc7XHJcblxyXG4vLyBMb2FkIHNhdmVkIGJ1YmJsZSBzdHlsZSBwcmVmZXJlbmNlXHJcbmV4cG9ydCBmdW5jdGlvbiBsb2FkQnViYmxlU3R5bGUoKTogJ3JvdW5kZWQnIHwgJ2dsYXNzJyB8ICduZW9uJyB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiAncm91bmRlZCc7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHNhdmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oQlVCQkxFX1NUWUxFX0tFWSk7XHJcbiAgICAgICAgaWYgKHNhdmVkICYmIFsncm91bmRlZCcsICdnbGFzcycsICduZW9uJ10uaW5jbHVkZXMoc2F2ZWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzYXZlZCBhcyAncm91bmRlZCcgfCAnZ2xhc3MnIHwgJ25lb24nO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBidWJibGUgc3R5bGU6JywgZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ3JvdW5kZWQnO1xyXG59XHJcblxyXG4vLyBTYXZlIGJ1YmJsZSBzdHlsZSBwcmVmZXJlbmNlXHJcbmV4cG9ydCBmdW5jdGlvbiBzYXZlQnViYmxlU3R5bGUoc3R5bGU6ICdyb3VuZGVkJyB8ICdnbGFzcycgfCAnbmVvbicpOiB2b2lkIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShCVUJCTEVfU1RZTEVfS0VZLCBzdHlsZSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgYnViYmxlIHN0eWxlOicsIGUpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBMb2FkIHNhdmVkIGZvbnQgc3R5bGUgcHJlZmVyZW5jZVxyXG5leHBvcnQgZnVuY3Rpb24gbG9hZEZvbnRTdHlsZSgpOiAnaW50ZXInIHwgJ21vbm8nIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuICdpbnRlcic7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHNhdmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oRk9OVF9TVFlMRV9LRVkpO1xyXG4gICAgICAgIGlmIChzYXZlZCAmJiBbJ2ludGVyJywgJ21vbm8nXS5pbmNsdWRlcyhzYXZlZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNhdmVkIGFzICdpbnRlcicgfCAnbW9ubyc7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGZvbnQgc3R5bGU6JywgZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ2ludGVyJztcclxufVxyXG5cclxuLy8gU2F2ZSBmb250IHN0eWxlIHByZWZlcmVuY2VcclxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVGb250U3R5bGUoZm9udDogJ2ludGVyJyB8ICdtb25vJyk6IHZvaWQge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEZPTlRfU1RZTEVfS0VZLCBmb250KTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBmb250IHN0eWxlOicsIGUpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBQYXJzZSB0aGVtZSBmcm9tIG1lc3NhZ2UgaWYgcHJlc2VudFxyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNZXNzYWdlVGhlbWUobWVzc2FnZURhdGE6IGFueSk6IE1lc3NhZ2VUaGVtZSB8IG51bGwge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAobWVzc2FnZURhdGE/LnRoZW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRoZW1lID0gbWVzc2FnZURhdGEudGhlbWU7XHJcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoZW1lIG9iamVjdFxyXG4gICAgICAgICAgICBpZiAodGhlbWUuYnViYmxlQ29sb3IgJiYgdGhlbWUudGV4dENvbG9yICYmIHRoZW1lLnN0eWxlICYmIHRoZW1lLmZvbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlQ29sb3I6IHRoZW1lLmJ1YmJsZUNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogdGhlbWUudGV4dENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBbJ3JvdW5kZWQnLCAnZ2xhc3MnLCAnbmVvbiddLmluY2x1ZGVzKHRoZW1lLnN0eWxlKSA/IHRoZW1lLnN0eWxlIDogJ3JvdW5kZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvbnQ6IFsnaW50ZXInLCAnbW9ubyddLmluY2x1ZGVzKHRoZW1lLmZvbnQpID8gdGhlbWUuZm9udCA6ICdpbnRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgYWNjZW50R3JhZGllbnQ6IHRoZW1lLmFjY2VudEdyYWRpZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGFjY2VudFByaW1hcnk6IHRoZW1lLmFjY2VudFByaW1hcnksXHJcbiAgICAgICAgICAgICAgICAgICAgYWNjZW50U2Vjb25kYXJ5OiB0aGVtZS5hY2NlbnRTZWNvbmRhcnksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIG1lc3NhZ2UgdGhlbWU6JywgZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4iXSwibmFtZXMiOlsiYWNjZW50Q29sb3JzIiwiYnViYmxlU3R5bGVzIiwicm91bmRlZCIsImNsYXNzTmFtZSIsImdsYXNzIiwibmVvbiIsIm92ZXJsYXlDbGFzc05hbWUiLCJmb250U3R5bGVzIiwiaW50ZXIiLCJtb25vIiwiZGVmYXVsdE1lc3NhZ2VUaGVtZSIsImJ1YmJsZUNvbG9yIiwidGV4dENvbG9yIiwic3R5bGUiLCJmb250IiwiYWNjZW50R3JhZGllbnQiLCJhY2NlbnRQcmltYXJ5IiwiYWNjZW50U2Vjb25kYXJ5IiwiYnVpbGRNZXNzYWdlVGhlbWUiLCJhY2NlbnQiLCJjdXN0b21TdHlsZSIsImN1c3RvbUZvbnQiLCJjb2xvcnMiLCJwcmltYXJ5Iiwic2Vjb25kYXJ5IiwiZ2V0QnViYmxlQ2xhc3NlcyIsInRoZW1lIiwic3R5bGVDb25maWciLCJmb250Q2xhc3MiLCJnZXRCdWJibGVTdHlsZSIsImJhY2tncm91bmQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJnZXROZW9uUmluZ1N0eWxlIiwiYm94U2hhZG93IiwidW5kZWZpbmVkIiwiQlVCQkxFX1NUWUxFX0tFWSIsIkZPTlRfU1RZTEVfS0VZIiwibG9hZEJ1YmJsZVN0eWxlIiwic2F2ZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiaW5jbHVkZXMiLCJlIiwiY29uc29sZSIsImVycm9yIiwic2F2ZUJ1YmJsZVN0eWxlIiwic2V0SXRlbSIsImxvYWRGb250U3R5bGUiLCJzYXZlRm9udFN0eWxlIiwicGFyc2VNZXNzYWdlVGhlbWUiLCJtZXNzYWdlRGF0YSIsIndhcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/themeSync.ts\n"));

/***/ })

});